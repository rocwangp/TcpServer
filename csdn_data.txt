小白想问一下这个程序错在哪里#include<stdio.h>
 int main(void)
  {
  double a,b,c;
  pintf("请输入您的年龄");
  scanf("%f",&a);
  pintf("请选择您需要转换的单位（转化“年”输入数字“1”。 转换 “小时 ”输入数字“24”"); 
  scanf("%d",&b);
  c=b*365;
  printf("恭喜您存在超过%g年/小时",a*c) ;
  
  
  return 0;








   }


c++重载赋值运算符无效c++
重载
赋值运算符
类



以上是重载部分


这是想在另一个类里使用，但是报错，哪里出问题了？？


一道算法题，大家有没有什么思路算法 
c/c++

                  题目如下：一棵 n 个结点的有根树，标号为 1 到 n，1 号结点为根结点，树的每个
叶子结点有一只蚂蚁。每一秒钟每只蚂蚁可以选择不动或者爬到相邻的一个结点。除了根节
点，其他结点每个时刻最多只能有一只蚂蚁，问开始后最少经过多少秒，所有蚂蚁都能爬到
根节点。

输入的第一行为数字 n (2 ≤ n ≤ 10 5 ) ，表示树的结点个数。
接下来第 n - 1 行，每行包含 2 个整数 u, v (1 ≤ u, v ≤ n) ，表示树边（不保证 u 是 v 的
父亲，也有可能 v 是 u 的父亲）。保证输入的必然是一棵树。

对于输入的数据如何生成这棵树以及蚂蚁如何爬才能时间最短。大家有啥思路没？


大佬们，求解答，不胜感激。关于c语言中结构体的赋值问题，我想问赋值的时候ret->header.next 这里为什么是用点而不是用->?结构体
赋值


typedef struct _tag_LinkListNode LinkListNode;
struct _tag_LinkListNode
{
	LinkListNode* next;	
};

typedef struct _tag_LinkList	 
{
	LinkListNode header;
	int length;
}TLinkList;			 

LinkList* LinkList_Create()
{
	TLinkList* ret = (TLinkList*)malloc(sizeof(TLinkList*));	

	if(ret != NULL)
	{
		ret->header.next = NULL;	 
		ret->length = 0;	 
	}

	return ret;
}
看你声明的时候用的是什么。
用对象声明的就用.
用指针对象声明的就用->
这是规范吧
通过结构指针访问成员用->
通过结构本身访问成员用.
TLinkList* ret = (TLinkList*)malloc(sizeof(TLinkList*)); 
ret是指针所以用ret->header
而LinkListNode header;所以header是结构体，不是指针
所以用ret->header.next = NULL;
豁然开朗，谢谢两位
关于 点 和箭头的区别，请看以下代码图片，书上有详细的说法
(*p).x  指针p先用*解引用，然后取结构体中的成员x，需要写个()，为了美观 就写成 p->x 这种写法
有箭头我就可以推断左边是个指针变量，用点说面 s.x 说明左边s 是个结构体

*


请各位前辈来指点一下迷津c++
c++提问
新手报到

                  初学doge触及到了知识盲区
代码如图：

想知道应该怎样修改才能有效删除影藏文件
还有一个问题 就是 怎样编程序能够用程序员的身份打开一个文件呢？
感觉不是书上用outfile.open那么简单
谢谢每一个进来看过的人哦
图片好像上传不了 这边网太卡了
代码如下：
#include <iostream>
#include <string>
#include <windows.h>
using namespace std;

int main()
{
	string fname;
	cout << "请输入文件名：" << endl;
	cin >> fname;
	if (DeleteFile(fname))
		cout << "删除成功！" << endl;
	else cout << "失败！！！" << endl;
    return 0;
}

一直提示说string和lpcwster不能转换 很困扰
http://blog.csdn.net/thecentry/article/details/78378487 
里面有一个string到wstring的转换！因为Windows的API大多用unicode的！
方法二：你试试把string改成wsting
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <string>
using namespace std;
int main()
{
string fname;
cout << "请输入文件名：" << endl;
cin >> fname;
if (!remove(fname))
cout << "删除成功！" << endl;
else cout << "失败！！！" << strerror(errno) << endl;
    return 0;
}
引用 3 楼 zhao4zhong1 的回复: 
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <string>
using namespace std;
int main()
{
string fname;
cout << "请输入文件名：" << endl;
cin >> fname;
if (!remove(fname))
cout << "删除成功！" << endl;
else cout << "失败！！！" << strerror(errno) << endl;
    return 0;
}

二楼的回复有点复杂我还没搞懂 就先试了试这个 这个程序我把string改成了char倒是通过了编译 但是输入文件名之后 没有cout 输出
就没反应了是怎么回事呢 会不会跟要删除的文件是隐藏文件有关呢？还是输入文件名不带路径呢？望老师解答
输入文件名请带全部绝对路径。
参考以下cmd下可用的命令：
attrib
del
runas
引用 6 楼 zhao4zhong1 的回复:参考以下cmd下可用的命令：
attrib
del
runas
谢谢您！ 想知道在c++中应用cmd命令的格式是否为：
#include <stdlib.h>

system(\"attrib -h E:\123.txt\") 呢 如果错误能否指点一下正确的呢 实在感谢
#include <iostream>
#include <string>
#include <windows.h>
using namespace std;
BOOL StringToWString(const std::string &str, std::wstring &wstr)
{
	int nLen = (int)str.length();
	wstr.resize(nLen, L' ');

	int nResult = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)str.c_str(), nLen, (LPWSTR)wstr.c_str(), nLen);

	if (nResult == 0)
	{
		return FALSE;
	}

	return TRUE;
}
int main()
{
	string fname;
	cout << "请输入文件名：" << endl;
	cin >> fname;
	wstring result;
	StringToWString(fname, result);
	if (DeleteFile((LPCWSTR)result.c_str()))
		cout << "删除成功！" << endl;
	else cout << "失败！！！" << endl;
	return 0;
}
这就是二楼要说的，哈哈！昨天晚上没有电脑就没有写；不过我觉得你们对系统API的调用比我强好多！
引用 3 楼 zhao4zhong1 的回复:#include <stdio.h>
#include <string.h>
#include <iostream>
#include <string>
using namespace std;
int main()
{
string fname;
cout << "请输入文件名：" << endl;
cin >> fname;
if (!remove(fname))
cout << "删除成功！" << endl;
else cout << "失败！！！" << strerror(errno) << endl;
    return 0;
}

这个程序应该这么写吧
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <string>
using namespace std;
int main()
{
	string fname;
	cout << "请输入文件名：" << endl;
	cin >> fname;
	if (!remove(fname.c_str()))
		cout << "删除成功！" << endl;
	else cout << "失败！！！" << strerror(errno) << endl;
	return 0;
}
我在我的电脑上这么写，操作正常
楼上的解答很可以 但是那个Wstring 和string的转化那个还是不行 编译之后提醒少了一个头文件 我添加之后又说找不到这个文件 en。。我不懂怎么回事 调试了一下还是不行 只能再次询问了
 
还想再问一个问题 
用#include <stdlib.h>
 system("attrib -h E:\123.txt")

为什么编译结果是找不到这个文件呢？不好意思问题太多了
引用 1 楼 zzerono 的回复:图片好像上传不了 这边网太卡了
代码如下：
#include <iostream>
#include <string>
#include <windows.h>
using namespace std;

int main()
{
	string fname;
	cout << "请输入文件名：" << endl;
	cin >> fname;
	if (DeleteFile(fname))
		cout << "删除成功！" << endl;
	else cout << "失败！！！" << endl;
    return 0;
}

一直提示说string和lpcwster不能转换 很困扰
DeleteFile参数的类型不对
windows api函数DeleteFile的参数需要是c风格的字符串，你给string，当然不对，参数要用fname.c_str()
引用 10 楼 zzerono 的回复:楼上的解答很可以 但是那个Wstring 和string的转化那个还是不行 编译之后提醒少了一个头文件 我添加之后又说找不到这个文件 en。。我不懂怎么回事 调试了一下还是不行 只能再次询问了
 
还想再问一个问题 
用#include <stdlib.h>
 system("attrib -h E:\123.txt")

为什么编译结果是找不到这个文件呢？不好意思问题太多了
你确定你是copy的我的程序？我贴出来的代码都是经过测试可行的哟！
引用 11 楼 ananluowei 的回复:Quote: 引用 1 楼 zzerono 的回复:
图片好像上传不了 这边网太卡了
代码如下：
#include <iostream>
#include <string>
#include <windows.h>
using namespace std;

int main()
{
	string fname;
	cout << "请输入文件名：" << endl;
	cin >> fname;
	if (DeleteFile(fname))
		cout << "删除成功！" << endl;
	else cout << "失败！！！" << endl;
    return 0;
}

一直提示说string和lpcwster不能转换 很困扰
DeleteFile参数的类型不对
windows api函数DeleteFile的参数需要是c风格的字符串，你给string，当然不对，参数要用fname.c_str()
主要的问题还是char 转 wchar的问题，我觉得！因为API多用Unicode
system("attrib -h E:\\123.txt")
引用 13 楼 thecentry 的回复:Quote: 引用 11 楼 ananluowei 的回复:
Quote: 引用 1 楼 zzerono 的回复:
图片好像上传不了 这边网太卡了
代码如下：
#include <iostream>
#include <string>
#include <windows.h>
using namespace std;

int main()
{
	string fname;
	cout << "请输入文件名：" << endl;
	cin >> fname;
	if (DeleteFile(fname))
		cout << "删除成功！" << endl;
	else cout << "失败！！！" << endl;
    return 0;
}

一直提示说string和lpcwster不能转换 很困扰
DeleteFile参数的类型不对
windows api函数DeleteFile的参数需要是c风格的字符串，你给string，当然不对，参数要用fname.c_str()
主要的问题还是char 转 wchar的问题，我觉得！因为API多用Unicode
windows API大多是有2个版本的，一个多字符集，一个Unicode，根据你项目的设置，自动的。
就你的例子来说，如果没设置Unicode字符集，那么用string.c_str()，如果设置了Unicode ，那么是用wstring.c_str()
怨人不如自怨，求诸人不如求之己
感谢各位的回答
初学狗今天也一样在为编程头痛
真心觉得学计算机挺好的 就是头实在有点冷哈哈哈哈

估计以后还是会有很多问题 希望自己能不断成长吧


不知道为什么，求和得出的结果是错的，求大神解释一下刚刚读大一，很多还不懂，谢谢大家的帮忙~
代码是这样的
#include <iostream>  
using namespace std;
int  main()
{  int i, a[4],sum=0;
for (i=1; i<5; )
{ cout<<"请输入第"<<i<<"个人的成绩: ";
cin>>a[i];
sum=sum+a[i];
i=i+1;
}
cout<<"sum="<<sum;
return 0;
}

要求是这个。然而我求出来的结果是这样的

还有这种情况……

实在是不明白……看了好久，刚刚接触数组，求大家帮忙看看，谢谢了
a[4]下标是0~3，
for (i=1; i<5; )你这个下标是1~4，最后一个成绩是未定义的，当然结果不对。改成这样：
#include <iostream>  
using namespace std;
int  main()
{  int i, a[4],sum=0;
for (i=0; i<4; )
{ cout<<"请输入第"<<i+1<<"个人的成绩: ";
cin>>a[i];
sum=sum+a[i];
i=i+1;
}
cout<<"sum="<<sum;
return 0;
}
感谢感谢，我懂了


（菜鸟提问）在类内用::调用该类自己的函数为什么是静态调用？多线程
静态

                  最近写了个程序，自己跑没问题，放到公司软件里就崩溃了，不知道什么原因，boss说是公司软件是多线程，不能有静态变量，然后发现我有类似这样的写法：

struct Test
{
        void a();
        void b();
}

Test::a()
{
        Test::b();
}

告诉我这样是不行的，Test::b();这样是隐式静态调用，我改成

Test::a()
{
        b();
}

这样后确实不崩溃了，有没有高人能给我详细讲解一下？
《深度探索C++对象模型》
《C++反汇编与逆向分析技术揭秘》
《Windows核心编程》
就你给出的代码而言，两者没有区别。
问题出在其他地方。
Test::b(); 是类外调用Test类的静态成员函数，如果是普通成员函数，要通过对象或指针来调用：
Test t;
t.fun();
Test *pt=new Test();
pt->fun();
就你写的函数，这2者确实是没有任何区别，你boss也是瞎扯，能否静态调用是看函数原型本身是否声明了static关键字，跟你怎么去调用没关系。问题应该是处在其他地方，你这样写只是偶然规避掉了这个问题。
我确实有些云里雾里的，在类外定义成员函数的时候需要加Test::，怎么在该成员函数里调用其它成员函数加了Test::反而不行，百思不得其解，可能是boss搞错了吧。。。
引用 4 楼 zgxyz2010 的回复:就你写的函数，这2者确实是没有任何区别，你boss也是瞎扯，能否静态调用是看函数原型本身是否声明了static关键字，跟你怎么去调用没关系。问题应该是处在其他地方，你这样写只是偶然规避掉了这个问题。
我确实有些云里雾里的，在类外定义成员函数的时候需要加Test::，怎么在该成员函数里调用其它成员函数加了Test::反而不行，百思不得其解，可能是boss搞错了吧。。。
引用 3 楼 u010165006 的回复:Test::b(); 是类外调用Test类的静态成员函数，如果是普通成员函数，要通过对象或指针来调用：
Test t;
t.fun();
Test *pt=new Test();
pt->fun();
我的Test::b()是在另一个成员函数Test::a()里调用的，这样也是是类外调用静态成员函数？
引用 7 楼 zhangqinghao0811 的回复:Quote: 引用 3 楼 u010165006 的回复:
Test::b(); 是类外调用Test类的静态成员函数，如果是普通成员函数，要通过对象或指针来调用：
Test t;
t.fun();
Test *pt=new Test();
pt->fun();
我的Test::b()是在另一个成员函数Test::a()里调用的，这样也是是类外调用静态成员函数？

成员函数里面调用同类的其它成员函数是类内调用。
好比说在班里，直接喊“小明”就可以了，在班外，要喊 “3班的小明” 。


vs2015下，用C进行正文提取的疑惑c
c++
visual

                  我的想法是用C写一个正文提取，它的源代码直接保存在txt文件中，我现在想要进行对文件的操作，也就是正文提取，去掉链接和标签，留下文本和标题，然后在放进txt中。正则表达式的话我自己也找过很多，但Windows好像没有regex.h库，只有regex库，而且regex库的使用方法好像和网上对regex.h库的介绍不一样。

#include<stdio.h>
#include<malloc.h>
void encode_small_file(FILE *fp, int length) {
	char *pBuf = (char *)malloc(length);

	rewind(fp);//文件指针指向文件头


		fscanf(fp,"%c",pBuf);
		//写文件
		rewind(fp);
	 fwrite(pBuf, 1, length, fp); 

	free(pBuf);
}
main() {
	char sz_file[256] = "";
	FILE*fp = NULL;
	gets(sz_file);
	fp = fopen(sz_file, "rb+");
	if (fp == NULL)
	{
		printf("文件打开失败！\n");
	}
	else
	{
		printf("文件打开成功!\n");
		fseek(fp, 0, SEEK_END);
		long length = ftell(fp);
		rewind(fp);
		encode_small_file(fp, length);

		fclose(fp);
	}
	getchar();

}
仅供参考：//test.c
#include <stdio.h>
int main() {
    int c,s;

    s=0;
    while (1) {
        c=getchar();
        if (EOF==c) break;
        switch (s) {
        case 0:
            if (c=='<') s=1;
            else putchar(c);
        break;
        case 1:
            if (c=='>') s=0;
        break;
        }
    }
    return 0;
}
//C:\test>type in.html
//<!DOCTYPE >
//<html>
//<head>
//<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
//<title>标题</title>
//</head>
//<body>
//内容
//</body>
//</html>
//
//C:\test>test <in.html
//
//
//
//
//标题
//
//
//内容
//
//
//
//C:\test>test <in.html >out.txt
//
//C:\test>type out.txt
//
//
//
//
//标题
//
//
//内容
//
//
//
//C:\test>

使用命令重定向操作符可以使用重定向操作符将命令输入和输出数据流从默认位置重定
向到不同的位置。输入或输出数据流的位置即为句柄。

下表将列出可用的句柄。

句柄      句柄的数字代号 描述
STDIN     0              键盘输入
STDOUT    1              输出到命令提示符窗口
STDERR    2              错误输出到命令提示符窗口
UNDEFINED 3-9            这些句柄由应用程序单独定义，并且是各个工具特定的。

数字 0 到 9 代表前 10 个句柄。可以使用命令 Cmd.exe 运行程序并将该程序前 10 个
句柄中的任何一个重定向。要指定想使用的句柄，可在重定向操作符前面键入该句柄的
数字。如果未定义句柄，则默认的 < 重定向输入操作符是 0，而默认的 > 重定向输出
操作符是 1。键入 > 或 < 操作符之后，必须指定要读取或写入数据的位置。可以指定
文件名或另一个现有的句柄。

要指定重定向到现有句柄，请使用与 (&) 字符，后面接要重定向的句柄号
（例如 &句柄#）。例如，下面的命令可以将句柄 2（即 STDERR）重定向到
句柄 1（即 STDOUT）：

2>&1

下表列出了可用于将输入和输出数据流进行重定向的操作符。

重定向操作符 描述
> 将命令输出写入到文件或设备（例如打印机）中，而不是写在命令提示符窗口或句柄中。
< 从文件中而不是从键盘或句柄中读入命令输入。
>> 将命令输出添加到文件末尾而不删除文件中的信息。
>& 将一个句柄的输出写入到另一个句柄的输入中。
<& 从一个句柄读取输入并将其写入到另一个句柄输出中。
| 从一个命令中读取输出并将其写入另一个命令的输入中。也称作管道。

默认情况下，可以从键盘将命令输入（即 STDIN 句柄）发送到 Cmd.exe，然后由
Cmd.exe 将命令输出（即 STDOUT 句柄）发送到命令提示符窗口。

重定向输入 (<)
要将键盘输入重定向到文件或设备，请使用 < 操作符。例如，要从 File.txt 获取
sort 命令的输入，请键入：

sort<file.txt

File.txt 的内容将以字母顺序列表的方式显示在命令提示符窗口中。

< 操作符可以打开具有只读访问的指定文件名。所以，不能使用该操作符向文件中写入
信息。例如，如果以 <&2 启动程序，则所有试图读取句柄 0 的操作都将失败，因为句
柄 2 最初是以只写访问打开的。

 注意

0 是 < 重定向输入操作符的默认句柄。
重定向输出 (>)
几乎所有的命令都将输出发送到命令提示符窗口。即使将输出发送到驱动器或打印机的
命令也会在命令提示符窗口显示消息和提示。

要将输出从命令提示符窗口重定向到文件或设备，请使用 > 操作符。可以在许多命令中
使用该操作符。例如，要将 dir 输出重定向到 Dirlist.txt，请键入：

dir>dirlist.txt

如果 Dirlist.txt 不存在，Cmd.exe 将创建该文件。如果 Dirlist.txt 存在，Cmd.exe
将使用 dir 命令的输出替换文件中的信息。

要运行 netsh routing dump 命令，然后将输出发送到 Route.cfg，请键入：

netsh routing dump>c:\route.cfg

> 操作符可以打开具有只写访问属性的指定文件。所以，不能使用该操作符读取文件。
例如，如果使用重定向 >&0 启动程序，则所有试图写入句柄 1 的操作都将失败，因为
句柄 0 最初是以只读访问打开的。

 注意

1 是 > 重定向输出操作符的默认句柄。
复制句柄
重定向操作符 & 可以将输出或输入从一个指定句柄复制到另一个指定的句柄。例如，
要将 dir 输出发送到 File.txt 并将错误输出发送到 File.txt，请键入：

dir>c:\file.txt 2>&1

复制句柄时，可以复制该句柄原状态的所有特性。例如，如果一个句柄具有只写访问的
属性，则该句柄的所有副本都具有只写访问属性。不能将一个具有只读访问属性的句柄
复制到另一个具有只写访问属性的句柄。

使用 & 操作符重定向输入和副本
要将重定向输入操作符 (<) 与复制操作符 (&) 一起使用，指定的文件必须已经存在。
如果输入文件存在，Cmd.exe 将以只读方式打开该文件，然后将文件中包含的字符作为
输入发送到此命令（如同从键盘输入一样）。如果指定了句柄，Cmd.exe 将指定的句柄
复制到系统现有的句柄中。

例如，要以句柄 0 输入读取（即 STDIN）的方式打开 File.txt，请键入：

<file.txt

要打开 File.txt，并在内容排序后将输出发送到命令提示符窗口（即 STDOUT），请键入：

sort<file.txt

要查找 File.txt，然后将句柄 1（即 STDOUT）和句柄 2（即 STDERR）重定向到
Search.txt，请键入：

findfile file.txt>search.txt 2<&1

要以句柄 0 输入读取（即 STDIN）的方式复制用户定义句柄 3，请键入：

<&3

使用 & 操作符重定向输出和复制
如果将输出重定向到文件且指定了现有的文件名，Cmd.exe 将以只写方式打开文件并覆
盖该文件内容。如果指定了句柄，Cmd.exe 将文件复制到现有句柄中。

要将用户定义句柄 3 复制到句柄 1，请键入：

>&3

要将包括句柄 2（即 STDERR）的所有输出从 ipconfig 命令重定向到
句柄 1（即 STDOUT），然后将输出重定向到 Output.log，请键入：

ipconfig.exe>>output.log 2>&1

使用 >> 重定向操作符追加输出
要从命令中将输出添加到文件末尾而不丢失文件中已存在的任何信息，请使用两个连续
的大于号（即 >>）。例如，下面的命令可以将由 dir 命令生成的目录列表追加到
Dirlist.txt 文件：

dir>>dirlist.txt

要将 netstat 命令的输出追加到 Tcpinfo.txt 的末尾，请键入：

netstat>>tcpinfo.txt

使用管道操作符 (|)
管道操作符 (|) 可以提取一个命令的输出（默认情况下是 STDOUT），然后将其导入另
一个命令的输入中（默认情况下是 STDIN）。例如，下面的命令将对目录分类：

dir | sort

在本例中，将同时启动两个命令，但随后 sort 命令会暂停，直到它接收到 dir 命令
的输出为止。sort 命令使用 dir 命令的输出作为输入，然后将输出发送到
句柄 1（即 STDOUT）。

合并带重定向操作符的命令
可以通过合并带有其他命令和文件名的筛选器命令创建自定义命令。例如，可以使用以
下命令存储包含“LOG”字符串的文件名:

dir /b | find "LOG" > loglist.txt

dir 命令的输出通过 find 筛选器命令发送。包含字符串 "LOG" 的文件名作为文件名
列表（例如，NetshConfig.log、Logdat.svd 和 Mylog.bat）存储在文件
Loglist.txt 中。

要在相同命令中使用多个筛选器，请使用管道 (|) 分隔筛选器。例如，下面的命令将
搜索 C 盘上的每个目录以查找包含 "LOG" 字符串的文件名，并且在命令提示符窗口中
每次显示一屏：

dir c:\ /s /b | find "LOG" | more

利用管道 (|) 可以将 Cmd.exe 导向为通过 find 筛选器命令发送 dir 命令输出。
find 命令只选择包含字符串 "LOG" 的文件名。more 命令可以显示由 find 命令选择
的文件名（在命令提示符窗口中每次显示一屏）。有关筛选器命令的详细信息，请参阅
使用筛选器。
没看太明白你要做什么？
fscanf(fp,"%c",pBuf);
//写文件
rewind(fp);
fwrite(pBuf, 1, length, fp);  
读一个字符到pBuf中，然后写length  * 1个字节到文件中？
这是做什么？
引用 2 楼 hzy_76 的回复:没看太明白你要做什么？
就是对txt文件读取，按我的想法操作，然后再放回去
引用 3 楼 cfjtaishan 的回复:
fscanf(fp,"%c",pBuf);
//写文件
rewind(fp);
fwrite(pBuf, 1, length, fp);  
读一个字符到pBuf中，然后写length  * 1个字节到文件中？
这是做什么？
每次读一个字节，一共读它的长度个字节（长度*1)
那你的读取没写对啊，这么用fscanf只是读出了一个字节，并没有循环读取至文件结束
使用C++ 有regex库
#include <iostream>
#include <string>
#include <regex>

using namespace std;
int main()
{
    string str("This expression could match from A and beyond. [ expression  express ]");
    string rs = "exp\\w*";  // 正则字符串，exp开始的单词
    cout << str << endl;

    regex expression(rs); // 字符串传递给构造函数，建立正则表达式

// regex_match 判断一个正则表达式(参数 e)是否匹配整个字符序列 str. 它主要用于验证文本。
// 注意，这个正则表达式必须匹配被分析串的全部，否则函数返回 false.
// 如果整个序列被成功匹配，regex_match 返回 True.
    bool ret = regex_match(str, expression);
    if (ret)
        cout << "可以匹配整个文本" << endl;
    else
        cout << "不能匹配整个文本" << endl;

// regex_search 类似于 regex_match, 但它不要求整个字符序列完全匹配。
// 你可以用 regex_search 来查找输入中的一个子序列，该子序列匹配正则表达式 e.
    ret = regex_search(str, expression);
    if (ret)
        cout << "能够搜索到 " << rs << endl;
    else
        cout << "不能搜索" << endl;

// regex_replace 在整个字符序列中查找正则表达式e的所有匹配。
// 这个算法每次成功匹配后，就根据参数fmt对匹配字符串进行格式化。
// 缺省情况下，不匹配的文本不会被修改，即文本会被输出但没有改变。

    str = regex_replace(str, expression, string("表达式"));
// VC2010或者TR1注意：这里第三个参数要用string()转换
// http://www.johndcook.com/cpp_regex.html
// started with C++ TR1 regular expressions
    cout << str << endl;
    return 0;
}
引用 5 楼 qq_40432009 的回复:Quote: 引用 3 楼 cfjtaishan 的回复:

fscanf(fp,"%c",pBuf);
//写文件
rewind(fp);
fwrite(pBuf, 1, length, fp);  
读一个字符到pBuf中，然后写length  * 1个字节到文件中？
这是做什么？
每次读一个字节，一共读它的长度个字节（长度*1)
但是你读也得用循环去读呢，循环length个字节，然后在写。
引用 6 楼 hzy_76 的回复:那你的读取没写对啊，这么用fscanf只是读出了一个字节，并没有循环读取至文件结束
fscanf好像是对整个流操作的，我加了循环和没加循环的结果是一样的
引用 8 楼 cfjtaishan 的回复:Quote: 引用 5 楼 qq_40432009 的回复:
Quote: 引用 3 楼 cfjtaishan 的回复:

fscanf(fp,"%c",pBuf);
//写文件
rewind(fp);
fwrite(pBuf, 1, length, fp);  
读一个字符到pBuf中，然后写length  * 1个字节到文件中？
这是做什么？
每次读一个字节，一共读它的长度个字节（长度*1)
但是你读也得用循环去读呢，循环length个字节，然后在写。
嗯，但是操作方面我还得看看别人写的，我主要是操作方面不清楚
那是你理解错了，fscanf并不会自动读取直至文件结束，它只根据你给出的format读取，或者遇到文件结束。
比如你给出"%c"它就只能读出一个字节，"%c%c"则是连续2个字节，"%c%d%c"就是一个字节然后一个整型数再一个字节，不多读。
在你这个例子中，更建议用fread，这么写：

fread(pBuf, length, 1, fp);
引用 12 楼 hzy_76 的回复:在你这个例子中，更建议用fread，这么写：

fread(pBuf, length, 1, fp);

但是fread之后就没办法对文件进行操作了，我要的是操作了之后再fwrite到fp中
你不是有rewind吗，一样会回到文件开头啊
提醒：1楼回复已经实现了“对文件的操作，也就是正文提取，去掉链接和标签，留下文本和标题，然后在放进txt中”功能。
引用 15 楼 zhao4zhong1 的回复:提醒：1楼回复已经实现了“对文件的操作，也就是正文提取，去掉链接和标签，留下文本和标题，然后在放进txt中”功能。
嗯。赵老师你好，我想问的是
1.那个重定向操作符是不是只能在cmd下运行的。我用VS的话按您给的代码我写了，它没反应在控制台上，是要添加到源代码吗，我又上网查那个VS用重定向的，我按上面的操作，在项目属性等操作，但是文本里面啥都没有
2.还有就是您给的代码，我感觉有点不能理解，底下的注释虽然很明白它的效果，但是。。应用起来的话步骤我还是不是很懂。
麻烦您了
WinExec("cmd /c cd /d 要处理文件in.html所在文件夹全路径比如D:\\mydir如果中间有空格还得用\"括住&test.exe <in.html >out.txt",SW_HIDE);
//处理结果在D:\\mydir\\out.txt文件中
引用 17 楼 zhao4zhong1 的回复:WinExec("cmd /c cd /d 要处理文件in.html所在文件夹全路径比如D:\\mydir如果中间有空格还得用\"括住&test.exe <in.html >out.txt",SW_HIDE);
//处理结果在D:\\mydir\\out.txt文件中
能举个例子吗，这样里面有中文和英文。。实在不好看懂，我上网找，但是好像不大一样
你小学语文体育老师教的？

比如待处理文件d:\mydir\in.html
WinExec("cmd /c cd /d d:\\mydir&test.exe <in.html >out.txt",SW_HIDE);

处理结果在d:\mydir\out.txt文件中

再比如待处理文件d:\my dir\in.html
WinExec("cmd /c cd /d \"d:\\my dir\"&test.exe <in.html >out.txt",SW_HIDE);

处理结果在d:\my dir\out.txt文件中
现在的码农竟然99%都不会在cmd窗口中输入cd命令设置当前目录为程序所在目录，输入程序名运行程序了！
引用 20 楼 zhao4zhong1 的回复:现在的码农竟然99%都不会在cmd窗口中输入cd命令设置当前目录为程序所在目录，输入程序名运行程序了！
=_=，才接触这个一个月，都拿来学C了。。。WinExec("cmd /c cd /d E:\\&test.exe <www >out.txt",SW_HIDE);麻烦帮忙看下，这个后面的SW_HIDE为什么现在未标识。。。
#include <windows.h>
引用 22 楼 zhao4zhong1 的回复:#include <windows.h>
'test.exe' 不是内部或外部命令，也不是可运行的程序
或批处理文件。
这个为什么会显示这个呀。是路径的问题吗，我的vs文件路径有中文。它显示好像不能用多字符。我改了文件名之后，我的VS打不开，找不到路径，手动也打不开那些项目
引用 20 楼 zhao4zhong1 的回复:现在的码农竟然99%都不会在cmd窗口中输入cd命令设置当前目录为程序所在目录，输入程序名运行程序了！

Windows惹的祸
将1楼的代码放到控制台项目中,设置项目使用多字节字符集,生成对应的test.exe
在你需要去掉in.html中html marker的程序中开头添加#include <windows.h>,用WinExec……语句去掉in.html中html marker
引用 25 楼 zhao4zhong1 的回复:将1楼的代码放到控制台项目中,设置项目使用多字节字符集,生成对应的test.exe
在你需要去掉in.html中html marker的程序中开头添加#include <windows.h>,用WinExec……语句去掉in.html中html marker

WinExec("cmd /c cd /d E:\\我的VS之路\\正文提取的test\\Debug\\&正文提取的test.exe <www.txt >out.txt",SW_HIDE);
这样子写了之后他会显示
另一个程序正在使用此文件，进程无法访问。

我停了其他程序，也重开电脑，但是都还是这个。。
WinExec("cmd /c cd /d \"E:\\我的VS之路\\正文提取的test\\Debug\"&\"正文提取的test.exe\" <www.txt >out.txt",SW_HIDE);
此内容可能已更新，有关最新信息，请参见 TechCenter 网站。Cmd启动命令解释程序 Cmd.exe 的新实例。如果在不含参数的情况下使用，cmd 将显示操作系统的版本和版权信息。

语法
cmd [{/c | /k}] [/s] [/q] [/d] [{/a | /u}] [/t:FG] [/e:{on | off}] [/f:{on | off}] [/v:{on | off}] [String]

参数
/c 
执行 String 指定的命令，然后停止。 
/k 
执行 String 指定的命令并继续。 
/s 
修改 /c 或 /k 后对 String 的处理。 
/q 
关闭回显。 
/d 
禁用“自动运行”命令执行。 
/a 
将内部命令输出按美国国家标准协会 (ANSI) 格式化为管道或文件。 
/u 
将内部命令输出作为 Unicode 格式化为管道或文件。 
/t:FG 
设置前景 F 色和背景 G 色。下表列出了可用作 F 和 G 值的有效的十六进制数字。 值 颜色 
0 黑色 
1 蓝色 
2 绿色 
3 浅绿色 
4 红色 
5 紫色 
6 黄色 
7 白色 
8 灰色 
9 淡蓝色 
A 淡绿色 
B 淡浅绿色 
C 淡红色 
D 淡紫色 
E 淡黄色 
F 亮白色 

/e:on 
启用命令扩展。 
/e:off 
禁用命令扩展。 
/f:on 
启用文件和目录名自动完成。 
/f:off 
禁用文件和目录名自动完成。 
/v:on 
启用延迟的环境变量扩展。 
/v:off 
禁用延迟的环境变量扩展。 
String 
指定要执行的命令。 
/? 
在命令提示符下显示帮助。 
注释
使用多个命令 
可以在 String 中使用由命令分隔符 && 分隔的多个命令，但这些命令必须用引号括起来（例如，"Command&&Command&&Command"）。

处理引号 
如果指定了 /c 或 /k，cmd 会处理 String 中的其余命令，并且只有在满足下述所有条件的情况下，才保留引号：

未使用 /s。 
准确使用了一对引号。 
在引号内未使用任何特殊字符（例如：&<>( ) @ ^ |）。 
在引号内使用了一个或多个空白字符。 
引号内的 String 为可执行文件的名称。 
如果上述条件不能满足，则处理 String 时将首先检查它的第一个字符以验证其是否为左引号。如果第一个字符是左引号，则它会与右引号分离开。跟在右引号之后的任何文本都会得到保留。

执行注册表子项 
如果在 String 中未指定 /d，则 Cmd.exe 会查找以下注册表子项：

HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\AutoRun\REG_SZ 

HKEY_CURRENT_USER\Software\Microsoft\Command Processor\AutoRun \REG_EXPAND_SZ

如果上述的一个注册表子项或两个都存在，则会在执行其他变量之前执行它们。

 警告

编辑注册表不当可能会严重损坏您的系统。在更改注册表之前，应备份计算机上任何有价值的数据。 
启用和禁用命令扩展 
在 Windows XP 中，命令扩展在默认情况下是启用的。对于特定进程，可使用 /e:off 禁用它们。通过设置下述 REG_DWORD 值，可以在计算机上或用户会话中启用或禁用所有 cmd 命令行选项的扩展名：

HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\EnableExtensions\REG_DWORD 

HKEY_CURRENT_USER\Software\Microsoft\Command Processor\EnableExtensions\REG_DWORD 

在注册表中使用 Regedit.exe 可以将 REG_DWORD 值设为 0×1（即启用）或 0×0（即禁用）。用户特定设置优先于计算机设置，并且命令行选项优先于注册表设置。

 警告

编辑注册表不当可能会严重损坏您的系统。在更改注册表之前，应备份计算机上任何有价值的数据。 
启用命令扩展后，会影响到下述命令： 

assoc 
call 
chdir (cd) 
color 
del (erase) 
endlocal 
for 
ftype 
goto 
if 
mkdir (md) 
popd 
prompt 
pushd 
set 
setlocal 
shift 
start（还包括将更改外部命令过程） 

有关这些命令的详细信息，请参阅“相关主题”。

启用延迟的环境变量扩展 
启用延迟的环境变量扩展，可以使用感叹号字符来替代运行时的环境变量值。

启用文件和目录名自动完成 
默认情况下，禁用文件和目录名自动完成。对于特定的 cmd 命令处理，可以通过 /f:{on|off来启用或禁用文件名自动完成。通过设置下述 REG_DWORD 值，可以在计算机上或用户登录会话中启用或禁用所有 cmd 命令处理的文件和目录名自动完成：

HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\CompletionChar\REG_DWORD 

HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\PathCompletionChar\REG_DWORD 

HKEY_CURRENT_USER\Software\Microsoft\Command Processor\CompletionChar\REG_DWORD 

HKEY_CURRENT_USER\Software\Microsoft\Command Processor\PathCompletionChar\REG_DWORD 

要设置 REG_DWORD 值，请运行 Regedit.exe 并使用特定功能的控制字符的十六进制值（例如，用 0×9 表示 Tab，用 0×08 表示 Backspace）。用户特定设置优先于计算机设置，并且命令行选项优先于注册表设置。

 警告

编辑注册表不当可能会严重损坏您的系统。在更改注册表之前，应备份计算机上任何有价值的数据。 
如果使用 /f:on 启用了文件和目录名自动完成，则对于目录名自动完成，可使用 Ctrl+D；而对于文件名自动完成，可使用 Ctrl+F。要禁用注册表中特定字符的自动完成，请使用空格值 [0×20]，因为空格不是有效的控制字符。

按 Ctrl+D 或 Ctrl+F 时，cmd 会处理文件和目录名的自动完成操作。这些组合键的作用是在 String 后附加通配符（如果还未使用），并创建匹配的路径列表，然后显示第一个匹配的路径。如果所有路径都不匹配，文件和目录名自动完成操作会发出警告声，并且不更改所显示的内容。要逐个查看匹配路径列表中的路径，请重复按 Ctrl+D 或 Ctrl+F。要向后查看该列表，请在按 Shift 的同时按 Ctrl+D 或 Ctrl+F。要放弃已保存的匹配路径列表并生成新列表，可以编辑 String，然后按 Ctrl+D 或 Ctrl+F。如果在 Ctrl+D 和 Ctrl+F 之间切换，将会放弃已保存的匹配路径列表并生成新列表。Ctrl+D 组合键与 Ctrl+F 组合键之间唯一的不同在于，Ctrl+D 仅匹配目录名，而 Ctrl+F 既匹配文件名，又匹配目录名。如果在任何内部目录命令（CD、MD 或 RD）中使用文件和目录名的自动完成，将仅使用目录的自动完成。

如果将匹配路径置于引号之中，则文件和目录名自动完成会正确地处理含有空格或特殊字符的文件名。

下述特殊字符需要有引号：& < > [ ] { } ^ = ; !' + , ` ~ [空白区域]

如果所提供的信息包含空格，请使用引号将内容引起来（例如，"Computer Name"）。

如果从 String 内处理文件和目录名自动完成操作，则将放弃 [Path] 在光标右侧的任何部分（即在 String 中处理自动完成操作的位置）。

格式化图例
格式 含义 
斜体 用户必须提供的信息 
粗体 用户必须准确键入的要显示的元素 
省略号 (...) 在命令行中可多次重复的参数 
中括号 ([]) 可选项 
大括号 ({})；选项用竖线 (|) 分隔。例如：{even|odd} 用户必须从选项集合中选择一个  
Courier 字体 代码或程序输出 
 
相关主题
引用 27 楼 zhao4zhong1 的回复:WinExec("cmd /c cd /d \"E:\\我的VS之路\\正文提取的test\\Debug\"&\"正文提取的test.exe\" <www.txt >out.txt",SW_HIDE);

还是一样。。一样是另外一个进程在使用，进程无访问。。
还是说，可以用C写个语句，来读取这个txt文件，然后加上底下的操作之后，再输入到另外一个txt文件里面？
在任务管理器中先结束进程“正文提取的test.exe”

这些都是常识啊！

程序员的常识之一：不要将程序源代码或项目或exe放在桌面这种复杂（多半带空格和汉字且在防火墙或杀毒软件严密控制的C盘上）的目录下。
你不会不懂
“正文提取的test.exe”对应我#1楼的test.cpp生成的exe
包含WinExec语句的.cpp文件生成的是另一个exe
吧。

我猜你是傻傻地把WinExec语句写到“正文提取的test.exe”对应的.cpp中了。
calltest.cpp:#include <windows.h>
int main() {
 WinExec("cmd /c cd /d \"E:\\我的VS之路\\正文提取的test\\Debug\"&\"正文提取的test.exe\" <www.txt >out.txt",SW_HIDE);
 return 0;
}
用这个代码生成比如“E:\我的VS之路\正文提取的test\Debug\calltest.exe"
然后你双击运行calltest.exe，作用是调用”“E:\我的VS之路\正文提取的test\正文提取的test.exe“并指定输入输出重定向文件。
引用 31 楼 zhao4zhong1 的回复:你不会不懂
“正文提取的test.exe”对应我#1楼的test.cpp生成的exe
包含WinExec语句的.cpp文件生成的是另一个exe
吧。

我猜你是傻傻地把WinExec语句写到“正文提取的test.exe”对应的.cpp中了。


呃。是有点绕哈。。。。我这个的确不是很清楚，这个是操作系统的吗，如果是的话。我还没学习。。。。。我就暂时学了C。现在在练C。
。。要不然我今晚再看看。但是不一定看的出来。
计算机组成原理→DOS命令→汇编语言→C语言（不包括C++）、代码书写规范→数据结构、编译原理、操作系统→计算机网络、数据库原理、正则表达式→其它语言（包括C++）、架构……
命令行解释器概述
命令行解释器是一个单独的软件程序，它可以在用户和操作系统之间提供直接的通讯。非图形命令行解释器用户界面提供运行基于字符的应用程序和实用程序的环境。通过使用类似于 MS-DOS 命令解释程序 Command.com 的单独字符，命令行解释器执行程序并在屏幕上显示其输出。Windows 服务器操作系统命令行解释器使用命令解释程序 Cmd.exe（该程序加载应用程序并指导应用程序之间的信息流动）将用户输入转换为操作系统可理解的形式。
可以使用命令行解释器创建和编辑可自动执行常规任务的批处理文件（也称作脚本）。例如，可以使用脚本自动管理用户帐户或夜间备份。还可以使用 Windows 脚本宿主 CScript 的命令行版本在命令行解释器中运行更高级的脚本。详细信息，请参阅运行 Windows 脚本宿主。通过使用批处理文件来执行操作，可比使用用户界面更有效率。批处理文件接受命令行上可用的所有命令。有关批处理文件和脚本的详细信息，请参阅使用批处理文件。
您可以自定义命令提示符窗口以易于查看并增强对程序运行方式的控制。有关自定义命令提示符窗口的详细信息，请参阅配置命令提示符。

使用命令语法
语法按命令及所带参数必须遵循的键入顺序出现。下面的 xcopy 命令示例显示了各种语法文本格式：

xcopy Source [Destination] [/w] [/p] [/c] [/v] [/q] [/f] [/l] [/g] [/d[:MM-DD-YYYY]] [/u] [/i] [/s [/e]] [/t] [/k] [/r] [/h] [{/a | /m}] [/n] [/o] [/x] [/exclude:File1[+[File2]][+[File3]] [{/y | /-y}] [/z]

下表说明如何解释不同的文本格式。

格式化图例
格式                                             含义
斜体                                             用户必须提供的信息
粗体                                             用户必须准确键入的要显示的元素
省略号(...)                                      在命令行中可多次重复的参数
中括号([])                                       可选项
大括号({})；选项用竖线(|)分隔。例如：{even|odd}  用户必须从选项集合中选择一个
Courier字体                                      代码或程序输出

使用多个命令和条件处理符号
使用条件处理符号可以在单个命令行或脚本中运行多个命令。通过条件处理符号运行多个命令时，条件处理符号右边的命令根据条件处理符号左边命令的执行结果来发挥作用。例如，只有在前一个命令失败的情况下才可能需要运行一个新命令。或者，只有在前一个命令成功时才可能需要运行一个新命令。
可以使用下表列出的特殊字符来传递多个命令。

字符       语法                            定义
& [...]    Command1 & Command2             用来分隔一个命令行中的多个命令。Cmd.exe 运行第一个命令，然后运行第二个命令。
&& [...]   Command1 && Command2            只有在符号 && 前面的命令成功时，才运行该符号后面的命令。Cmd.exe 运行第一个命令，然后只有在第一个命令运行成功时才运行第二个命令。
|| [...]   Command1 || Command2            只有在符号 || 前面的命令失败时，才运行符号 || 后面的命令。Cmd.exe 运行第一个命令，然后只有在第一个命令未能运行成功（接收到大于零的错误代码）时才运行第二个命令。
( ) [...]  (Command1 & Command2)           用来分组或嵌套多个命令。
;或者,     Command1 Parameter1;Parameter2  用来分隔命令参数。

注意
“与”符号 (&)、管道符号 (|) 以及括号 () 是特殊字符，将它们作为参数传递时，必须在其前面加上转义字符 (^) 或引号。
如果某个命令成功完成操作，该命令就返回零 (0) 退出代码或不返回任何退出代码。有关退出代码的详细信息，请参阅 Microsoft Windows 部署和资源工具包。

嵌套命令行解释器
通过在命令提示符下打开新的 Cmd.exe 实例，可以在 Cmd.exe 内嵌套命令行解释器。默认情况下，Cmd.exe 的每个实例继承其父 Cmd.exe 应用程序的环境。通过嵌套 Cmd.exe 的实例，可以更改局部环境，而不会影响 Cmd.exe 的父应用程序。这使您能够保留 Cmd.exe 的原始环境，并在终止嵌套的命令行解释器之后返回到原始环境。但是在嵌套的命令行解释器中所做的更改将不会被保存。
要嵌套命令行解释器，请在命令提示符下键入：

cmd

出现类似于下面内容的消息：

Microsoft (R) Windows Server 2003 Standard Edition (TM)
(C) 版权所有 1985-2002 Microsoft Corp.
要关闭嵌套的命令行解释器，请键入 exit。

使用 setlocal 和 endlocal 命令，可以在 Cmd.exe 的实例中（或在脚本中）进一步将更改局部化。Setlocal 创建局部作用范围，而 endlocal 终止局部作用范围。在 setlocal 和 endlocal 作用范围内所做的更改将会被放弃，从而保持原始环境不变。这两个命令的嵌套最高可达到 32 级。有关 setlocal 和 endlocal 命令的详细信息，请参阅 Setlocal 和 Endlocal。

将环境变量与 Cmd.exe 一起使用
Cmd.exe 命令行解释器环境由确定命令行解释器和操作系统行为的变量进行定义。可以使用两种类型的环境变量（系统和局部）来定义命令行解释器环境或整个操作系统环境的行为。系统环境变量定义全局操作系统环境的行为。局部环境变量定义 Cmd.exe 当前实例环境的行为。
系统环境变量预置于操作系统之中，并可用于所有 Windows 服务器操作系统进程。只有具有管理凭据的用户才可以更改系统变量。这些变量最常用于登录脚本。
局部环境变量只有在创建变量时针对的目标用户登录到计算机时才有效。HKEY_CURRENT_USER 配置单元中设置的局部变量只对当前用户有效，但它们可定义全局操作系统环境的行为。

下表按优先顺序的降序描述变量的各种类型：
1.内置系统变量
2.在 HKEY_LOCAL_MACHINE 配置单元中找到的系统变量
3.在 HKEY_CURRENT_USER 配置单元中找到的局部变量
4.在 Autoexec.bat 文件中设置的所有环境变量和路径
5.在登录脚本（如果有的话）中设置的所有环境变量
6.在脚本或批处理文件中交互使用的变量

在命令行解释器中，Cmd.exe 的每个实例都继承其父应用程序的环境。因此，可以在不影响父应用程序环境的情况下更改新的 Cmd.exe 环境中的变量。
下表列出 Windows server operating system 的系统和本地环境变量。

变量                     类型       描述
%ALLUSERSPROFILE%        本地       返回“所有用户”配置文件的位置。
%APPDATA%                本地       返回默认情况下应用程序存储数据的位置。
%CD%                     本地       返回当前目录字符串。
%CMDCMDLINE%             本地       返回用来启动当前的Cmd.exe的准确命令行。
%CMDEXTVERSION%          系统       返回当前的“命令处理程序扩展”的版本号。
%COMPUTERNAME%           系统       返回计算机的名称。
%COMSPEC%                系统       返回命令行解释器可执行程序的准确路径。
%DATE%                   系统       返回当前日期。使用与date/t命令相同的格式。由Cmd.exe生成。有关date命令的详细信息，请参阅Date。
%ERRORLEVEL%             系统       返回上一条命令的错误代码。通常用非零值表示错误。
%HOMEDRIVE%              系统       返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。
%HOMEPATH%               系统       返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。
%HOMESHARE%              系统       返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。
%LOGONSERVER%            本地       返回验证当前登录会话的域控制器的名称。
%NUMBER_OF_PROCESSORS%   系统       指定安装在计算机上的处理器的数目。
%OS%                     系统       返回操作系统名称。Windows2000显示其操作系统为Windows_NT。
%PATH%                   系统       指定可执行文件的搜索路径。
%PATHEXT%                系统       返回操作系统认为可执行的文件扩展名的列表。
%PROCESSOR_ARCHITECTURE% 系统       返回处理器的芯片体系结构。值：x86或IA64（基于Itanium）。
%PROCESSOR_IDENTFIER%    系统       返回处理器说明。
%PROCESSOR_LEVEL%        系统       返回计算机上安装的处理器的型号。
%PROCESSOR_REVISION%     系统       返回处理器的版本号。
%PROMPT%                 本地       返回当前解释程序的命令提示符设置。由Cmd.exe生成。
%RANDOM%                 系统       返回0到32767之间的任意十进制数字。由Cmd.exe生成。
%SYSTEMDRIVE%            系统       返回包含Windowsserveroperatingsystem根目录（即系统根目录）的驱动器。
%SYSTEMROOT%             系统       返回Windowsserveroperatingsystem根目录的位置。
%TEMP%和%TMP%            系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。
%TIME%                   系统       返回当前时间。使用与time/t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅Time。
%USERDOMAIN%             本地       返回包含用户帐户的域的名称。
%USERNAME%               本地       返回当前登录的用户的名称。
%USERPROFILE%            本地       返回当前用户的配置文件的位置。
%WINDIR%                 系统       返回操作系统目录的位置。

设置环境变量
使用 set 命令创建、更改、删除或显示环境变量。set 命令只更改当前解释器环境中的变量。

要查看变量，请在命令提示符下键入：

set VariableName

要添加变量，请在命令提示符下键入：

set variablename=Value

要删除变量，请在命令提示符下键入：

set VariableName=

可以将大多数字符用作变量值，其中包括空格。如果使用特殊字符 <、>、|、& 或 ^，则必须在它们前面加上转义字符 (^) 或引号。如果使用引号，则必须将引号作为值的组成部分，因为等号后面的任何内容都会被视为值。请考虑下列示例：

要创建变量值 new&name，请键入：
set varname=new^&name

要创建变量值 "new&name"，请键入：
set varname="new&name"

如果在命令提示符下键入 set varname=new&name，就会出现与下面内容类似的错误消息：
“'name' 不是内部或外部文件，也不是可运行的程序或批处理文件。”
变量名不区分大小写。但是，set 显示的变量与您键入的完全相同。可以在变量名中结合使用大写字母和小写字母，这样可以使代码更具有可读性（例如，UserName）。

注意

单个环境变量的最大大小为 8192 字节。
所有环境变量的大小总和（包括变量名和等号）最大为 65,536 KB。
替换环境变量值
要在命令行或脚本中启用变量值替换，请将变量名包括在百分号之中（即，%VariableName%）。使用百分号可以确保 Cmd.exe 引用变量值，而不是进行文字比较。为变量名定义变量值之后，请将变量名包括在百分号之中。Cmd.exe 搜索该变量名的所有实例，并用定义的变量值进行替换。例如，如果创建包含不同值（例如，用户名）的脚本，并且想要用这些值为每个用户定义 USERNAME 环境变量，可以使用包括在百分号之中的 USERNAME 来编写代码。运行此脚本时，Cmd.exe 将用变量值替换 %USERNAME%，这样就消除了为每个用户手动执行此任务的必要。变量替换是不可递归的。Cmd.exe 检查变量一次。有关变量替换的详细信息，请参阅 For 和 Call。
开始、运行、cmd、确定
在黑色的cmd窗口中输入命令：
cd /d "E:\我的VS之路\正文提取的test\Debug"
"正文提取的test.exe" <www.txt >out.txt

现在的码农竟然99%都不会在cmd窗口中输入cd命令设置当前目录为程序所在目录，输入程序名运行程序了！
引用 36 楼 zhao4zhong1 的回复:开始、运行、cmd、确定
在黑色的cmd窗口中输入命令：
cd /d "E:\我的VS之路\正文提取的test\Debug"
"正文提取的test.exe" <www.txt >out.txt

现在的码农竟然99%都不会在cmd窗口中输入cd命令设置当前目录为程序所在目录，输入程序名运行程序了！
呃。1.我现在分开了2个程序，一个是WinExec然后一个是1楼给的代码，都编译了，但是我运行WinExec的时候，黑框上就直接显示，请按任意键继续，然后我打开那个out.txt文件，都没有东西。
        2.还有就是我在cmd上面填写你给的那个，上面显示系统找不到指定文件。。。。。
        3.其实我只是想用一些代码来实现，最好只有关于C的，引用，操作，结束。。。涉及到别的话。可能就有点跟我的初衷有点相反了。
引用 36 楼 zhao4zhong1 的回复:开始、运行、cmd、确定
在黑色的cmd窗口中输入命令：
cd /d "E:\我的VS之路\正文提取的test\Debug"
"正文提取的test.exe" <www.txt >out.txt

现在的码农竟然99%都不会在cmd窗口中输入cd命令设置当前目录为程序所在目录，输入程序名运行程序了！
最好可以用到C语言文件的读取fopen之类的，然后操作，放入文件
本质上没区别，且c语言过滤文件用管道已经是业界通行做法。
引用 39 楼 zhao4zhong1 的回复:本质上没区别，且c语言过滤文件用管道已经是业界通行做法。
https://zhidao.baidu.com/question/1446284622845532140.html
那这里面取标签之间的原理是什么，为什么要设置那么多参数，有点理解不了。。不明白为什么要加上那些判断语句什么的。能帮忙指点一下吗。
代码功能归根结底不是别人帮自己看或讲解或注释出来的；而是被自己静下心来花足够长的时间和精力亲自动手单步或设断点或对执行到某步获得的中间结果显示或写到日志文件中一步一步分析出来的。
提醒：再牛×的老师也无法代替学生自己领悟和上厕所！
单步调试和设断点调试（VS IDE中编译连接通过以后，按F10或F11键单步执行，按Shift+F11退出当前函数；在某行按F9设断点后按F5执行停在该断点处。）是程序员必须掌握的技能之一。
理解和讨论之前请先学会如何观察！

计算机组成原理→DOS命令→汇编语言→C语言（不包括C++）、代码书写规范→数据结构、编译原理、操作系统→计算机网络、数据库原理、正则表达式→其它语言（包括C++）、架构……

对学习编程者的忠告：
多用小脑和手，少用大脑、眼睛和嘴，会更快地学会编程！
眼过千遍不如手过一遍！
书看千行不如手敲一行！
手敲千行不如单步一行！
单步源代码千行不如单步Debug版对应汇编一行！
单步Debug版对应汇编千行不如单步Release版对应汇编一行！
不会单步Release版对应汇编？在你想单步Release版C/C++代码片断的前面临时加一句DebugBreak();重建所有，然后在IDE中运行。（一般人我不告诉他！）

VC调试时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
对VC来说，所谓‘调试时’就是编译连接通过以后，按F10或F11键单步执行一步以后的时候，或者在某行按F9设了断点后按F5执行停在该断点处的时候。
（Turbo C或Borland C用Turbo Debugger调试,Linux或Unix下用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）

想要从本质上理解C指针，必须学习汇编以及C和汇编的对应关系。
从汇编的角度理解和学习C语言的指针，原本看似复杂的东西就会变得非常简单！
指针即地址。“地址又是啥？”“只能从汇编语言和计算机组成原理的角度去解释了。”
但我又不得不承认：
 有那么些人喜欢或者适合用“先具体再抽象”的方法学习和理解复杂事物；
 而另一些人喜欢或者适合用“先抽象再具体”的方法学习和理解复杂事物。
而我本人属前者。

不要企图依赖输出指针相关表达式...的值【比如printf("%p\n",...);或者cout<<...】来理解指针的本质，
而要依赖调试时的反汇编窗口中的C/C++代码【比如void *p=(void *)(...);】及其对应汇编指令以及内存窗口中的内存地址和内存值来理解指针的本质。

这辈子不看内存地址和内存值；只画链表、指针示意图，画堆栈示意图，画各种示意图，甚至自己没画过而只看过书上的图……能从本质上理解指针、理解函数参数传递吗？本人深表怀疑！
这辈子不种麦不收麦不将麦粒拿去磨面；只吃馒头、吃面条、吃面包、……甚至从没看过别人怎么蒸馒头，压面条，烤面包，……能从本质上理解面粉、理解面食吗？本人深表怀疑！！

提醒：
“学习用汇编语言写程序”
和
“VC调试(TC或BC用TD调试)时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
（Linux或Unix下可以在用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）
想要从本质上理解C指针，必须学习C和汇编的对应关系。”
不是一回事！

不要迷信书、考题、老师、回帖；
要迷信CPU、编译器、调试器、运行结果。
并请结合“盲人摸太阳”和“驾船出海时一定只带一个指南针。”加以理解。
任何理论、权威、传说、真理、标准、解释、想象、知识……都比不上摆在眼前的事实！

有人说一套做一套，你相信他说的还是相信他做的？
其实严格来说这个世界上古往今来所有人都是说一套做一套，不是吗？

不要写连自己也预测不了结果的代码！

电脑内存或文件内容或传输内容只是一个一维二进制字节数组及其对应的二进制地址；
人脑才将电脑内存或文件内容或传输内容中的这个一维二进制字节数组及其对应的二进制地址的某些部分看成是整数、有符号数/无符号数、浮点数、复数、英文字母、阿拉伯数字、中文/韩文/法文……字符/字符串、汇编指令、函数、函数参数、堆、栈、数组、指针、数组指针、指针数组、数组的数组、指针的指针、二维数组、字符点阵、字符笔画的坐标、黑白二值图片、灰度图片、彩色图片、录音、视频、指纹信息、身份证信息……
引用 42 楼 zhao4zhong1 的回复:理解和讨论之前请先学会如何观察！

计算机组成原理→DOS命令→汇编语言→C语言（不包括C++）、代码书写规范→数据结构、编译原理、操作系统→计算机网络、数据库原理、正则表达式→其它语言（包括C++）、架构……

对学习编程者的忠告：
多用小脑和手，少用大脑、眼睛和嘴，会更快地学会编程！
眼过千遍不如手过一遍！
书看千行不如手敲一行！
手敲千行不如单步一行！
单步源代码千行不如单步Debug版对应汇编一行！
单步Debug版对应汇编千行不如单步Release版对应汇编一行！
不会单步Release版对应汇编？在你想单步Release版C/C++代码片断的前面临时加一句DebugBreak();重建所有，然后在IDE中运行。（一般人我不告诉他！）

VC调试时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
对VC来说，所谓‘调试时’就是编译连接通过以后，按F10或F11键单步执行一步以后的时候，或者在某行按F9设了断点后按F5执行停在该断点处的时候。
（Turbo C或Borland C用Turbo Debugger调试,Linux或Unix下用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）

想要从本质上理解C指针，必须学习汇编以及C和汇编的对应关系。
从汇编的角度理解和学习C语言的指针，原本看似复杂的东西就会变得非常简单！
指针即地址。“地址又是啥？”“只能从汇编语言和计算机组成原理的角度去解释了。”
但我又不得不承认：
 有那么些人喜欢或者适合用“先具体再抽象”的方法学习和理解复杂事物；
 而另一些人喜欢或者适合用“先抽象再具体”的方法学习和理解复杂事物。
而我本人属前者。

不要企图依赖输出指针相关表达式...的值【比如printf("%p\n",...);或者cout<<...】来理解指针的本质，
而要依赖调试时的反汇编窗口中的C/C++代码【比如void *p=(void *)(...);】及其对应汇编指令以及内存窗口中的内存地址和内存值来理解指针的本质。

这辈子不看内存地址和内存值；只画链表、指针示意图，画堆栈示意图，画各种示意图，甚至自己没画过而只看过书上的图……能从本质上理解指针、理解函数参数传递吗？本人深表怀疑！
这辈子不种麦不收麦不将麦粒拿去磨面；只吃馒头、吃面条、吃面包、……甚至从没看过别人怎么蒸馒头，压面条，烤面包，……能从本质上理解面粉、理解面食吗？本人深表怀疑！！

提醒：
“学习用汇编语言写程序”
和
“VC调试(TC或BC用TD调试)时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
（Linux或Unix下可以在用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）
想要从本质上理解C指针，必须学习C和汇编的对应关系。”
不是一回事！

不要迷信书、考题、老师、回帖；
要迷信CPU、编译器、调试器、运行结果。
并请结合“盲人摸太阳”和“驾船出海时一定只带一个指南针。”加以理解。
任何理论、权威、传说、真理、标准、解释、想象、知识……都比不上摆在眼前的事实！

有人说一套做一套，你相信他说的还是相信他做的？
其实严格来说这个世界上古往今来所有人都是说一套做一套，不是吗？

不要写连自己也预测不了结果的代码！

电脑内存或文件内容或传输内容只是一个一维二进制字节数组及其对应的二进制地址；
人脑才将电脑内存或文件内容或传输内容中的这个一维二进制字节数组及其对应的二进制地址的某些部分看成是整数、有符号数/无符号数、浮点数、复数、英文字母、阿拉伯数字、中文/韩文/法文……字符/字符串、汇编指令、函数、函数参数、堆、栈、数组、指针、数组指针、指针数组、数组的数组、指针的指针、二维数组、字符点阵、字符笔画的坐标、黑白二值图片、灰度图片、彩色图片、录音、视频、指纹信息、身份证信息……
谢谢赵四老师，我会记住的


程序执行不出来，求大佬看下哪里错了？将一个环形队列（容量为n，元素小标为0~n-1）的元素倒置#include <stdio.h>
#include <malloc.h>
#define MaxSize 10
typedef int ElemType; 

typedef struct
{
	ElemType data[MaxSize];
	int top;
}SqStack;

typedef struct
{
	ElemType data[MaxSize];
	int front,rear;
}SqQueue;



void InitQueue(SqQueue *&q)
{
	q=(SqQueue *)malloc(sizeof(SqQueue));
	q->front=q->rear=0;
}

bool QueueEmpty(SqQueue *q)
{
	return(q->front==q->rear);
} 

bool enQueue(SqQueue *&q,ElemType e)
{
	if((q->rear+1)%MaxSize==q->front)
	return false;
	q->rear=(q->rear+1)%MaxSize;
	q->data[q->rear]=e;
	return true;
}

bool deQueue(SqQueue *&q,ElemType &e)
{
	if(q->front==q->rear)
	return false;
	q->front-(q->front+1)%MaxSize;
	e=q->data[q->front];
	return true; 
}

void InitStack(SqStack *&s)
{
	s=(SqStack *)malloc(sizeof(SqStack));
	s->top=-1;
}

bool StackEmpty(SqStack *&s)
{
	return(s->top==-1);
}

bool Push(SqStack *&s,ElemType e)
{
	if(s->top==MaxSize-1)
	return false;
	s->top++;
	s->data[s->top]=e;
	return true;
}

bool Pop(SqStack *&s,ElemType e)
{
	if(s->top==-1)
	return false;
	e=s->data[s->top];
	s->top--;
	return true;
}

void DestroyStack(SqStack *&s)
{
	free(s);
}

void Reverse(SqQueue *&qu)
{
ElemType e;
SqStack *st;
InitStack(st);
while(!QueueEmpty(qu))
{
	deQueue(qu,e);
	Push(st,e);
}
InitQueue(qu);
while(!StackEmpty(st))
{
	Pop(st,e);
	enQueue(qu,e);
}
DestroyStack(st);
}

main()
{
	ElemType e;
	SqQueue *q;
	InitQueue(q);
	
	enQueue(q,1);
	enQueue(q,2);
	enQueue(q,3);
	enQueue(q,4);
	enQueue(q,5);
	
	printf("环形队列倒置前元素顺序：\n");
	while (!QueueEmpty(q))
	{	deQueue(q,e);
		printf("%d ",e);
	}
	printf("\n");
	
	Reverse(q);
	printf("环形队列倒置后元素顺序：\n"); 
	while (!QueueEmpty(q))
	{	deQueue(q,e);
		printf("%d ",e);
	}
	printf("\n");
}
#include <stdio.h>
#include <stdlib.h>
//#include <malloc.h>

#define MaxSize 10

typedef int ElemType;

typedef struct
{
    ElemType data[MaxSize];
    int top;
}SqStack;

typedef struct
{
    ElemType data[MaxSize];
    int front,rear;
}SqQueue;



void InitQueue(SqQueue *&q)
{
    q = (SqQueue *)malloc(sizeof(SqQueue));
    if (!q)
        exit(0);
    q->front = q->rear = 0;
}

bool QueueEmpty(SqQueue *q)
{
    return(q->front == q->rear);
}

bool enQueue(SqQueue *&q,ElemType e)
{
    if((q->rear+1)%MaxSize == q->front)
        return false;
    q->rear=(q->rear+1)%MaxSize;
    q->data[q->rear]=e;
    return true;
}

bool deQueue(SqQueue *&q,ElemType &e)
{
    if(q->front==q->rear)
        return false;
    q->front = (q->front+1)%MaxSize;
    e = q->data[q->front];
    return true;
}

void InitStack(SqStack *&s)
{
    s=(SqStack *)malloc(sizeof(SqStack));
    if (!s)
        exit(0);
    s->top=-1;
}

bool StackEmpty(SqStack *&s)
{
    return(s->top==-1);
}

bool Push(SqStack *&s,ElemType e)
{
    if(s->top == MaxSize-1)
        return false;
    s->top++;
    s->data[s->top] = e;
    return true;
}

bool Pop(SqStack *&s,ElemType &e)
{
    if(s->top==-1)
        return false;
    e = s->data[s->top];
    s->top--;
    return true;
}

void DestroyStack(SqStack *&s)
{
    free(s);
}

void Reverse(SqQueue *&qu)
{
    ElemType e;
    SqStack *st;
    InitStack(st);
    while(!QueueEmpty(qu))
    {
        deQueue(qu,e);
        printf("e = %d\n", e);
        Push(st,e);
    }
    free(qu);
    InitQueue(qu);
    while(!StackEmpty(st))
    {
        Pop(st,e);
        enQueue(qu,e);
    }
    DestroyStack(st);
}

int main()
{
    ElemType e;
    SqQueue *q;
    InitQueue(q);

    enQueue(q,1);
    enQueue(q,2);
    enQueue(q,3);
    enQueue(q,4);
    enQueue(q,5);

#if 0
    printf("环形队列倒置前元素顺序：\n");
    while (!QueueEmpty(q))
    {    deQueue(q,e);
        printf("%d ",e);
    }
    printf("\n");
#endif
    Reverse(q);
    printf("环形队列倒置后元素顺序：\n");
    while (!QueueEmpty(q))
    {    deQueue(q,e);
        printf("%d ",e);
    }
    printf("\n");
}

参考一下吧；
问题主要是：
1. 没有意义的表达式
q->front-(q->front+1)%MaxSize;
应该为：
q->front = (q->front+1)%MaxSize;
2. pop第二个参数应该加引用：
bool Pop(SqStack *&s,ElemType &e)
因为你要pop后用到出栈的数据；
3. 重新初始化队列时，要先把上一个队列释放掉，不然会导致内存泄漏；
void Reverse(SqQueue *&qu)
{
    ElemType e;
    SqStack *st;
    InitStack(st);
    while(!QueueEmpty(qu))
    {
        deQueue(qu,e);
        printf("e = %d\n", e);
        Push(st,e);
    }
    free(qu);    /*释放旧的的队列*/
    InitQueue(qu);
    while(!StackEmpty(st))
    {
        Pop(st,e);
        enQueue(qu,e);
    }
    DestroyStack(st);
}
4.main函数中的出队列操作，即在倒置之前，还没倒置就将队列数据完全出队列了，那么倒置再出队列数据从哪来？
因此倒置前，把出队列操作注释掉；
其他问题，建议对比代码看一下；
引用 1 楼 cfjtaishan 的回复:#include <stdio.h>
#include <stdlib.h>
//#include <malloc.h>

#define MaxSize 10

typedef int ElemType;

typedef struct
{
    ElemType data[MaxSize];
    int top;
}SqStack;

typedef struct
{
    ElemType data[MaxSize];
    int front,rear;
}SqQueue;



void InitQueue(SqQueue *&q)
{
    q = (SqQueue *)malloc(sizeof(SqQueue));
    if (!q)
        exit(0);
    q->front = q->rear = 0;
}

bool QueueEmpty(SqQueue *q)
{
    return(q->front == q->rear);
}

bool enQueue(SqQueue *&q,ElemType e)
{
    if((q->rear+1)%MaxSize == q->front)
        return false;
    q->rear=(q->rear+1)%MaxSize;
    q->data[q->rear]=e;
    return true;
}

bool deQueue(SqQueue *&q,ElemType &e)
{
    if(q->front==q->rear)
        return false;
    q->front = (q->front+1)%MaxSize;
    e = q->data[q->front];
    return true;
}

void InitStack(SqStack *&s)
{
    s=(SqStack *)malloc(sizeof(SqStack));
    if (!s)
        exit(0);
    s->top=-1;
}

bool StackEmpty(SqStack *&s)
{
    return(s->top==-1);
}

bool Push(SqStack *&s,ElemType e)
{
    if(s->top == MaxSize-1)
        return false;
    s->top++;
    s->data[s->top] = e;
    return true;
}

bool Pop(SqStack *&s,ElemType &e)
{
    if(s->top==-1)
        return false;
    e = s->data[s->top];
    s->top--;
    return true;
}

void DestroyStack(SqStack *&s)
{
    free(s);
}

void Reverse(SqQueue *&qu)
{
    ElemType e;
    SqStack *st;
    InitStack(st);
    while(!QueueEmpty(qu))
    {
        deQueue(qu,e);
        printf("e = %d\n", e);
        Push(st,e);
    }
    free(qu);
    InitQueue(qu);
    while(!StackEmpty(st))
    {
        Pop(st,e);
        enQueue(qu,e);
    }
    DestroyStack(st);
}

int main()
{
    ElemType e;
    SqQueue *q;
    InitQueue(q);

    enQueue(q,1);
    enQueue(q,2);
    enQueue(q,3);
    enQueue(q,4);
    enQueue(q,5);

#if 0
    printf("环形队列倒置前元素顺序：\n");
    while (!QueueEmpty(q))
    {    deQueue(q,e);
        printf("%d ",e);
    }
    printf("\n");
#endif
    Reverse(q);
    printf("环形队列倒置后元素顺序：\n");
    while (!QueueEmpty(q))
    {    deQueue(q,e);
        printf("%d ",e);
    }
    printf("\n");
}

参考一下吧；
问题主要是：
1. 没有意义的表达式
q->front-(q->front+1)%MaxSize;
应该为：
q->front = (q->front+1)%MaxSize;
2. pop第二个参数应该加引用：
bool Pop(SqStack *&s,ElemType &e)
因为你要pop后用到出栈的数据；
3. 重新初始化队列时，要先把上一个队列释放掉，不然会导致内存泄漏；
void Reverse(SqQueue *&qu)
{
    ElemType e;
    SqStack *st;
    InitStack(st);
    while(!QueueEmpty(qu))
    {
        deQueue(qu,e);
        printf("e = %d\n", e);
        Push(st,e);
    }
    free(qu);    /*释放旧的的队列*/
    InitQueue(qu);
    while(!StackEmpty(st))
    {
        Pop(st,e);
        enQueue(qu,e);
    }
    DestroyStack(st);
}
4.main函数中的出队列操作，即在倒置之前，还没倒置就将队列数据完全出队列了，那么倒置再出队列数据从哪来？
因此倒置前，把出队列操作注释掉；
其他问题，建议对比代码看一下；非常非常非常感谢！！！实在是解释得非常清楚了！！新手小白的问题很白痴，感谢不吝赐教


这个正则表达式怎么写vim 正则表达式
linux

                  匹配：每行的开头到第一次出现http或rtmp之前的内容。

#NAME Stream USA
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//state.ak.tvwmedia.net/ktoo-live playpath=360north swfUrl=http%3a//www.360north.org/jwplayer5.9/player.swf pageUrl=http%3a//www.360north.org/watch-360-north-live/:360 North
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//bcoveliveios-i.akamaihd.net/hls/live/246496/4744899807001/livestream/master.m3u8:7 News Boston, MA
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//live.field59.com/kyur/ngrp%3akyur2_all/playlist.m3u8 :ABC 13 Anchorage, AK
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net/hls/live/224711/WFTV/master.m3u8?anv_user=1fead8f7153a78f2017343f07d4d6a6817657&fw_ltlg=&fw_sdk_flag=%252Bslcb%252Bvicb&fw_metr=7&_dev=web&fw_did=1fead8f7153a78f2017343f07d4d6a6817657&fw_sdk_flag_safe=%25252Bslcb%25252Bvicb&_tkx_anvack=anvato_cox_app_web_prod_ce45cda237969f93e7130f50ee8bb6280c1484ab&_tkx_callsign=wftv&anvauth=tb=0~te=1490563719~sgn=c6a0654d2939be829da358b8d5029d60daad3d88f8ff3c3871975fd1382db576&t=1490563629:ABC 9 Orlando, FL 
#SERVICE 4097:0:1:86:0:0:0:0:0:0:http%3a//abclive.abcnews.com/i/abc_live4@136330/master.m3u8:ABC News (USA)
#SERVICE 4097:0:1:108:0:0:0:0:0:0:http%3a//iphone-streaming.ustream.tv/uhls/17448463/streams/live/iphone/playlist.m3u8:Animal Planet (USA)
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//iphone-streaming.ustream.tv/uhls/12762028/streams/live/iphone/playlist.m3u8:Animal PLanet Live (USA)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//64.22.99.223%3a1935/AtlantaGALIVE playpath=AtlantaGALIVE.stream swfUrl=http%3a//view.earthchannel.com/misc/player.swf pageUrl=http%3a//view.earthchannel.com/PlayerLive.aspx:ATL 26
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//stream.iphonewebtown.com/bibleexplorations/ playpath=bexplorations.stream swfUrl=http%3a//www.flashwebtown.com/mediaplayer/player.swf pageUrl=http%3a//www.bibleexplorations.com/:Bible Explorations TV
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//cdn3.videos.bloomberg.com/btv/us/master.m3u8?b?b*t$:Bloomberg
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//reflect-ch68-bronxnet-tv.cablecast.tv/live/WIFI-1896k-720p/WIFI-1896k-720p.m3u8:Bronxnet Channel 68
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//reflect-ch69-bronxnet-tv.cablecast.tv/live/WIFI-1896k-720p/WIFI-1896k-720p.m3u8:Bronxnet Channel 69
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//reflect-ch70-bronxnet-tv.cablecast.tv/live/WIFI-1896k-720p/WIFI-1896k-720p.m3u8:Bronxnet Channel 70
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//cspan1-lh.akamaihd.net/i/cspan1_1@304727/index_1000_av-p.m3u8?sd=10&rebase=on:C-SPAN 1 news US
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//cspan2-lh.akamaihd.net/i/cspan2_1@304728/index_1000_av-p.m3u8?sd=10&rebase=on:C-SPAN 2 news US
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//cspan3-lh.akamaihd.net/i/cspan3_1@304729/index_1000_av-p.m3u8?sd=10&rebase=on:C-SPAN 3 news US
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net%3a80/hls/live/224714/WJAX/904k/prog.m3u8:CBS 47 Jacksonville, FL
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net/hls/live/224708/KIRO/564k/prog.m3u8:CBS 7 Seattle, WA
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//cbsnewshd-lh.akamaihd.net/i/CBSNHD_7@199302/index_2200_av-p.m3u8:CBS News
#SERVICE 4097:0:1:90:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net/hls/live/224708/KIRO/564k/prog.m3u8:CBS7 Seattle (USA)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//streaming.cityofboston.gov/live/cable:City of Boston TV
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//wgntribune-lh.akamaihd.net/i/WGNPrimary_1@304622/master.m3u8:CW 9 Chicago, IL
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net/hls/live/224672/WHBQ/564k/prog.m3u8:Fox 13 Memphis, TN
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net%3a80/hls/live/224709/KOKI/904k/prog.m3u8:Fox 23 news Tulsa, OH
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net%3a80/hls/live/224671/WFXT/904k/prog.m3u8:Fox 25 News Boston, MA
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net%3a80/hls/live/224710/WFOX/904k/prog.m3u8:Fox 30 News Jacksonville, FL
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//tribwdaf-lh.akamaihd.net/i/WDAFBreaking_1@394769/index_1900_av-b.m3u8?sd=10&rebase=on:Fox 4 News Kansas City, MI
#SERVICE 4097:0:1:92:0:0:0:0:0:0:http%3a//play-prod1.live.anvato.net/server/play/ktvutestctg/master.m3u8:Fox2 KTVU News (USA)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//hctv.streamguys.org%3a80/live playpath=streamName swfUrl=http%3a//helenacivictv.org/player/flowplayer-3.2.11.swf pageUrl=http%3a//helenacivictv.org/whats-on-channel-11/live-stream/:Helena Civic TV
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//bcliveuniv-lh.akamaihd.net/i/HopeChannel_1@182961/index_3192_av-p.m3u8?sd=10&rebase=on:Hope Channel
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//52.40.109.131%3a1935/rtplive/smil%3ajltv.smil/playlist.m3u8:Jewish Life TV
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//156.obj.netromedia.net/KAZQH264 playpath=KAZQH264 swfUrl=http%3a//player.netromedia.com/flowplayer.commercial-3.2.7.swf pageUrl=http%3a//kazq32.org/watch-online/:KAZQ-TV
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//mexicoserver.miamitvchannel.com/miamitv/smil%3amiamitvmexico/playlist.m3u8:Miami TV Colombia (Colombia)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//usaserver.miamitvchannel.com/miamitv/smil%3amiamitv/playlist.m3u8:MiamiTV Mexico
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//tvemsnbc-lh.akamaihd.net/i/nbcmsnbc_1@122532/index_2596_av-p.m3u8?sd=10&rebase=on:MSNBC (USA)
#SERVICE 4097:0:0:0:0:0:0:0:0:0:https%3a//nasa-i.akamaihd.net/hls/live/253566/NTV-Media/master_2000.m3u8:NASA TV Media
#SERVICE 4097:0:0:0:0:0:0:0:0:0:https%3a//nasa-i.akamaihd.net/hls/live/253565/NTV-Public1/master.m3u8:NASA TV Public
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//cmghlslive-i.akamaihd.net/hls/live/224715/WPXI/564k/prog.m3u8:NBC 11 Pittsburg, PA
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//fs-b4e3010000000000.id.cdn.cv.net/vxedge/fs-ace3010000000000 playpath=fs-ace3010000000000 swfUrl=http%3a//www.news12.com/player/flowplayer.commercial-3.2.7.swf app=vxedge/fs-ace3010000000000 pageUrl=http%3a//www.news12.com/player/flowplayer/.live_player.html?region=BK live=true swfVfy=true timeout=10:News12 Brooklyn
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//rtmp.one.by%3a1300:One 1
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12netw-2328.m3u8:PAC National 1280*720
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12netw-1164.m3u8:PAC National 640*360
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12baya-2328.m3u8:PAC-12 Net. (Bay Area) 1280*720
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12losa-4728.m3u8?:PAC-12 Net. (Los Angeles)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12oreg-2328.m3u8:PAC-12 Net. (Oregon) 1280*720
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12oreg-1164.m3u8:PAC-12 Net. (Oregon) 640*360
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12oreg-4728.m3u8?:PAC-12 Net. (Oregon)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//158.69.124.9%3a1935/primeasia/primeasia app=primeasia/ pageUrl=http%3a//www.primeasiatv.com/ swfUrl=http%3a//www.primeasiatv.com/jwplayer/jwplayer.flash.swf tcUrl=rtmp%3a//158.69.124.9%3a1935/primeasia/ playPath=primeasia live=1:Prime Asia
#SERVICE 4097:0:1:250:0:0:0:0:0:0:rtmp%3a//server5.stweb.tv/radioone/live:Radio ONE TV (USA)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//rt-eng-live.hls.adaptive.level3.net/rt/eng/index1600.m3u8:RT America
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//207.7.154.94/raleigh playpath=G0224_002 swfUrl=http%3a//raleigh.granicus.com/core/Players/Flash/ModernFlashPlayer.swf pageUrl=http%3a//raleigh.granicus.com/MediaPlayer.php:RTN Channel 11
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//streaming.temple.edu/tutvlive playpath=play swfUrl=https%3a//ensemble.temple.edu/ensemble/app/plugin/flashPlayer/flowplayer.commercial.swf?0.3377222182516503 pageUrl=https%3a//ensemble.temple.edu/ensemble/app/plugin/embed.aspx?ID=aTxloJelokKHV2qs:Temple University TV Philadelphia
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//webcasting.thefloridachannel.org/live/tvweb1:The Florida Channel
#SERVICE 4097:0:0:0:0:0:0:0:0:0:http%3a//mirlees.railcam.co.uk%3a8080/push/Lawrence/index.m3u8:UK rail - Lawrence, Kansas, USA 
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//ucsdtv-wowza.ucsd.edu%3a1935/live/live_800:University of California TV
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12ariz-1164.m3u8:USA-BASKET UNI.(Arizona)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12losa-1164.m3u8:USA-BASKET UNI.(Los Angeles)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//xrxs.net/video/live-p12moun-1164.m3u8:USA-BASKET UNI.(Moutain)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//aljazeeraflashlivefs.fplive.net%3a443/aljazeeraflashlive-live?videoId=883816736001&lineUpId=&pubId=665003303001&playerId=751182905001&affiliateId= playpath=aljazeera_eng_med?videoId=883816736001&lineUpId=&pubId=665003303001&playerId=751182905001&affiliateId= swfUrl=http%3a//admin.brightcove.com/viewer/us20130328.1037/federatedVideoUI/BrightcovePlayer.swf?uid=1365259821715 live=1 pageUrl=http%3a//tklist.net/tklist/aljazeera2.php:USA_AlJAZEERA
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//weather-lh.akamaihd.net/i/twc_1@92006/index_2400_av-p.m3u8:Weather Channel HD (USA)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:http%3a//cdnapi.kaltura.com/p/931702/sp/93170200/playManifest/entryId/1_oorxcge2/format/applehttp/protocol/http/uiConfId/28428751/a.m3u8:Weather Nation
#SERVICE 4097:0:1:84:0:0:0:0:0:0:http%3a//wgntribune-lh.akamaihd.net/i/WGNPrimary_1@304622/master.m3u8:WGN News Chicago (USA)
#SERVICE 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//fss29.streamhoster.com/lv_goodlife45f1 playpath=broadcast1 swfUrl=http%3a//public.streamhoster.com/Resources/Flash/JWFLVMediaPlayer/mediaplayer.swf pageUrl=http%3a//www.tv45.org/watch-now/:WTGL-TV Good Life 45
vim里想选定一些内容删除，半天搞不出来啊
并不需要正则
分别查找http和rtmp，然后比较以下出现的位置就可以了
引用 2 楼 jiht594 的回复:并不需要正则
分别查找http和rtmp，然后比较以下出现的位置就可以了

问题再简化一下： 下面这一行， 如何匹配住从SSS到第一个EEE之前的内容，
SSSaaaaaaaaaaEEEaaaaaaaaaaaaEEEaaaaaaaaaaa
我用/SSS.*EEE 总是匹配住了开头到第二个EEE的内容。
/SSS.*?EEE 
正则学过，但是没啥机会用。
默认是“贪婪模式”，你可以搜以下，感觉是这个问题。加？试试。
引用 4 楼 jiht594 的回复:/SSS.*?EEE 
正则学过，但是没啥机会用。
默认是“贪婪模式”，你可以搜以下，感觉是这个问题。加？试试。

没匹配上任何东西啊。
我在网站上试的，http://tool.oschina.net/regex/
串：SSSaaaaaaaaaaEEEaaaaaaaaaaaaEEEaaaaaaaaaaa
表达式：SSS.*?EEE
结果：SSSaaaaaaaaaaEEE

表达式：SSS.*EEE
结果：SSSaaaaaaaaaaEEEaaaaaaaaaaaaEEE
/////////////////////////////////////////////////////
PS：你可以搜以下贪婪模式、我写的不一定对、网站的结果也不一定。
正则表达式速查 正则表达式举例 正则表达式学习 (4页A4纸)http://download.csdn.net/detail/zhao4zhong1/1808549
引用 7 楼 zhao4zhong1 的回复:正则表达式速查 正则表达式举例 正则表达式学习 (4页A4纸)http://download.csdn.net/detail/zhao4zhong1/1808549

VIM的一些正则表达式功能没有出现在这个文档里，对JavaScript还是不错的。
引用 6 楼 jiht594 的回复:我在网站上试的，http://tool.oschina.net/regex/
串：SSSaaaaaaaaaaEEEaaaaaaaaaaaaEEEaaaaaaaaaaa
表达式：SSS.*?EEE
结果：SSSaaaaaaaaaaEEE

表达式：SSS.*EEE
结果：SSSaaaaaaaaaaEEEaaaaaaaaaaaaEEE
/////////////////////////////////////////////////////
PS：你可以搜以下贪婪模式、我写的不一定对、网站的结果也不一定。
我弄出来了，
/SSS.\{-}\zeEEE
\{-}  -- 去掉贪婪模式
\ze	Matches at any position, and sets the end of the match there: The
	previous char is the last char of the whole match. |/zero-width|
	Can be used multiple times, the last one encountered in a matching
	branch is used.
	Example: "end\ze\(if\|for\)" matches the "end" in "endif" and
	"endfor"


nullptr的原理是啥，应该怎么改链式队列
c语言
基础


#include<stdio.h>  
#include<string.h>  
#include<stdlib.h>  
#include<malloc.h>  
#define  TRUE  1  
#define  FALSE 0  
#define  OK    1  
#define  ERROR 0  
typedef  int  QElemType;
typedef  int    Status;
typedef struct QNode {
	QElemType Qdata;
	struct QNode *next;
}QNode, *Queueptr;
typedef struct {
	Queueptr  front;
	Queueptr  rear;
}LinkQueue;

//建立空队列Q
Status InitQueue(LinkQueue *Q)
{

	Q->front = Q->rear = (Queueptr)malloc(sizeof(QNode));
	if (!Q->front)exit(ERROR);
	Q->front->next = NULL;
	return OK;
}
//销毁队列Q
Status DestroyQueue(LinkQueue *Q)
{
	while (Q->front) {
		Q->front = Q->front->next;
		free(Q->front);
		Q->front = Q->rear;
	}
	return OK;
}
//插入元素e为Q的新的队尾元素
Status EnQueue(LinkQueue *Q, QElemType &e)
{

	Queueptr p = (Queueptr)malloc(sizeof(QNode));
	if (!p)exit(ERROR);
	p->Qdata = e;
	p->next = NULL;
	Q->rear->next = p;
	Q->front = p;
	return OK;
}//若队列不空，则删除Q的队头元素，用e返回其值，return OK
Status DeQueue(LinkQueue *Q, QElemType &e)
{
	
	if (Q->front == Q->rear)
		return ERROR;
	Queueptr p = Q->front->next;
	e = p->Qdata;
	Q->front->next = p->next;
	if (Q->rear == p)
		Q->rear = Q->front;
	free(p);
	return e;
}
//判断队列是否为空
Status QueueEmpty(LinkQueue *Q)
{
	if (Q->front == Q->rear)return OK;
	else return ERROR;
}
//遍历队列
void PrintQueue(LinkQueue *Q) {
	//p指向头结点的下一个结点，即存放数据的第一个结点
	Queueptr p = Q->front->next;
	if (QueueEmpty(Q)) {
		printf("链队列为空!\n");
		exit(0);
	}
	else {
		while (p) {
			printf("%d\t", p->Qdata);
			p = p->next;
		}
		printf("\n");
	}
}
//查看队列长度
Status QueueLength(LinkQueue *Q)
{
	Queueptr p = Q->front->next;
	int i = 0;
	while (p != Q->rear)
	{
		p = p->next;
		i++;
	}
	return i;
}
Status Operatemenu(LinkQueue *Q)
{
	int num;
	printf("\t\t\t------****操作菜单****------\n");
	printf("\t\t\t------    1 队尾插入元素\n");
	printf("\t\t\t------    2 删除队头元素\n");
	printf("\t\t\t------    3 查看队长\n");
	printf("\t\t\t------    4 销毁队列\n");
	printf("\t\t\t------    0 退出系统\n\n\n");
	printf("\t\t\t------    请选择你所需要的操作\n");
	scanf("%d", &num);
	switch (num)
	{
	case 1:
		int e0;
		printf("请输入你要插入的元素\n");
		scanf("%d", &e0);
		EnQueue(Q, e0);
		PrintQueue(Q);
		break;
	case 2:
		int e1;
		DeQueue(Q, e1);
		printf("队头元素%d已删除\n", e1);
		PrintQueue(Q);
		break;
	case 3:
		printf("队列长度为%d\n", QueueLength(Q));
		break;
	case 4:
		DestroyQueue(Q);
		PrintQueue(Q);
		break;

	case 0:
		exit(0);


	default:
		printf("输入有误！\n");
		break;
	}
	return OK;

}
void main()
{
	LinkQueue Q;
	InitQueue(&Q);
	QElemType e;
	int L;
	printf("请输入你需要队列的长度\n");
	scanf("%d", &L);
	printf("请输入入队元素\n");
	for (int i = 0; i < L; i++)
	{
		scanf("%d", &e);
		EnQueue(&Q, e);
	}
	PrintQueue(&Q);

	char opp;
	do
	{
		printf("请输入你所需要的操作\n");
		Operatemenu(&Q);
		getchar();
		printf("是否继续y/n\n");
		scanf("%c", &opp);

	} while (opp == 'Y' || opp == 'y');

}
看样子应该是空指针错误，执行   e = p->Qdata;时，p为空，所以造成访问冲突，产生这种情况的原因，可能是已经访问到队列尾部了，它的前一句 Queueptr p = Q->front->next;可能最后的next指针指向空了，所以你在执行 e = p->Qdata前，还需要判断p！=NULL，这样就应该没有冲突了，至于其他逻辑我没仔细看，希望能帮到你
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
//#include<malloc.h>

#define  TRUE  1
#define  FALSE 0
#define  OK    1
#define  ERROR 0

typedef  int  QElemType;
typedef  int    Status;
typedef struct QNode {
    QElemType Qdata;
    struct QNode *next;
}QNode, *Queueptr;

typedef struct {
    Queueptr  front;
    Queueptr  rear;
}LinkQueue;

//建立空队列Q
Status InitQueue(LinkQueue *Q)
{

    Q->front = Q->rear = (Queueptr)malloc(sizeof(QNode));
    if (!Q->front)
        exit(ERROR);
    Q->front->next = NULL;
    return OK;
}

//销毁队列Q
Status DestroyQueue(LinkQueue *Q)
{
#if 1
    Queueptr p = Q->front->next, q;

    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    Q->front->next = NULL;
#else

    while (Q->front) {
        Q->front = Q->front->next;
        free(Q->front);
        Q->front = Q->rear;
    }
#endif
    return OK;
}
//插入元素e为Q的新的队尾元素
Status EnQueue(LinkQueue *Q, QElemType &e)
{

    Queueptr p = (Queueptr)malloc(sizeof(QNode));
    if (!p)
        exit(ERROR);
    p->Qdata = e;
    p->next = NULL;
    Q->rear->next = p;
    //Q->front = p;
    Q->rear = p;
    return OK;
}

//若队列不空，则删除Q的队头元素，用e返回其值，return OK
Status DeQueue(LinkQueue *Q, QElemType &e)
{

    if (Q->front == Q->rear)
        return ERROR;
    Queueptr p = Q->front->next;
    e = p->Qdata;
    Q->front->next = p->next;
    if (Q->rear == p)
        Q->rear = Q->front;
    free(p);
    return e;
}

//判断队列是否为空
Status QueueEmpty(LinkQueue *Q)
{
    if (Q->front == Q->rear)
        return OK;
    else
        return ERROR;
}

//遍历队列
void PrintQueue(LinkQueue *Q) {
    //p指向头结点的下一个结点，即存放数据的第一个结点
    Queueptr p = Q->front->next;
    if (QueueEmpty(Q)) {
        printf("链队列为空!\n");
        exit(0);
    }
    else {
        while (p) {
            printf("%d\t", p->Qdata);
            p = p->next;
        }
        printf("\n");
    }
}
//查看队列长度
Status QueueLength(LinkQueue *Q)
{
    Queueptr p = Q->front->next;
    int i = 0;
    //while (p != Q->rear)
    while (p)
    {
        p = p->next;
        i++;
    }
    return i;
}
Status Operatemenu(LinkQueue *Q)
{
    int num;
    printf("\t\t\t------****操作菜单****------\n");
    printf("\t\t\t------    1 队尾插入元素\n");
    printf("\t\t\t------    2 删除队头元素\n");
    printf("\t\t\t------    3 查看队长\n");
    printf("\t\t\t------    4 销毁队列\n");
    printf("\t\t\t------    0 退出系统\n\n\n");
    printf("\t\t\t------    请选择你所需要的操作\n");
    scanf("%d", &num);
    switch (num)
    {
        case 1:
            int e0;
            printf("请输入你要插入的元素\n");
            scanf("%d", &e0);
            EnQueue(Q, e0);
            PrintQueue(Q);
            break;
        case 2:
            int e1;
            DeQueue(Q, e1);
            printf("队头元素%d已删除\n", e1);
            PrintQueue(Q);
            break;
        case 3:
            printf("队列长度为%d\n", QueueLength(Q));
            break;
        case 4:
            DestroyQueue(Q);
            PrintQueue(Q);
            break;

        case 0:
            exit(0);


        default:
            printf("输入有误！\n");
            break;
    }
    return OK;

}
int main()
{
    LinkQueue Q;
    InitQueue(&Q);
    QElemType e;
    int L;
    printf("请输入你需要队列的长度\n");
    scanf("%d", &L);
    printf("请输入入队元素\n");
    for (int i = 0; i < L; i++)
    {
        scanf("%d", &e);
        EnQueue(&Q, e);
    }
    PrintQueue(&Q);

    char opp;
    do
    {
        printf("请输入你所需要的操作\n");
        Operatemenu(&Q);
        getchar();
        printf("是否继续y/n\n");
        scanf("%c", &opp);

    } while (opp == 'Y' || opp == 'y');

}
参考一下吧，上面的 代码已经修改；
程序有多出问题：
1. 创建队列时，采用尾插法，那么应该让rear指向末节点；
2. 计算队列长度，少算一个节点；比如输入3个节点，但是算出的长度是2；
3. 销毁队列，逻辑有问题；
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
引用 2 楼 自信男孩的回复:#include<stdio.h>
#include<string.h>
#include<stdlib.h>
//#include<malloc.h>

#define  TRUE  1
#define  FALSE 0
#define  OK    1
#define  ERROR 0

typedef  int  QElemType;
typedef  int    Status;
typedef struct QNode {
    QElemType Qdata;
    struct QNode *next;
}QNode, *Queueptr;

typedef struct {
    Queueptr  front;
    Queueptr  rear;
}LinkQueue;

//建立空队列Q
Status InitQueue(LinkQueue *Q)
{

    Q->front = Q->rear = (Queueptr)malloc(sizeof(QNode));
    if (!Q->front)
        exit(ERROR);
    Q->front->next = NULL;
    return OK;
}

//销毁队列Q
Status DestroyQueue(LinkQueue *Q)
{
#if 1
    Queueptr p = Q->front->next, q;

    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    Q->front->next = NULL;
#else

    while (Q->front) {
        Q->front = Q->front->next;
        free(Q->front);
        Q->front = Q->rear;
    }
#endif
    return OK;
}
//插入元素e为Q的新的队尾元素
Status EnQueue(LinkQueue *Q, QElemType &e)
{

    Queueptr p = (Queueptr)malloc(sizeof(QNode));
    if (!p)
        exit(ERROR);
    p->Qdata = e;
    p->next = NULL;
    Q->rear->next = p;
    //Q->front = p;
    Q->rear = p;
    return OK;
}

//若队列不空，则删除Q的队头元素，用e返回其值，return OK
Status DeQueue(LinkQueue *Q, QElemType &e)
{

    if (Q->front == Q->rear)
        return ERROR;
    Queueptr p = Q->front->next;
    e = p->Qdata;
    Q->front->next = p->next;
    if (Q->rear == p)
        Q->rear = Q->front;
    free(p);
    return e;
}

//判断队列是否为空
Status QueueEmpty(LinkQueue *Q)
{
    if (Q->front == Q->rear)
        return OK;
    else
        return ERROR;
}

//遍历队列
void PrintQueue(LinkQueue *Q) {
    //p指向头结点的下一个结点，即存放数据的第一个结点
    Queueptr p = Q->front->next;
    if (QueueEmpty(Q)) {
        printf("链队列为空!\n");
        exit(0);
    }
    else {
        while (p) {
            printf("%d\t", p->Qdata);
            p = p->next;
        }
        printf("\n");
    }
}
//查看队列长度
Status QueueLength(LinkQueue *Q)
{
    Queueptr p = Q->front->next;
    int i = 0;
    //while (p != Q->rear)
    while (p)
    {
        p = p->next;
        i++;
    }
    return i;
}
Status Operatemenu(LinkQueue *Q)
{
    int num;
    printf("\t\t\t------****操作菜单****------\n");
    printf("\t\t\t------    1 队尾插入元素\n");
    printf("\t\t\t------    2 删除队头元素\n");
    printf("\t\t\t------    3 查看队长\n");
    printf("\t\t\t------    4 销毁队列\n");
    printf("\t\t\t------    0 退出系统\n\n\n");
    printf("\t\t\t------    请选择你所需要的操作\n");
    scanf("%d", &num);
    switch (num)
    {
        case 1:
            int e0;
            printf("请输入你要插入的元素\n");
            scanf("%d", &e0);
            EnQueue(Q, e0);
            PrintQueue(Q);
            break;
        case 2:
            int e1;
            DeQueue(Q, e1);
            printf("队头元素%d已删除\n", e1);
            PrintQueue(Q);
            break;
        case 3:
            printf("队列长度为%d\n", QueueLength(Q));
            break;
        case 4:
            DestroyQueue(Q);
            PrintQueue(Q);
            break;

        case 0:
            exit(0);


        default:
            printf("输入有误！\n");
            break;
    }
    return OK;

}
int main()
{
    LinkQueue Q;
    InitQueue(&Q);
    QElemType e;
    int L;
    printf("请输入你需要队列的长度\n");
    scanf("%d", &L);
    printf("请输入入队元素\n");
    for (int i = 0; i < L; i++)
    {
        scanf("%d", &e);
        EnQueue(&Q, e);
    }
    PrintQueue(&Q);

    char opp;
    do
    {
        printf("请输入你所需要的操作\n");
        Operatemenu(&Q);
        getchar();
        printf("是否继续y/n\n");
        scanf("%c", &opp);

    } while (opp == 'Y' || opp == 'y');

}
参考一下吧，上面的 代码已经修改；
程序有多出问题：
1. 创建队列时，采用尾插法，那么应该让rear指向末节点；
2. 计算队列长度，少算一个节点；比如输入3个节点，但是算出的长度是2；
3. 销毁队列，逻辑有问题；
你好，在出队哪块我把队尾写成了队头，已经改正错误，销毁队列应该没错，问题已解决，多谢了！
引用 3 楼 赵4老师的回复:崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
多谢提醒，已经通过断点调试改正错误了。
引用 1 楼 csulizhang的回复:看样子应该是空指针错误，执行   e = p->Qdata;时，p为空，所以造成访问冲突，产生这种情况的原因，可能是已经访问到队列尾部了，它的前一句 Queueptr p = Q->front->next;可能最后的next指针指向空了，所以你在执行 e = p->Qdata前，还需要判断p！=NULL，这样就应该没有冲突了，至于其他逻辑我没仔细看，希望能帮到你
多谢，问题已解决
引用 4 楼 albert_m 的回复:Quote: 引用 2 楼 自信男孩的回复:#include<stdio.h>
#include<string.h>
#include<stdlib.h>
//#include<malloc.h>

#define  TRUE  1
#define  FALSE 0
#define  OK    1
#define  ERROR 0

typedef  int  QElemType;
typedef  int    Status;
typedef struct QNode {
    QElemType Qdata;
    struct QNode *next;
}QNode, *Queueptr;

typedef struct {
    Queueptr  front;
    Queueptr  rear;
}LinkQueue;

//建立空队列Q
Status InitQueue(LinkQueue *Q)
{

    Q->front = Q->rear = (Queueptr)malloc(sizeof(QNode));
    if (!Q->front)
        exit(ERROR);
    Q->front->next = NULL;
    return OK;
}

//销毁队列Q
Status DestroyQueue(LinkQueue *Q)
{
#if 1
    Queueptr p = Q->front->next, q;

    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    Q->front->next = NULL;
#else

    while (Q->front) {
        Q->front = Q->front->next;
        free(Q->front);
        Q->front = Q->rear;
    }
#endif
    return OK;
}
//插入元素e为Q的新的队尾元素
Status EnQueue(LinkQueue *Q, QElemType &e)
{

    Queueptr p = (Queueptr)malloc(sizeof(QNode));
    if (!p)
        exit(ERROR);
    p->Qdata = e;
    p->next = NULL;
    Q->rear->next = p;
    //Q->front = p;
    Q->rear = p;
    return OK;
}

//若队列不空，则删除Q的队头元素，用e返回其值，return OK
Status DeQueue(LinkQueue *Q, QElemType &e)
{

    if (Q->front == Q->rear)
        return ERROR;
    Queueptr p = Q->front->next;
    e = p->Qdata;
    Q->front->next = p->next;
    if (Q->rear == p)
        Q->rear = Q->front;
    free(p);
    return e;
}

//判断队列是否为空
Status QueueEmpty(LinkQueue *Q)
{
    if (Q->front == Q->rear)
        return OK;
    else
        return ERROR;
}

//遍历队列
void PrintQueue(LinkQueue *Q) {
    //p指向头结点的下一个结点，即存放数据的第一个结点
    Queueptr p = Q->front->next;
    if (QueueEmpty(Q)) {
        printf("链队列为空!\n");
        exit(0);
    }
    else {
        while (p) {
            printf("%d\t", p->Qdata);
            p = p->next;
        }
        printf("\n");
    }
}
//查看队列长度
Status QueueLength(LinkQueue *Q)
{
    Queueptr p = Q->front->next;
    int i = 0;
    //while (p != Q->rear)
    while (p)
    {
        p = p->next;
        i++;
    }
    return i;
}
Status Operatemenu(LinkQueue *Q)
{
    int num;
    printf("\t\t\t------****操作菜单****------\n");
    printf("\t\t\t------    1 队尾插入元素\n");
    printf("\t\t\t------    2 删除队头元素\n");
    printf("\t\t\t------    3 查看队长\n");
    printf("\t\t\t------    4 销毁队列\n");
    printf("\t\t\t------    0 退出系统\n\n\n");
    printf("\t\t\t------    请选择你所需要的操作\n");
    scanf("%d", &num);
    switch (num)
    {
        case 1:
            int e0;
            printf("请输入你要插入的元素\n");
            scanf("%d", &e0);
            EnQueue(Q, e0);
            PrintQueue(Q);
            break;
        case 2:
            int e1;
            DeQueue(Q, e1);
            printf("队头元素%d已删除\n", e1);
            PrintQueue(Q);
            break;
        case 3:
            printf("队列长度为%d\n", QueueLength(Q));
            break;
        case 4:
            DestroyQueue(Q);
            PrintQueue(Q);
            break;

        case 0:
            exit(0);


        default:
            printf("输入有误！\n");
            break;
    }
    return OK;

}
int main()
{
    LinkQueue Q;
    InitQueue(&Q);
    QElemType e;
    int L;
    printf("请输入你需要队列的长度\n");
    scanf("%d", &L);
    printf("请输入入队元素\n");
    for (int i = 0; i < L; i++)
    {
        scanf("%d", &e);
        EnQueue(&Q, e);
    }
    PrintQueue(&Q);

    char opp;
    do
    {
        printf("请输入你所需要的操作\n");
        Operatemenu(&Q);
        getchar();
        printf("是否继续y/n\n");
        scanf("%c", &opp);

    } while (opp == 'Y' || opp == 'y');

}
参考一下吧，上面的 代码已经修改；
程序有多出问题：
1. 创建队列时，采用尾插法，那么应该让rear指向末节点；
2. 计算队列长度，少算一个节点；比如输入3个节点，但是算出的长度是2；
3. 销毁队列，逻辑有问题；
你好，在出队哪块我把队尾写成了队头，已经改正错误，销毁队列应该没错，问题已解决，多谢了！
销毁队列不是应该没错，是确实有问题；


找不到kinect.hkinect 
vs2015

                  win10系统，64位机，VS2015专业版，kinect SDK2.0
安装配置之后提示找不到kinect.h，将C:\Program Files\Microsoft SDKs\Kinect\v2.0_1409\inc目录下的kinect.h添加到工程头文件也没有用，


但是我编译却没有报错什么鬼！！

可是明明程序中一篇红啊。。。
而且运行过去了。。
重启电脑
重建所有
……
引用 1 楼 zhao4zhong1 的回复:重启电脑
重建所有
……
没有用
这个问题解决了，但是又出现了另外的问题。。
说说是什么另外问题。
引用 4 楼 zhao4zhong1 的回复:说说是什么另外问题。
就是这个帖子http://bbs.csdn.net/topics/392159703，您也回复了。
引用 5 楼 yangfengman 的回复:Quote: 引用 4 楼 zhao4zhong1 的回复:
说说是什么另外问题。
就是这个帖子http://bbs.csdn.net/topics/392159703，您也回复了。
请严格区分
Win32,x86
和
Win64,x64
请问这个问题怎么解决的~


关于中缀表达式向后缀表达式转换的编程问题 求解答本帖最后由 BH_Little_Lion 于 2017-10-26 19:57:03 编辑



#include<stdio.h> 
#include<string.h>
void PostFix(char *f)
{ char stack[100],x;  int i,k,top;
  top = 0;  stack[0]="#";  i = 0;  k = strlen(f);
  do {
    x = f[i];   
	 switch(x) 
    { case ')':
       while ((top>0) && (stack[top]!="("))
         printf(stack[top--]);
       top--;  break;
    case '+': '-':'*': '/': '^': '%':
       while ((top>0) && (isp(stack[top])>=icp(x))
          printf(stack[top--]);
          stack[++top]=x;  break;
    default: printf(x) ;}
   i=i+1;
  }
   while (i<=k);
while (top>=0);
   printf(stack[top--]);}

int isp(char x) /* 栈内优先级 */

{ 
int a;
switch(x) {
  case '+':a = 1;  break;
   case '-': a = 1;  break;
  case '*':
  a = 2; break;
  case '/':
  a = 2; break;
  case '%': a = 2; break;
  case '^': a = 3; break;
  case '(': a = 0; break;
  case ')': a = 0; break;
  default: a = 0; break; }
return a;}

int icp( char x) /* 栈外优先级 */

{ int a;
  switch(x) {
  case '+': a = 1;  break;
   case '-': a = 1;  break;
  case '*':
  a = 2; break;
  case '/':
  a = 2; break;
  case '%': a = 2; break;
  case '^': a = 4; break;
  case '(': a = 5; break;
  case ')': a = 0; break;
  default: a = 0; break; }
  return a;}

int main()
{	char f[100];
	printf("Please enter a char:\n");
	gets(f);
	PostFix(f);
	return 0;
}



打完代码发现好多问题 自己已经debug到这里了
求编程大神解答 ~debug一点是一点。。。
谢谢！

编译器提示错误有5	21	C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp	[Error] invalid conversion from 'const char*' to 'char' [-fpermissive]

10	39	C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp	[Error] ISO C++ forbids comparison between pointer and integer [-fpermissive]

11	28	C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp	[Error] invalid conversion from 'char' to 'const char*' [-fpermissive]

378	15	c:\program files (x86)\dev-cpp\mingw64\x86_64-w64-mingw32\include\stdio.h	[Error] initializing argument 1 of 'int printf(const char*, ...)' [-fpermissive]

13	18	C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp	[Error] expected ';' before ':' token

17	22	C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp	[Error] invalid conversion from 'char' to 'const char*' [-fpermissive]

1	0	C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp	In file included from C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp

378	15	c:\program files (x86)\dev-cpp\mingw64\x86_64-w64-mingw32\include\stdio.h	[Error] initializing argument 1 of 'int printf(const char*, ...)' [-fpermissive]

22	22	C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp	[Error] invalid conversion from 'char' to 'const char*' [-fpermissive]

1	0	C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp	In file included from C:\Users\hp\Desktop\中缀表达式向后缀表达式的转换.cpp

378	15	c:\program files (x86)\dev-cpp\mingw64\x86_64-w64-mingw32\include\stdio.h	[Error] initializing argument 1 of 'int printf(const char*, ...)' [-fpermissive]
我会啦 printf出的错


class AAA : public BBB<CCC>   <>什么意思？一个类的声明如下:

class AAA : public BBB<CCC>  

 <>是什么意思？ CCC 又是什么？
BBB<CCC>为类模板实例化 , CCC一般为类


各位大侠，如何获取浏览器网页源码？Ax组件
浏览器控件

                  各位大侠，如何获取浏览器网页源码？

使用Ax组件加载浏览器控件，如何获取浏览器浏览网页的源码呢？
Chrome F12
该回复于2017-11-07 09:42:40被管理员删除
右键,查看源
chrome ctrl+u
我是说用什么函数获取 源的字符串文本。。。


为什么这个程序可以在老电脑上运行，但在新的电脑就不行？问题如题，电脑的系统相同。
编译vc++6.0
代码如下：
#include <windows.h>
#include <graphics.h>
#include <conio.h>
#include <stdio.h>

struct COLOUR
{
	long red;
	long green;
	long blue;
};

COLOUR colour[2000][5000];              //为[y][x]
COLORREF up;
HDC hdc = GetDC(NULL);

int WINAPI WinMain(HINSTANCE hInstance,
				   HINSTANCE hPreInstance,
				   LPSTR lpCmdLine,
				   int nShowCmd)
{
	int cx = GetSystemMetrics( SM_CXSCREEN ); 
	int cy = GetSystemMetrics( SM_CYSCREEN );
	int x,y;
	for(y = 0;y <= cy;y++)
	{
		for(x = 0;x <= cx;x++)
		{
			up = GetPixel(hdc, x, y);
			colour[y][x].red = GetRValue(up); //返回R的颜色值！
			colour[y][x].green = GetGValue(up); //返回G的颜色值！
			colour[y][x].blue = GetBValue(up); //返回B的颜色值！
		}
	}
	initgraph(cx, cy);   
	for(y = 0;y <= cy;y++)
	{
		for(x = 0;x <= cx;x++)
		{
			up = RGB(colour[y][x].red,colour[y][x].green,colour[y][x].blue);
			putpixel(x, y, up);
		}
	}
	Sleep(10000);
	return 0;
}
求大神帮忙！
具体是什么错？
代码功能归根结底不是别人帮自己看或讲解或注释出来的；而是被自己静下心来花足够长的时间和精力亲自动手单步或设断点或对执行到某步获得的中间结果显示或写到日志文件中一步一步分析出来的。
提醒：再牛×的老师也无法代替学生自己领悟和上厕所！
单步调试和设断点调试（VS IDE中编译连接通过以后，按F10或F11键单步执行，按Shift+F11退出当前函数；在某行按F9设断点后按F5执行停在该断点处。）是程序员必须掌握的技能之一。

学会使用depends.exe查看exe依赖的其它dll及其版本号。
/*
#include <graphics.h>
initgraph 和 putpixel  两个函数
*
这个头文件 和 2个函数，vc编译器不代，应该是网上 从TC下移植过来的，要配置起来才行
http://www.easyx.cn
COLOUR colour[2000][5000];              //为[y][x]
目测这行代码不爽,用new COLOUR[2000][5000]
测试之
问题已经找出：getpixel太浪费时间。
我尝试循环二十次（一开始的两个for循环）
并用time去时间，文字台输出结果为：

也就是说，按照屏幕这个配置（1600*900），
这两个for（第一二个）所循环的时间为：
1600*900/20*483/1000/60/60约为10
也就是这两个循环需要10分钟才可以结束。
这也是为什么程序思路、逻辑，语法都没错
但是却无法在新的电脑运行的原因：getpixel受设备影响。
学习了
感谢分享


[资源优选]第十九期：20个热门的C语言源码C
资源优选



下载专辑链接：http://download.csdn.net/album/detail/3714
十字链表交换任意两个节点C源代码（C指针应用终极挑战）http://download.csdn.net/detail/zhao4zhong1/5532495

引用 1 楼 zhao4zhong1 的回复:十字链表交换任意两个节点C源代码（C指针应用终极挑战）http://download.csdn.net/detail/zhao4zhong1/5532495

收了

看看是什么~


自创C语言填表式编码风格。欢迎大家用各种语言及其编码风格来PK！
http://bbs.csdn.net/topics/380157851

感谢分享，收藏了
赞一个，收藏了。
C语言怪异代码大赛历届作品大全 1984～1996，1998，2000，2001，2004～2006，2011，2012http://download.csdn.net/detail/zhao4zhong1/5538847
分享是美
C-FREE不错，小巧实用，功能不失强大

下载要积分 全部差评

该回复于2017-06-22 12:32:21被管理员删除
666  很喜欢  正在学
谢谢分享sdadsf
不知道为什么打开后404

佩服佩服666666666666666666666666666666
谢谢分享6666
谢谢楼主分享。


问题咨询题目

两行输出：
第1行，第一个最长的单词。
第2行，第一个最短的单词。
样例输入
I am studying Programming language C in Peking University
样例输出
Programming
I

我自己的写法是 
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
char total[20210];
const int NUM=100;
int main()
{
    int c,i=0;
    int j=0,k=0;
    char MAX[NUM],MIN[NUM];
    int sum1=1,sum2=100;
    char s1[NUM],s2[NUM];
     while((c=cin.get())!=EOF){      //记录输入
        total[i]=c;
        i++;
     }
     for(int i=0;total[i];i++ ){                             //提取连续的两个单词
        while(total[i]!=' '&&total[i]!=','){
            s1[j]=total[i];i++;j++;
        }
        while((total[i+1]!=' ')&&(total[i+1]!=',')){
            s2[k]=total[i];i++;k++;
        }                                        
        if((k-j>0)&&(k>sum1)){strcpy(s1,MAX);sum1=k;}        //通过字符的长度来比较单词的长度
        if((k-j>0)&&(k<sum2)){strcpy(s2,MIN);sum2=j;}
        j=0,k=0;
     }
     cout<<MAX<<endl
         <<MIN<<endl;
    return 0;
}
陷入了死循环。。。。想问一下问题出现在哪？Thanks.
没有输入结束符么?
百度一下eof
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
char total[20210];
const int NUM=100;
int main()
{
    int len = 0; // 新加的
    // int c,i=0;
    char c; int i = 0;
    int j=0,k=0;
    char MAX[NUM],MIN[NUM];
 // int sum1=1,sum2=100;
    int sum1=0,sum2=100;
    char s1[NUM],s2[NUM];
  // while((c=cin.get())!=EOF){
     while((c=getchar())!=EOF){
      //total[i] = c;
        total[len] = c;
        // i++;
        ++len;
     }
 // for(int i=0;total[i];++i){
    for(int i=0;i<len;++i){
     // while(total[i]!=' '&&total[i]!=',')
        while(total[i]!=' '&&total[i]!=','&&i<len){
            s1[j]=total[i];i++;j++;
        }
     // while((total[i+1]!=' ')&&(total[i+1]!=',') &&i<len){
     //     s2[k]=total[i];i++;k++;
     // } 三句删除
        s1[j]=0; s2[k]=0;// 新加的
     // if((k-j>0)&&(k>sum1)){strcpy(s1,MAX);sum1=k;}
        if(j > sum1){strcpy(MAX,s1);sum1=j;}
     // if((k-j>0)&&(k<sum2)){strcpy(s2,MIN);sum2=j;}
        if(j < sum2){strcpy(MIN,s1);sum2=j;}
        j=0,k=0;
     }
     cout<<MAX<<endl
         <<MIN<<endl;
    return 0;
}
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

char total[128];
const int NUM = 80;

int main()
{

#if 1
    int str_len;
    int i = 0, j = 0;
    char max_str[NUM] = {0}, min_str[NUM] = {0}, word[NUM];

    while ((total[i++] = cin.get()) != '\n')
        ;
    total[i] = 0;

    str_len = i + 1;

    for (i = 0; i < str_len; i++) {
        if (total[i] == ' ' || total[i] == ',' || total[i] == 0) {
            word[j] = 0;
            j = 0;
            if (strlen(word) > strlen(max_str))
                strcpy(max_str, word);
            if (strlen(min_str) <= 0)
                strcpy(min_str, word);
        } else {
            word[j++] = total[i];
        }
    }

    cout<<"max str: "<<max_str<<endl;
    cout<<"min str: "<<min_str<<endl;



#else
    int c,i=0;
    int j=0,k=0;
    char MAX[NUM],MIN[NUM];
    int sum1=1,sum2=100;
    char s1[NUM],s2[NUM];


    while ((c=cin.get()) != EOF) {
        total[i] = c;
        i++;
    }
    printf("i = %d\n", i);
    for(int i = 0; total[i]; i++ ){
        while(total[i]!=' '&& total[i] != ','){
            s1[j] = total[i];
            i++;
            j++;
        }
        while((total[i+1]!=' ')&&(total[i+1]!=',')){
            s2[k] = total[i];
            i++;
            k++;
        }
        if((k - j > 0)&&(k>sum1)) {
            strcpy(MAX, s1);
            sum1=k;
        }
        if((k-j>0)&&(k<sum2)){
            strcpy(MIN, s2);
            sum2=j;
        }
        j=0,k=0;
    }
    cout<<MAX<<endl
        <<MIN<<endl;
#endif
    return 0;
}
参考一下吧
一般终端一次（一行）最多输入80个字符，因此没必要申请太多的空间
首先要确定是哪里死循环了，可以加日志确定。
 for(int i=0;total[i];i++ ){                             //提取连续的两个单词
        while(total[i]!=' '&&total[i]!=','){
            s1[j]=total[i];i++;j++;
        }
这里死循环了，修改下，while的条件一直都满足导致。
切割，然后每个字符串的大小
以空格为分割符,每个单词保存一个字符串，最后直接比较字符串
用std::string str， 然后while(cin>>str)就可以了，输入结束需要按Ctrl+Z键。   遇到输入的空格会自动开始下一个str的输入


这段代码怎么改才能把去掉空格后的全输出C
C语言
编程

                  #include <stdio.h>
#include <stdlib.h> 
#include <string.h>


char deblack( char *p , char *q)
 {
	 while( *p )
	 {
		 if( *p == ' ')
			 *p++;
		 else
			 *q++ = *p++;
	 }
	 //printf("%s" , q);

 }
 
 
 void main()
 {
	 FILE *fp ; 
	 char str[100] , str1[100];
	 fp = fopen("a" , "r");
	 while( !feof(fp) )
	 {
		fgets(str , 100 , fp);
		//printf("%s\n" , str);
	 }
	 deblack( str , str1);
	 printf("%s\n" , str1);
	 fclose(fp);
 }





这样只能消除最后一行的空格，怎样修改才能全部输出呢？各位大神
﻿#include <stdio.h>
#include <stdlib.h>
#include <string.h>


char* deblack(char* src)    // 删除C风格字符串中的空格
{
    char* ret = src;
    char* fp = src;
    while (*src) {
        if (*src != ' ') { // 如果不是空格就复制
            *fp = *src;
            fp++;
        }
        src++;
    }
    *fp = '\0' ; //封闭字符串
    return ret;
}


int main()
{
    FILE* fp ;
    char str[100];
    fp = fopen("a.txt", "r");
    while (!feof(fp)) {
        fgets(str, 100, fp);
        printf("%s\n", deblack(str));
    }


    fclose(fp);
}


楼主的代码 少了  *fp = '\0' ; //封闭字符串
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void deblack(char* p, char* q)
{
    while (*p) {
        if (*p == ' ')
            *p++;
        else
            *q++ = *p++;
    }
    *q = '\0';  ///需要把字符串封闭掉

}


int main()
{
    FILE* fp ;
    char str[100], str1[100];
    fp = fopen("a.txt", "r");
    while (!feof(fp)) {
        fgets(str, 100, fp); /// fgets  读取换行的
        deblack(str, str1);
        printf("%s", str1);

    }
    fclose(fp);
}

在楼主的代码上改吧
fgets是一行一行的读，一行一行的传给deblack（*q = '\0';   的用是在每行后面都加\0结束），然后用while (!feof(fp))这个循环把每行都这样遍历一遍     ，     这样理解对吗？
void main() {
    FILE *fp ;
    char str[100] , str1[100];
    fp = fopen("a" , "r");
    while(1)  {
        if (NULL==fgets(str , 100 , fp)) break;
        deblack( str , str1);
        printf("%s\n" , str1);
    }
    fclose(fp);
}
引用 4 楼 zhao4zhong1 的回复:void main() {
    FILE *fp ;
    char str[100] , str1[100];
    fp = fopen("a" , "r");
    while(1)  {
        if (NULL==fgets(str , 100 , fp)) break;
        deblack( str , str1);
        printf("%s\n" , str1);
    }
    fclose(fp);
}
欸，大叔，你这个方法也行耶，那说明我的问题出在没有结束while的判断，所以会出问题。
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void deblack( char *p , char *q)
{
    while (*p) {
        if(*p == ' ')
            p++;
        else
            *q++ = *p++;
    }
    *p = 0;
}

void main()
{
    FILE *fp ;
    char str[100] , str1[100];

    fp = fopen("a" , "r");
    if (!fp)
        return;
    while(!feof(fp))
    {
        fgets(str, 100, fp);
        deblack(str, str1);
        printf("%s" , str1);
    }
    fclose(fp);
}
参考一下吧
再问一下，在怎样改进能使注释符（#） ， 前加上'\t'  或不删除其前的空格

加入"a"的内容是
           ip         =  192.168.219.136                 #这是ip


最后能输出
ip=192.168.219.136                   #这是ip
#include <stdio.h>
void delblank( char *p , char *q)
{
    char c,f;
    f=1;
    while (1) {
        c=*p;
        if (0==c) {
            *q=0;
            break;
        }
        if (f) {
            if ('#'==c) {
                f=0;
                *q='\t';
                q++;
                *q=*p;
                q++;
            } else if (!(' '==c || '\t'==c)) {
                *q=*p;
                q++;
            }
        } else {
            *q=*p;
            q++;
        }
        p++;
    }
}
int main() {
    char str[100]="           ip         =  192.168.219.136                 #这是ip" , str1[100];
    delblank(str,str1);
    printf("%s\n",str1);
    return 0;
}
//ip=192.168.219.136      #这是ip
//
引用 8 楼 zhao4zhong1 的回复:#include <stdio.h>
void delblank( char *p , char *q)
{
    char c,f;
    f=1;
    while (1) {
        c=*p;
        if (0==c) {
            *q=0;
            break;
        }
        if (f) {
            if ('#'==c) {
                f=0;
                *q='\t';
                q++;
                *q=*p;
                q++;
            } else if (!(' '==c || '\t'==c)) {
                *q=*p;
                q++;
            }
        } else {
            *q=*p;
            q++;
        }
        p++;
    }
}
int main() {
    char str[100]="           ip         =  192.168.219.136                 #这是ip" , str1[100];
    delblank(str,str1);
    printf("%s\n",str1);
    return 0;
}
//ip=192.168.219.136      #这是ip
//
谢谢，好厉害，我以后要是也能这样就好了


数据结构中的typedef问题数据结构
C语言
C++

                  typedef struct LNode
{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
这个语句是把名字为LNode的结构体重命名为LNode吗？那个*LinkList是干什么用的？
LinkList代表struct LNode*
引用 1 楼 hefashion0190 的回复:LinkList代表struct LNode*也就是相当于LNode*这个吧？为什么要改成这样呢？还有把struct LNode 改成LNode不就相当于没改吗?
LNode是struct LNode的别名；
同理：LinkList是struct LNode *的别名；
别名，就是用别名就是用struct LNode或struct LNode *
LNode 是  struct LNode
LinkList 是 struct LNode *
LinkList  是为了方便创建结构体指针，你也可以用LNode来创建指针
引用 4 楼 destory27 的回复:LNode 是  struct LNode？
LinkList 是 struct LNode *
LinkList  是为了方便创建结构体指针，你也可以用LNode来创建指针用LNode创建结点，LNode*创建结点指针也是没问题的吧？
LNode 是  struct LNode
LinkList 是 struct LNode *
LinkList  是为了方便创建结构体指针，你也可以用LNode来创建指针

引用 5 楼 zihui0459 的回复:Quote: 引用 4 楼 destory27 的回复:


LNode 是  struct LNode？
LinkList 是 struct LNode *
LinkList  是为了方便创建结构体指针，你也可以用LNode来创建指针用LNode创建结点，LNode*创建结点指针也是没问题的吧？

没问题，又是必须写指针为了做复合结构，面试题常见。例子不记得了
因为本来就是要讲链表。而简单的链表数据结构和Node没有什么区别。所以直接用typedef来重命名，这主要是让语义更清晰。
引用 2 楼 zihui0459 的回复:Quote: 引用 1 楼 hefashion0190 的回复:
LinkList代表struct LNode*也就是相当于LNode*这个吧？为什么要改成这样呢？还有把struct LNode 改成LNode不就相当于没改吗?

c语言中，如果没有使用typedef新定义一个类型的话，需要使用struct LNode和struct LNode*，而此时直接使用LNode和LNode *会语法报错。
C++中struct与class关键字一样定义一个类，只不过struct默认访问属性为public，class访问属性为private
实际定义了两个，一个是把struct LNode别名为LNode，另一个是把struct LNode*别名为LinkList，也就是说LinkList表示指针struct LNode*
理解和讨论之前请先学会如何观察！

//char (*(*x[3])())[5];//x是什么类型的变量?
//
//分析C语言声明，关键是搞清楚这个变量是个什么东西（函数、指针、数组），
//是函数那么剩下的就是他的参数和返回值，
//是指针那剩下部分是说明他指向什么，
//是数组剩下的部分就是说明数组的成员是什么类型。
//解析C语言声明规则：
//从左侧第一个标识符开始，按照优先级进行结合。*表示是..的指针，const表示只读的，volatile表示可变的，[]表示是数组，()表示是函数。
//
//x和[3]结合说明是一个大小为3的数组，该数组的每个元素为一类指针，该类指针指向一类函数，该类函数无参数，返回一类指针，该类指针指向一个大小为5的char型数组
#include <stdio.h>
#include <typeinfo.h>
char num[5];
char (*x00())[5] {
    return &num;
}
int main() {
    char (*(*x[3])())[5];//是个数组，大小为3
    char (*(*x0  )())[5];//数组的元素，是个函数指针
    char (*( x00 )())[5];//函数原型，参数为空，返回值为指针
    char (*  x000   )[5];//返回值

    x0 = x00;
    x[0] = x0;
    x[1] = x0;
    x[2] = x0;
    printf("typeid(x).name() is %s\n",typeid(x).name());
    return 0;
}
//typeid(x).name() is char (* (__cdecl**)(void))[5]
楼上的高手永远这么犀利。


while循环的输出问题，之中可能是scanf_s的输入问题。有大神帮帮菜鸟新人吗while循环
scanf_s

                  [code=c][
#include<stdio.h>
int main(void)
{
	long num;
	long sum = 0L;               // 把 sum 初始化为0
	int status;

	printf("Please enter an integer to be summed ");
	printf("(q to quit): ");
	status = scanf_s("%1d", &num);
	while (status == 1)          // ==不同于= 。 == 是作为测试条件的，该表达式判断status是否等于1
	{
		sum = sum + num;
		printf("Please enter next integer (q to quit): ");
		status = scanf_s("%1d", &num);
	}
	printf("Those integers sum to %1d.\n", sum);

	return 0;
}
]



调试输出的结果是这样的。只要输入的位数在两位及以上，输出的结果就会出现两次Please enter next integer (q to quit)并且最后结果相加的时候是以单个位相加的。请问我错在哪里？怎么才能够正确的使输入的较大的数也能像个位数那样准确输出想要的结果？
将所有%1d都替换为%ld
关于自己是否适合编程的很简单的测试：
在报纸或杂志上随便找一段约1000字的文章，在Word中输入一遍。输完后再参考下面答案：

A里面有10处以上文字或标点错误
B里面没有文字或标点错误并敢为此跟人打赌
C里面没有文字或标点错误并且字体和排版完全与原稿一致
D打印在半透明的纸上和原稿重叠在一起检查一模一样，且自我感觉很有成就感

A不适合编程（理由：打字准确度偏低、粗心大意）
B初级程序员（理由：打字准确度很高、认真细致、自信、理解全角半角概念）
C高级程序员（理由：在B的基础上理解字体和排版也是电脑打印的重要因素、但相比D还不够偏执、精益求精、结果可验证）
D软件项目经理（理由：能针对项目给出令人信服的细致到极点的需求说明和典型测试用例。用户几乎挑不出毛病。专业！）

如果想从A变成B的话，到我的资源http://download.csdn.net/detail/zhao4zhong1/4084259里面下载“适合程序员的键盘练习”


C语言数组指针不能进行自增自减以达到遍历数组的作用吗指针
C语言
数组操作


int *l = (int*)malloc(sizeof(int)*100);
    *l = 1;
    *(++l) = 2;
    printf("%d %d\n", l[0], l[1]);

结果是：2 1684107116
将其改为运算后自加结果改变

int *l = (int*)malloc(sizeof(int)*100);
    *l = 1;
    *(l++) = 2;
    printf("%d %d\n", l[0], l[1]);

结果为：131264 1684107116
只有不用自增运算符时才能得到正确结果，想知道用自增运算符进行运算的过程中发生了什么。
谢谢各位大佬了
各位大佬一起交流下啊，指点小弟一下
你不是刻舟求剑么,指针都++了,读取的当然也是自增后的
int* p=l
用p读取
引用 2 楼 qq_31709097 的回复:你不是刻舟求剑么,指针都++了,读取的当然也是自增后的
int* p=l
用p读取
老哥你没看明白我的意思    我的意思是想问在这自增运算过程中发生了什么，才造成了赋值的错误 = =、
这是问题的原型

Link* k = (Link*)malloc(sizeof(Link));
    k->List = (int*)malloc(sizeof(int)*100);
    k->List[0] = 0;
    k->List[1] = 0;
    printf("%d %d\n", k->List[0], k->List[1]);
    *(k->List) = 1;
    *(k->List) = 2;
    printf("%d %d\n", k->List[0], k->List[1]);
上图的代码有点错误

Link* k = (Link*)malloc(sizeof(Link));
    k->List = (int*)malloc(sizeof(int)*100);
    k->List[0] = 0;
    k->List[1] = 0;
    printf("%d %d\n", k->List[0], k->List[1]);
    *(k->List) = 1;
    *(k->List++) = 2;
    printf("%d %d\n", k->List[0], k->List[1]);
引用 4 楼 qq_35859033 的回复:上图的代码有点错误

Link* k = (Link*)malloc(sizeof(Link));
    k->List = (int*)malloc(sizeof(int)*100);
    k->List[0] = 0;
    k->List[1] = 0;
    printf("%d %d\n", k->List[0], k->List[1]);
    *(k->List) = 1;
    *(k->List++) = 2;
    printf("%d %d\n", k->List[0], k->List[1]);

指针自增是增加一个元素的size
比如p++,原来的p[1]就变成的现在的p[0]了
你又没把它复位,读取就是从p[1]开始的
x++ 和 ++x的区别么?
我也不太理解你的意思
你可以试着单步调试一下
引用 4 楼 qq_35859033 的回复:上图的代码有点错误

Link* k = (Link*)malloc(sizeof(Link));
    k->List = (int*)malloc(sizeof(int)*100);
    k->List[0] = 0;
    k->List[1] = 0;
    printf("%d %d\n", k->List[0], k->List[1]);
    *(k->List) = 1;
    *(k->List++) = 2;
    printf("%d %d\n", k->List[0], k->List[1]);

第一个可以得到两个0，因为List指针没有变化；
第二个输出是2个随机值；
*(k->List++) = 2;该表达式有两个运算，第一个运算是将将2复制给k->List[0]，第二个运算是k->List++;即指针指向了初始的List[1];
没错，开始*(k->List)是给k->List[0]赋值1，但是第二个紧接着是用2覆盖了1；此时List指针已经发生了变化，所以此时的k->List[0]就是申请空间时的List[1]，k->List[1]是开始的List[1]；所以，后面的printf输出两个随机值。*(k->List++) = 2；这样操作会导致内存泄漏，因为找不到申请空间的首地址了，指针指向下一个内存地址（偏移了4字节）；
若第二个表达式变成*(++k->List) = 2;那么输出的是2和一个随机值；这样操作一样会有内存泄露；
解决办法是将k->List指针指向的地址做备份，即int *bak = k->List;这样可以通过bak[0], bak[1]来验证你的赋值是怎样的。另外，free时可以直接free(bak);这样就可以把List申请的空间释放掉，而不会内存泄漏；
引用 7 楼 cfjtaishan 的回复:Quote: 引用 4 楼 qq_35859033 的回复:
上图的代码有点错误

Link* k = (Link*)malloc(sizeof(Link));
    k->List = (int*)malloc(sizeof(int)*100);
    k->List[0] = 0;
    k->List[1] = 0;
    printf("%d %d\n", k->List[0], k->List[1]);
    *(k->List) = 1;
    *(k->List++) = 2;
    printf("%d %d\n", k->List[0], k->List[1]);

第一个可以得到两个0，因为List指针没有变化；
第二个输出是2个随机值；
*(k->List++) = 2;该表达式有两个运算，第一个运算是将将2复制给k->List[0]，第二个运算是k->List++;即指针指向了初始的List[1];
没错，开始*(k->List)是给k->List[0]赋值1，但是第二个紧接着是用2覆盖了1；此时List指针已经发生了变化，所以此时的k->List[0]就是申请空间时的List[1]，k->List[1]是开始的List[1]；所以，后面的printf输出两个随机值。*(k->List++) = 2；这样操作会导致内存泄漏，因为找不到申请空间的首地址了，指针指向下一个内存地址（偏移了4字节）；
若第二个表达式变成*(++k->List) = 2;那么输出的是2和一个随机值；这样操作一样会有内存泄露；
解决办法是将k->List指针指向的地址做备份，即int *bak = k->List;这样可以通过bak[0], bak[1]来验证你的赋值是怎样的。另外，free时可以直接free(bak);这样就可以把List申请的空间释放掉，而不会内存泄漏；
老哥你分析得很对，是我学的太浅了！
好，谢谢楼上几位
2楼大佬说得很对，多调试感受一下，int a[5]={3,4,5,6,7},*p;

	p=&a[0]; 

	printf("%d\n",*p); 
	//printf("%d\n",*p++);
    printf("%d\n",*++p);
	printf("%d\n",*p+1);
用这个代码对比一下。感觉直接对地址自加赋值，指针l所指的空间不一样了
引用 10 楼 lilimite 的回复:2楼大佬说得很对，多调试感受一下，int a[5]={3,4,5,6,7},*p;

	p=&a[0]; 

	printf("%d\n",*p); 
	//printf("%d\n",*p++);
    printf("%d\n",*++p);
	printf("%d\n",*p+1);
用这个代码对比一下。感觉直接对地址自加赋值，指针l所指的空间不一样了
我在分析得时候没有顾及到，沉迷于我自己的理论ａｃ


c/c++,密码有效期的函数比如在xx分xx秒+(0 - 59)秒以后生成的密码要一样，超过60秒后生成的密码就是其它密码
这个函数是要在不同电脑上用的，比如说在客户端xx分xx秒时运行这个函数根据系统时间生成的密码是(1-100)其中的一个，在服务端机器上在(xx分xx秒 + 60)内运行这个函数得到的值要相同，在00:分00秒运行这个函数得到的密码和00:分60秒之前任何时间运行后得到的密码要一样，不能像类似passwd = floor((now - seed)/60 *100) + 1这样的，因为这样的算法导致，比如我在00:分50秒运行这个函数得到的密码和在01:分09秒运行这个函数得到的密码不一样，我的要求是在（任何时间x）执行这个函数得到的密码和（任何时间x+（1-60）秒）执行这个函数得到的值 要一样。这个函数是要在不同的电脑上运行的，且这些电脑都不可互相通信。
有没有办法呢？
你的意思是如果开始时间是13:10:27，则13:11:10得到的密码还是一样的？而不是每60秒都从整分钟数开始计算？
你依然可以用floor函数，或简单的用整型数除法，但必须记录密码产生的时间。
产生新密码时，记录当时的时间，比如用time(NULL)得到一个秒数，用它除以60得到一个整数，用来计算密码，或者简单的假设它就是密码；
每次需要计算密码时查看当前时间和记录时间的差，60秒之内以记录时间计算密码，超过60秒时重新用time(NULL)计算得到一个新的密码。
这样应该就能达到你要的目的了。
补充一下，超过60秒计算新密码时，记录新的时间，接下来的60秒又以该时间进行计算。
这样，倒不如精确到分钟生成一个串；那么在1~60秒就是同一个串。串是指字符串；
引用 2 楼 hzy_76 的回复:你依然可以用floor函数，或简单的用整型数除法，但必须记录密码产生的时间。
产生新密码时，记录当时的时间，比如用time(NULL)得到一个秒数，用它除以60得到一个整数，用来计算密码，或者简单的假设它就是密码；
每次需要计算密码时查看当前时间和记录时间的差，60秒之内以记录时间计算密码，超过60秒时重新用time(NULL)计算得到一个新的密码。
这样应该就能达到你要的目的了。
不可通信，所以没法记录上一次这个函数在哪个PC上执行过
引用 1 楼 hzy_76 的回复:你的意思是如果开始时间是13:10:27，则13:11:10得到的密码还是一样的？而不是每60秒都从整分钟数开始计算？
是的，不是按60秒一次来，是任意时间的（1-60）秒后执行得数得一样
考虑通讯的话，可以在每次生成新的密码时推送新的时间到其他机器，而每个机器如果发现时间超过了60秒，亦需先查询是否在对端记录有新的时间，有则同步，没有则生成新的并发出通知。
但是这只是一对一通讯的情况，如果有多台客户端就比较麻烦，进一步的方案可考虑仅在服务器保存最新的时间，采用确认机制保证每次产生新的时间记录，服务器都有记录。
但这些讨论仅在你要求各自产生密码的前提下，不知道你的具体业务需求，若能考虑仅在服务器生成密码呢？
客户端的数据需要通过密钥加密，然后服务端通过 这个密钥解密数据，这个密钥就是以上我想问的有时效的密钥
以上通信是严格控制的，也无法多附加任何其实数据的传输，只能传输指定的数据。所以没法传输密钥。
唯一共同点就是日期和时间
取秒计数，比如用time()函数，再整除以60得到分计数，以分计数来生成密码就可以。
两端平台一样的话可以用伪随机解决啊	time_t t=time(0);
	t=t-t%60;
	srand(t);
	int encode_key=rand();		//这里可以约定循环取几次

拿到key就随便搞了
引用 8 楼 micckkk 的回复:客户端的数据需要通过密钥加密，然后服务端通过 这个密钥解密数据，这个密钥就是以上我想问的有时效的密钥
以上通信是严格控制的，也无法多附加任何其实数据的传输，只能传输指定的数据。所以没法传输密钥。
唯一共同点就是日期和时间

那么你这个方案就有很大问题，因为首次生成密钥的时间无法同步，即使时间严格一致，也没办法保证知道对方更新密钥的具体秒数——这个数据若要传输必须通过加密通讯，而新的密钥对方却不知道！发现陷入了一个悖论没？
解决办法呢，一是大家都从每分钟的开始更新密钥，二是更新时间通过不加密手段告知对方。

但是我还有另一个疑问，你能保证两台设备的时间严格一致吗？
想了一下，还有另一个做法，更新密钥时也通过加密通讯告知对方，但还用旧密钥通讯，对端收到新的密钥后保存下来，这个过程必须保证可靠，即发送方要确认对端已经收到。确认后方可删除本地旧密钥。
只要两台设备从同一时间服务器定时同步，保证双方时间误差小于一秒就可以。比如这个东西就是每分钟生成一个动态密码：
感谢“老马何以识途”和“早打大打打核战争”你们两位，好像就你们俩位明白我的意思
我最后想了想，在不可能互相通信的情况下，就算时间严格一致也做不到
	for (int i = 0; i < 60; i++)
	{
		getkey(xx分xx秒) = getkey(xx分xx秒 + i)
	}
帖子先留着看看有没有人讨论吧，明天再来看看
自相矛盾，照你的说法，所有时间都只能是同一个值了。1分0秒的密码必须和1分30的密码一样，1分30秒的密码又必须和2分0秒的密码一样，2分0秒的密码又必须和2分30秒的密码一样，2分30秒的密码又必须和3分0秒的密码一样，……
关于时间同步问题，我没测试过如果都同步网络时间的话，能不能达到秒级的一致性。我们以前做过设备时间同步的，有一个时间同步协议，感兴趣的话可以去找来看看。基本的原理我可以在这里给你说说：
首先有一个很重要的假设，就是一来一回两次的数据包传输时间一样。机器A发包时打上时间戳，记为t1，机器B收到包时记录时间T2，回复包时打上另一个时间戳T2，机器A收到回复时记录时间t2。此时机器A可以得知其发包到收到回复的时间是t2 - t1，而机器B的业务处理时间是T2 - T1，则单程的传输时间为((t2 - t1) - (T2 - T1))/2，因为已知机器B的发包时间是T2，因此机器A就可以把自己的时间校正为T2 + ((t2 - t1) - (T2 - T1))/2，即跟机器B同步。
可以看出来这个算法的误差，一是传输时间是否绝对一样，二是设置本地时间所耗费的时间。但是我想这个精度应该已经能满足你的需要了。你可以把这几个时间戳加到数据通讯的报文里，不必单独做时间同步协议，抽取一定比例的数据包中的时间戳用来校正时间就可以了。
不好意思，手误，其中一句要纠正一下：
机器B收到包时记录时间T1
引用 15 楼 baidu_37097818 的回复:自相矛盾，照你的说法，所有时间都只能是同一个值了。1分0秒的密码必须和1分30的密码一样，1分30秒的密码又必须和2分0秒的密码一样，2分0秒的密码又必须和2分30秒的密码一样，2分30秒的密码又必须和3分0秒的密码一样，……
嗯，你这个比喻很到位，确实是我疯了，想多了。哈哈。
引用 16 楼 hzy_76 的回复:关于时间同步问题，我没测试过如果都同步网络时间的话，能不能达到秒级的一致性。我们以前做过设备时间同步的，有一个时间同步协议，感兴趣的话可以去找来看看。基本的原理我可以在这里给你说说：
首先有一个很重要的假设，就是一来一回两次的数据包传输时间一样。机器A发包时打上时间戳，记为t1，机器B收到包时记录时间T2，回复包时打上另一个时间戳T2，机器A收到回复时记录时间t2。此时机器A可以得知其发包到收到回复的时间是t2 - t1，而机器B的业务处理时间是T2 - T1，则单程的传输时间为((t2 - t1) - (T2 - T1))/2，因为已知机器B的发包时间是T2，因此机器A就可以把自己的时间校正为T2 + ((t2 - t1) - (T2 - T1))/2，即跟机器B同步。
可以看出来这个算法的误差，一是传输时间是否绝对一样，二是设置本地时间所耗费的时间。但是我想这个精度应该已经能满足你的需要了。你可以把这几个时间戳加到数据通讯的报文里，不必单独做时间同步协议，抽取一定比例的数据包中的时间戳用来校正时间就可以了。
你说的这些我也早想过，但如果加个前提 ，
这个前提就是在不改变原数据的长度和字节序的情况下（首先这些程序是客户的，我们是在没有程序源码的情况下给这些客户的程序封包加解密，要求不允许改变原始数据长度和字节序），给这些要发送的数据加密，那只能单字节加密，单字节加解密的缺点是太容易看得懂了，比如客户程序有时候 会在短时间内连续发送数据"01 02 00 00 08 08 FF 00 00 AD 00 00"这样的数据,单字节加密，又不可以改这些数据的序列，如果用固定密钥加密，那么加密后的数据还是会变成连续的“xxxxxxxxx”什么的，所以我想到用时间seed做可变的密钥，这样数据就不会还是连续的"xxxxxxxx"，就会变成杂乱无章的字节序。而且老板不允许增加网络开销，其实倒不是怕有什么开销，主要是怕我们的程序hook客户的程序后另发数据包会给客户程序原本的通信验证带来难度，导致各种有可能不稳定的因素。
所以你看在不改变原数据的长度和字节序的还有不发送额外数据情况下怎么做单字节加解密，然后加密后的数据要看起来杂乱无章呢？
不改变长度和字节序？这个要求貌似不是很必要啊，只要在原程序收到之前，被你的程序先解密，原程序收到的依然是正确的数据就够了吧。如果这样的话，就可以考虑压缩和全文加密了。

如果非要这么严格，我给你提供一个思路，不见得好，帮你拓展一下思维：第一个字节转为十进制然后取个位数，按这个数再去取另一个序号的数据，比如02 AB 3F 90这样的头部，按第一个字节02去取第3个字节3F，这个数就用来做密钥的种子。加密时，对第一个字节、所选取的另一个字节（本例中是第3个）不加密。收到数据时也按此思路，保持这两个字节不解密。

这样做不复杂，结果的规律性也不强，你觉得呢？
引用 20 楼 hzy_76 的回复:不改变长度和字节序？这个要求貌似不是很必要啊，只要在原程序收到之前，被你的程序先解密，原程序收到的依然是正确的数据就够了吧。如果这样的话，就可以考虑压缩和全文加密了。

如果非要这么严格，我给你提供一个思路，不见得好，帮你拓展一下思维：第一个字节转为十进制然后取个位数，按这个数再去取另一个序号的数据，比如02 AB 3F 90这样的头部，按第一个字节02去取第3个字节3F，这个数就用来做密钥的种子。加密时，对第一个字节、所选取的另一个字节（本例中是第3个）不加密。收到数据时也按此思路，保持这两个字节不解密。

这样做不复杂，结果的规律性也不强，你觉得呢？
你的这个方法我也试过，奇怪的事，在普通聊天程序上没任何问题，因为没有被HOOK的程序本身就没有其它复杂的字节验证什么的，
但现在碰到的这个网游程序，他本身就有一些验证规则，他的程序是WSARecv接收数据的，不知道他程序怎么处理的，一但不是一个字节一个字节处理他就会强制断开这个socket，你说的先看前一个字节，再处理后一个字节就显然 不行了，只要不是单独处理单字节 就会被断开
网游可能涉及到防外挂机制了，确实比较复杂。
学习路过顶
使用北斗卫星校准时间！
引用 24 楼 zhao4zhong1 的回复:使用北斗卫星校准时间！

你咋不让他买俩原子钟呢...
我是这样想的，客户端有公钥，服务器有私钥，客户端将时间加密，上送到服务器，服务器解密校验看看是不是允许通讯
引用 25 楼 DelphiGuy 的回复:Quote: 引用 24 楼 zhao4zhong1 的回复:
使用北斗卫星校准时间！

你咋不让他买俩原子钟呢... 

估计买原子钟花钱多多了。
引用 27 楼 zhao4zhong1 的回复:Quote: 引用 25 楼 DelphiGuy 的回复:
Quote: 引用 24 楼 zhao4zhong1 的回复:
使用北斗卫星校准时间！

你咋不让他买俩原子钟呢... 

估计买原子钟花钱多多了。

那肯定，最便宜的铷原子钟也要一万多，几百年误差一秒，当然二手拆机的也就几百到一两千，这种廉价原子钟精度还是不如北斗授时的，北斗授时精度可以达到误差0.3纳秒以内。


Visual Studio 2013无法正常设置断点在使用Visual Studio 2013调试C++程序的时候，同一个文件前部分可以正常设置断点，后面部分无法设置，断点处提示：没有与此行关联的调试程序的目标代码类型的可执行代码
可能的原因包括：条件编译，编译器优化或当前调试程序代码类型不支持此行的目标体系结构。
请问这个问题该如何解决？
设置生成Debug版
往前或往后挪几行再设断点
插入断点函数DebugBreak();
是生成的debug版，能够定位到具体行数，在这一行之前是可以设置断点，但是之后就不可以了
重新编译一下
引用 4 楼 falcomavin 的回复:重新编译一下重新编译了n多次了，都没有用
根据断点处小感叹号的提示，可能的原因包括：条件编译，编译器优化或当前调试程序代码类型不支持此行的目标体系结构。这些原因该如何检查呢
使用2楼给出的终极必杀技。
用完别忘了注释掉或删掉。
引用 7 楼 zhao4zhong1 的回复:使用2楼给出的终极必杀技。
用完别忘了注释掉或删掉。好的，先试试，有问题再咨询您
将工程目录下的一些文件删掉，包括 suo、nbf等。
你这个文件可能并没有被编译
清除临时文件，
或者重新构建工程。
各种方法都试过了，都没有解决，最后换回VS2010了，感谢各位的帮助
我和你的问题一样，有的断点跳走或者打不出来，各种工程设置方法都试过了，也重新安装vs2013，都不行
最后考虑是不是代码文件本身的问题，有的源文件打开提示行尾不是Windows（CR LF）格式，我一个一个打开所有源文件，把所有的
行尾（Line Endings）选择Windows（CR LF）后解决了


warning: assignment from incompatible pointer type的问题#include <stdio.h>
#include <stdlib.h>
typedef struct lnode{//定义结点类型
char  data;          //数据域
struct Lnode *next;  //指针域
}lnode;
//生成单链表create
void  creat(lnode *h)
{
    lnode *t,*p;
    char ch;
    t=h;
    while((ch=getchar())!='\n')
    {   //尾插法建立单链表
        p=(lnode*)malloc(sizeof(lnode));//生成新结点p。并分配存储空间
        p->data=ch;
        p->next=NULL;//p的指针域为空
        t->next=(lnode*)p; // p的next指向这个结点
        t=p;// t指向这个结点

    }
}
//遍历单链表
void print(lnode *h)
{
    lnode *p;
    p=p->next;
while(p)
{
printf("%c",p->data);   //输出p的数值域
p=p->next;//p指向下一结点
//if(p->data!=' ')
//printf(" ");
}
}
//求单链表的长度
void length(lnode *h)
{
lnode *p;
int i=0;
p=h->next;
while(p!=NULL)
{
   // if(p->data!=' ')
   // {
        i=i+1;
   // }
    p=p->next;
}
   // i=i-1;
    printf(" %d",i);
}
//数据插入函数
int insert(lnode *h,char x,int i)//h:单链表的头指针 x:要插入的元素 i:要插入的位置
{
int j;
lnode *p,*s;
p=h->next;
j=1;
while(p&&j<i)  //找到要插入的位置
{
++j;
p=p->next;
}
if(i>0&&j==i)
{
s=(lnode*)malloc(sizeof(lnode));
s->data=x;//把x复制给s的数据域
s->next=p->next;//s指向p的下一个结点
p->next=s;//p指向s
return (1);
}
else
return(0);
}
//删除数据函数
int delete_(lnode *h,int i)
{
int j;
lnode *p,*q;
p=h->next;  //p为首结点
j=1;
while(p&&j<i-1)
{
++j;
p=p->next;
}
if(i>0&&j==i-1)
{
q=p->next;//q指向要删除结点的结点
p->next=q->next;//p的下一个结点位q的下一个结点
free(q);   //释放q的空间
return(1);
}
else
return(0); //失败返回0
}
//查找函数
void locate(lnode *h,char x)
{
lnode *p;
p=h->next;//此时p位首节点
while(p!=NULL&&p->data!=x)//进入循环，知道p为空，或找到x
p=p->next;//s指向p的下一个结点
if(p!=NULL)
{
printf("seccess!\n");
printf("你想查看的数据位置 : %c",p->data);
}
else
printf("无法查看此结点\n");
}
//主函数
void main()
{
int i,j,k;
char x,y;
lnode *h;
h=(lnode*)malloc(sizeof(lnode));//建立表头结点
h->next=NULL;
printf("请输入一个单链表:\n");
creat(h);  //建立链表函数
while(1)//功能选择菜单
{
printf("\n");
printf("\n");
printf("+++++++++++++++++++++++");
printf("\n++++1.遍历单链表+++++++");
printf("\n++++2.求单链表的长度+++");
printf("\n++++3.单链表的插入+++++");
printf("\n++++4.单链表的删除+++++");
printf("\n++++5查找数据地址++++++");
printf("\n++++6.退出+++++++++");
printf("\n+++++++++++++++++++++++");
printf("\n");
printf("选择查看1~6: ");
scanf("%d",&i);
if(i<0||i>7)
printf("超出查询范围!\n");
if(i==1)
{
printf("输出单链表:");
print(h);
}
if(i==2)
{
printf("单链表的长度为；");
length(h);
printf("\n");
}
if(i==3)
{
getchar();
printf("输入插入内容");
x=getchar();
printf("\n输入插入数据位置；");
scanf("%d",&j);
insert(h,x,j);
}
if(i==4) //删除函数
{
printf("输入删除位置");
scanf("%d",&k);
delete_(h,k);
}
if(i==5)
{
getchar();
printf("输入所需要查找的数据");
y=getchar();
locate(h,y);
}
if(i==6) break;
}
printf(" \n ...");
getch();
}
都是这个警告
warning: assignment from incompatible pointer type
哪位大神能解答下谢谢
有多个问题，
问题1：结构体声明时，名字写错了"struct Lnode"--->"struct lnode"，应该是后者；
问题2：print函数都没有对定义的p指针初始化，而就直接使用p = p->next;很容易导致段错误；
问题3：insert和delete_函数都不能对1位置进行插入和删除；

以下是修改后的代码，参考一下吧：

#include <stdio.h>
#include <stdlib.h>

typedef struct lnode{
    char  data;
    struct lnode *next;
}lnode;

//生成单链表create
void  creat(lnode *h)
{
    lnode *t,*p;
    char ch;
    t = h;
    while((ch = getchar())!='\n')
    {   //尾插法建立单链表
        p = (lnode *)malloc(sizeof(lnode));//生成新结点p。并分配存储空间
        p->data=ch;
        p->next = NULL;//p的指针域为空
        t->next = p; // p的next指向这个结点
        t=p;

    }
}
//遍历单链表
void print(lnode *h)
{
    lnode *p = h->next;
    while(p)
    {
        printf("%c", p->data);   //输出p的数值域
        p = p->next;//p指向下一结点
        //if(p->data!=' ')
        //printf(" ");
    }
}
//求单链表的长度
void length(lnode *h)
{
    lnode *p = h->next;
    int i=0;
    while(p)
    {
        // if(p->data!=' ')
        // {
        i=i+1;
        // }
        p=p->next;
    }
    // i=i-1;
    printf(" length: %d\n",i);
}
//数据插入函数
int insert(lnode *h, char x, int i)//h:单链表的头指针 x:要插入的元素 i:要插入的位置
{
    int j;
    lnode *p,*s;
    p = h;
    j=1;
    while(p&&j<i)  //找到要插入的位置
    {
        ++j;
        p = p->next;
    }
    if(i>0&&j==i)
    {
        s = (lnode*)malloc(sizeof(lnode));
        s->data = x;//把x复制给s的数据域
        s->next = p->next;//s指向p的下一个结点
        p->next = s;//p指向s
        return (1);
    }
    else
        return(0);
}
//删除数据函数
int delete_(lnode *h,int i)
{
    int j;
    lnode *p,*q;
    p = h;  //p为首结点
    j=1;
    while(p&&j<i)
    {
        ++j;
        p=p->next;
    }
    if(i>0&&j==i)
    {
        q=p->next;//q指向要删除结点的结点
        p->next=q->next;//p的下一个结点位q的下一个结点
        free(q);   //释放q的空间
        return(1);
    }
    else
        return(0); //失败返回0
}
//查找函数
void locate(lnode *h,char x)
{
    lnode *p;
    int idx = 1;
    p = h->next;//此时p位首节点
    while(p && p->data != x) {
        idx++;
        p=p->next;//s指向p的下一个结点
    }
    if(p)
    {
        printf("seccess!\n");
        printf("你想查看的数据位置 : pos: %d, val: %c", idx, p->data);
    }
    else
        printf("无法查看此结点\n");
}
//主函数
//void main()
int main()
{
    int i,j,k;
    char x,y;
    lnode *h;
    h=(lnode*)malloc(sizeof(lnode));//建立表头结点
    h->next = NULL;
    printf("请输入一个单链表:\n");
    creat(h);  //建立链表函数
    while(1)//功能选择菜单
    {
        printf("\n");
        printf("\n");
        printf("+++++++++++++++++++++++");
        printf("\n++++1.遍历单链表+++++++");
        printf("\n++++2.求单链表的长度+++");
        printf("\n++++3.单链表的插入+++++");
        printf("\n++++4.单链表的删除+++++");
        printf("\n++++5查找数据地址++++++");
        printf("\n++++6.退出+++++++++");
        printf("\n+++++++++++++++++++++++");
        printf("\n");
        printf("选择查看1~6: ");
        scanf("%d",&i);
        if(i<0||i>7)
            printf("超出查询范围!\n");
        if(i==1)
        {
            printf("输出单链表:");
            print(h);
        }
        if(i==2)
        {
            printf("单链表的长度为；");
            length(h);
            printf("\n");
        }
        if(i==3)
        {
            getchar();
            printf("输入插入内容");
            x=getchar();
            printf("\n输入插入数据位置；");
            scanf("%d",&j);
            insert(h,x,j);
        }
        if(i==4) //删除函数
        {
            printf("输入删除位置");
            scanf("%d",&k);
            delete_(h,k);
        }
        if(i==5)
        {
            getchar();
            printf("输入所需要查找的数据");
            y=getchar();
            locate(h,y);
        }
        if(i==6) break;
    }
    printf(" \n ...");
    //getch();
}

代码的风格建议注意下，可以参考以下比如华为的编码风格，或者Linux内核的风格等等；
注释不需要太多，没必要的注释尽量不要加；函数名如果能定义成见名知意最好；
数据结构对单链表进行数据排序 http://bbs.csdn.net/topics/392201633


关于字符数组的问题要求输入一个密码，其中必须满足几个条件，其中一个条件是该密码必需包含特殊字母~ @ ！ # $ % ^之一,我定义了一个字符数组char b[50]，
输入了密码后
程序中通过
	c=strlen(b);

	for(i=0;i<c;i++)
	{

			if(b[i]=='~'||'!'||'@'||'#'||'$'||'%'||'^'){  e=e+1;break;
			}
}
,来判断是不是满足这个条件，但在调试中发现不管是不是包含这些特殊字符,e都会在这里+1,为什么会出现这种情况。
if(b[i]=='~'||'!'||'@'||'#'||'$'||'%'||'^')不能这样比较
应该if(b[i]=='~'||b[i]=='@'。。。。。)分开这样，
你写的比较只会判断第一个是否含有'~'然后因为'@'等的值肯定为真所以e都会+1；
c = strlen(b);

for(i=0;i<c;i++)
{

    if(b[i]=='~'|| b[i] == '!'|| b[i] == '@'|| b[i] == '#'|| b[i] == '$'|| b[i] == '%'|| b[i] == '^') {
        e = e+1;
        break;
    }
}
C语言语法还需要加强学习呀
c = strlen(b);

for (i=0;i<c;i++) {

    if (b[i] == '~'
     || b[i] == '!'
     || b[i] == '@'
     || b[i] == '#'
     || b[i] == '$'
     || b[i] == '%'
     || b[i] == '^') {
         e = e+1;
         break;
    }
}

//----------------------
c = strlen(b);

for (i=0;i<c;i++) {

    if (strchr("~!@#$%^",b[i])) {
        e = e+1;
        break;
    }
}
if(b[i]=='~'||'!'||'@'||'#'||'$'||'%'||'^') 不能这样写，你需要分成多个，if(b[i]=='~'|| b[i] == '!'|| b[i] == '@'|| b[i] == '#'|| b[i] == '$'|| b[i] == '%'|| b[i] == '^')
一起写表示的是判断b是否等于后面这些做||运算的结果


keil5单片机


请问这个该如何处理
没有main函数?
程序不知道入口 不知道从哪里开始运行
有啊
555文件连个后缀名都没有不应该是.c文件?
这个文件也没有添加到项目中去..为什么不好好看一下教程?
main函数在.h文件中？
你的Main函数没有得到定义，就算再怎么是.h文件，前面也应该有定义
你的Main函数定义好了后，它所在的555.c文件也要添加到项目里，才能编译
现在又出现了这些错误   这是咋回事呢
int main
int mian


C++学生管理系统C++
类
成员函数
析构函数
构造函数

                  课本上的一道题，老师改了一下，上机操作总是有错误，不知道怎么改，请教大神，谢谢

老师要求身份证号改为成绩A，B，C，D，和日期一样做一个类，不需要使用内联函数。
不会引用只能复制粘贴，可能看起来比较麻烦，求大神帮帮忙啦！！！
谢谢！！！


#include <iostream>
#include <string>
using namespace std;

class Date
{
public:
	Date(int,int,int);
	int getYear();
	int getMonth();
	int getDay();
private:
	int year;
	int month;
	int day;
};
Date::Date(int Year,int Month,int Day):year(Year),month(Month),day(Day)
{
	year=Year;
	month=Month;
	day=Day;
}
int Date::getYear()
{
	return year;
}
int Date::getMonth()
{
	return month;
}
int Date::getDay()
{
	return day;
}

class Score
{
public:
	Score(char);
    char getScore();
private:
	char score;
};
Score:: Score(char score)
{
	score=score;
}
char Score::getScore ()
{
	return score;
}
class Student
{
public:
	Student(int,string,char,int,int,int,char);
	Student(Student &s);
	void Show();
	int getNumber();
	string getName();
	char getSex();
	
	~Student(){};
private:
	int number;
	string name;
	char sex;
	
	Date d;
	Score score;
};
Student::Student(int Number,string Name,char Sex,int Year=0,int Month=0,int Day=0,char Score)
	:number(Number),name(Name),sex(Sex),d(Year,Month,Day),score(score)
{}
int Student::getNumber()
{
	return number;
}
string Student::getName()
{
	return name;
}
char Student::getSex()
{
	return sex;
}

Student::Student(Student &s):d(s.d.getYear(),s.d.getMonth(),s.d.getDay())
{
	number=s.getNumber();
	name=s.getName();
	sex=s.getSex();
	
}
Score::Score()
{
	return score;
}
void Student::Show()
{
	cout<<"学号：	"<<getNumber()<<endl;
	cout<<"姓名：	"<<getName()<<endl;
	cout<<"性别：	"<<getSex()<<endl;
	cout<<"出生年月：	"<<d.getYear()<<"	"<<d.getMonth()<<"	"<<d.getDay()<<"	"<<endl;
	cout<<"成绩："<<score.getScore()<<endl;
}

void Set()
{
	int inu,iye,imo,ida;
	char cse,iscore;
	string sna;
	cout<<"请输入学号：	";
	cin>>inu;
	cout<<"请输入名字：	";
	cin>>sna;
	cout<<endl;
	cout<<"请输入性别（男性输入M，女性输入W）：	";
	cin>>cse;
	cout<<"请输入出生年月日（中间用空格隔开）：	";
	cin>>iye>>imo>>ida;
	cout<<"请输入成绩：	";
	cin>>iscore;
	
	Student s(inu,sna,cse,iye,imo,ida,iscore);
	s.Show();
}
int main()
{
    for(int i=0;i<10000;i++)
	{
		cout<<"请输入第"<<i+1<<"个学生信息"<<endl;
	   Set();
	   cout<<endl;
	}
	return 0;
}
参数char Score也需要一个默认值
引用 1 楼 paschen 的回复:参数char Score也需要一个默认值
不是要手动输入成绩吗，怎么设默认值？
Date::Date(int Year,int Month,int Day):year(Year),month(Month),day(Day)
{
    year=Year;
    month=Month;
    day=Day;
}
/* 有初始化列表，还需要赋值吗？ 可以通过， 但概念不清*/


Student::Student(int Number,string Name,char Sex,int Year=0,int Month=0,int Day=0,char Score)  /*形参含默认值， 但Score却没有，（含默认值形参项后都含默认值）*/
引用 3 楼 destory27的回复:Date::Date(int Year,int Month,int Day):year(Year),month(Month),day(Day)
{
    year=Year;
    month=Month;
    day=Day;
}
/* 有初始化列表，还需要赋值吗？ 可以通过， 但概念不清*/


Student::Student(int Number,string Name,char Sex,int Year=0,int Month=0,int Day=0,char Score)  /*形参含默认值， 但Score却没有，（含默认值形参项后都含默认值）*/
请问要怎么改啊？您说的看不太懂。
引用 2 楼 x519942447 的回复:Quote: 引用 1 楼 paschen 的回复:参数char Score也需要一个默认值不是要手动输入成绩吗，怎么设默认值？

你前面的参数既然有默认值，后面的参数也需要，这与需不需要手动输入无关，除非你把这个参数放到所有有默认值参数的前面
引用 5 楼 paschen的回复:Quote: 引用 2 楼 x519942447 的回复:Quote: 引用 1 楼 paschen 的回复:参数char Score也需要一个默认值不是要手动输入成绩吗，怎么设默认值？

你前面的参数既然有默认值，后面的参数也需要，这与需不需要手动输入无关，除非你把这个参数放到所有有默认值参数的前面
放到前边也有错啊，在后边赋了初值最后输出成绩那栏没有输出，再帮忙看看，谢谢！
我有一个疑惑，为什么成绩要用char 呢？用了char的话，输入成绩的时候不是只能接收一个字符即只有一个数字吗？要不你把它改成int 试试？
引用 7 楼 le_silence_de_la_mer的回复:我有一个疑惑，为什么成绩要用char 呢？用了char的话，输入成绩的时候不是只能接收一个字符即只有一个数字吗？要不你把它改成int 试试？
要求成绩以A,B,C,D的形式输出
引用 4 楼 x519942447 的回复:Quote: 引用 3 楼 destory27的回复:
Date::Date(int Year,int Month,int Day):year(Year),month(Month),day(Day)
{
    year=Year;
    month=Month;
    day=Day;
}
/* 有初始化列表，还需要赋值吗？ 可以通过， 但概念不清*/


Student::Student(int Number,string Name,char Sex,int Year=0,int Month=0,int Day=0,char Score)  /*形参含默认值， 但Score却没有，（含默认值形参项后都含默认值）*/
请问要怎么改啊？您说的看不太懂。


Date::Date(int Year,int Month,int Day):year(Year),month(Month),day(Day)
{
}

Student::Student(int Number,string Name,char Sex,int Year=0,int Month=0,int Day=0,char Score = ‘ ’) ；或
Student::Student(int Number,string Name,char Sex,char Score，int Year=0,int Month=0,int Day=0);注意传参


小白向各位大神求教一个编译问题本人用记事本写下helloworld的代码，
然后将文件名整个改成1.c（此处确认是整个改过来，显示的也是c sources），
之后我用visual studio 下的命令行提示符对他进行编译，结果显示的是fatalerror  c1083  无法打开源文件，
我确定敲上去的代码没有错误，然后我直接打开这个文件，他自动用vs打开，但是我点击调试选项却发现无法调试，我上网搜索之后业务好的解决办法，希望各位能不吝赐教。
你先建立个工程 把文件加进去再试着编译
VS新建C++项目，在编译运行或者调试
单独一个C文件无法编译，你需要建立一个工程，然后添加进去
谢谢各位大神，尽管结果还是不尽人意，但是还是很感谢各位的帮助，每位我都给分了


求解一个输出问题？#include <stdio.h>
#include <stdlib.h>
int main(void)
{
	int a,b,c;
	scanf_s("%d%d&d",&a,&b,&c);
	printf("%d%d%d",a,b,c);
	system("pause");
	return 0;
}
为什么输出不了三个数？
输入函数用的不对
详情百度scanf_s的用法

以上改为scanf也可以
%d%d&d
scanf_s("%d%d&d",&a,&b,&c); -> scanf_s("%d%d%d",&a,&b,&c);
写着写着，第三个的%写成&呢
个人建议编译的时候不要放过任何警告；争取将警告也一并去掉；
关于自己是否适合编程的很简单的测试：
在报纸或杂志上随便找一段约1000字的文章，在Word中输入一遍。输完后再参考下面答案：

A里面有10处以上文字或标点错误
B里面没有文字或标点错误并敢为此跟人打赌
C里面没有文字或标点错误并且字体和排版完全与原稿一致
D打印在半透明的纸上和原稿重叠在一起检查一模一样，且自我感觉很有成就感

A不适合编程（理由：打字准确度偏低、粗心大意）
B初级程序员（理由：打字准确度很高、认真细致、自信、理解全角半角概念）
C高级程序员（理由：在B的基础上理解字体和排版也是电脑打印的重要因素、但相比D还不够偏执、精益求精、结果可验证）
D软件项目经理（理由：能针对项目给出令人信服的细致到极点的需求说明和典型测试用例。用户几乎挑不出毛病。专业！）

如果想从A变成B的话，到我的资源http://download.csdn.net/detail/zhao4zhong1/4084259里面下载“适合程序员的键盘练习”

printf里面的%和变量的一一对应关系
scanf里面的%和变量以及变量前加不加&的一一对应关系
是C代码中非常容易出错的地方，而且通常编译还不出错。
所以在编译源代码之前值得专门仔细检查一遍甚至多遍。
看编译器错误提示，就算不能直接指出错误，也能大概知道错在哪一行了。


求助程序停止工作 C语言C语言

                  我想做一个赫夫曼树，想使用动态数组，经过一番折腾之后，没有error 了，可是运行之后 就弹出了 停止工作 ！！ 我觉得是哪里内存分配出了问题，但是作为小白实在找不到问题在哪里！！！ 求助各位大神了~
#include<stdio.h>
#include<stdlib.h>
	typedef struct huftree{
	int weight;
	int Plink,Llink,Rlink;
	} *HFT,Tnode;
	typedef struct hufcode{
	int star;
	int symbol;
    int bits[5]; 
	} *HFC,Cnode;
	
	void intilTree(int *w,int n,HFT ht,HFC hc){
        int i;
		for(i=1;i<n+1;i++){
			ht[i].Llink=0;
			ht[i].Plink=0;
			ht[i].Rlink=0;
			ht[i].weight=w[i];
			
		}
		for(i;i<2*n;i++){
			ht[i].Llink=0;
			ht[i].Plink=0;
			ht[i].Rlink=0;
			ht[i].weight=0;
		}
	
	}//intil
main(){
	HFT ht;
    HFC hc;
int n;
int *w;
int i=0;
int w0;
int m;
m=2*n-1;
	printf("shuru N\n");
		scanf("%d",&n);
		w=(int*)malloc((n+1)*sizeof(int));
		ht=(HFT)malloc((m+1)*sizeof(Tnode));
		hc=(HFC)malloc((n+1)*sizeof(Cnode));
		
	for(i=1;i<n+1;i++){
		 printf("第%d个权值\n",i);
			scanf("%d",&w0);
			w[i]=w0;
		}
	intilTree(w,n,ht,hc);
	for(i=1;i<=m;i++){
	printf("%d   %d   %d  %d\n",ht[i].weight,ht[i].Llink,ht[i].Rlink,ht[i].Plink);
	}
}
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
#include<stdio.h>
#include<stdlib.h>
typedef struct huftree{
    int weight;
    int Plink,Llink,Rlink;
} *HFT,Tnode;
typedef struct hufcode{
    int star;
    int symbol;
    int bits[5];
} *HFC,Cnode;

void intilTree(int *w,int n,HFT ht,HFC hc){
    int i;
    for(i=1;i<n+1;i++){
        ht[i].Llink=0;
        ht[i].Plink=0;
        ht[i].Rlink=0;
        ht[i].weight=w[i];

    }
    for(;i<2*n;i++){
        ht[i].Llink=0;
        ht[i].Plink=0;
        ht[i].Rlink=0;
        ht[i].weight=0;
    }

}//intil
main(){
    HFT ht;
    HFC hc;
    int n;
    int *w;
    int i=0;
    int w0;
    int m;
    printf("shuru N\n");
    scanf("%d",&n);
    m=2*n-1;
    w=(int*)malloc((n+1)*sizeof(int));
    ht=(HFT)malloc((m+1)*sizeof(Tnode));
    hc=(HFC)malloc((n+1)*sizeof(Cnode));

    for(i=1;i<n+1;i++){
        printf("第%d个权值\n",i);
        scanf("%d",&w0);
        w[i]=w0;
    }
    intilTree(w,n,ht,hc);
    printf("helloworld!\n");
    for(i=1;i<=m;i++){
        printf("%d   %d   %d  %d\n",ht[i].weight,ht[i].Llink,ht[i].Rlink,ht[i].Plink);
    }
}
如上的代码；
主要改一下一条代码语句的位置即可。即
    scanf("%d",&n);
    m=2*n-1;
m = 2 * n -1;需要放在scanf之后，不然，n是随机值（可能很大，导致输出时越界，出现楼主的停止运行），那么m = 2 * n -1也会变得很大；
所以，m = 2 * n -1需要放在scanf之后，这样n确定大小了，m的值也会确定大小了。
引用 2 楼 cfjtaishan 的回复:#include<stdio.h>
#include<stdlib.h>
typedef struct huftree{
    int weight;
    int Plink,Llink,Rlink;
} *HFT,Tnode;
typedef struct hufcode{
    int star;
    int symbol;
    int bits[5];
} *HFC,Cnode;

void intilTree(int *w,int n,HFT ht,HFC hc){
    int i;
    for(i=1;i<n+1;i++){
        ht[i].Llink=0;
        ht[i].Plink=0;
        ht[i].Rlink=0;
        ht[i].weight=w[i];

    }
    for(;i<2*n;i++){
        ht[i].Llink=0;
        ht[i].Plink=0;
        ht[i].Rlink=0;
        ht[i].weight=0;
    }

}//intil
main(){
    HFT ht;
    HFC hc;
    int n;
    int *w;
    int i=0;
    int w0;
    int m;
    printf("shuru N\n");
    scanf("%d",&n);
    m=2*n-1;
    w=(int*)malloc((n+1)*sizeof(int));
    ht=(HFT)malloc((m+1)*sizeof(Tnode));
    hc=(HFC)malloc((n+1)*sizeof(Cnode));

    for(i=1;i<n+1;i++){
        printf("第%d个权值\n",i);
        scanf("%d",&w0);
        w[i]=w0;
    }
    intilTree(w,n,ht,hc);
    printf("helloworld!\n");
    for(i=1;i<=m;i++){
        printf("%d   %d   %d  %d\n",ht[i].weight,ht[i].Llink,ht[i].Rlink,ht[i].Plink);
    }
}
如上的代码；
主要改一下一条代码语句的位置即可。即
    scanf("%d",&n);
    m=2*n-1;
m = 2 * n -1;需要放在scanf之后，不然，n是随机值（可能很大，导致输出时越界，出现楼主的停止运行），那么m = 2 * n -1也会变得很大；
所以，m = 2 * n -1需要放在scanf之后，这样n确定大小了，m的值也会确定大小了。  谢谢谢谢 牛逼牛逼！！！！！！ 找了好久好久   都快崩溃了，原来问题出在这


我写的这个void函数为啥不能输出啊？c++

                  void mystring::changeSmall()
{
	cout<<string<<endl;
	char *p;
	p=new char[51];strcpy(p,string);
	while(*p)
 {
  if(*p>='a'&&*p<='z')
	 *p=*p-'a'+'A';
  p++;
 }

	cout<<p<<endl;
}
主函数入口在哪？程序是从main()函数开始，遇return结束。你这没有main()函数。编译器怎么知道你有没有开始。
主函数：
#include <iostream>
#include "mystring.h"
using namespace std;
int main()
{
	char *s="Hello World!";

	mystring m1;
	m1.SetSentence(s);
	m1.print1();
	m1.changeSmall();
	return 0;
}
mystring .h:
#pragma once
#ifndef MYSTRING_H
#define MYSTRING_H
class mystring
{
public:
	char *string;
	mystring(void);
	void SetSentence(char *s);
	char *GetSetence(){return string;}
	void print1();
	void changeSmall();

	~mystring(void);
};
#endif
void mystring::changeSmall()
{
    cout<<string<<endl;
    char *p, *q;
    p = new char[51];
    strcpy(p,string);
    q = p;
    while(*p)
    {
        if(*p>='a'&&*p<='z')
            *p=*p-'a'+'A';
        p++;
    }

    p = q;
    cout<<p<<endl;
}

参考一下吧；
因为p已经指向了'\0'，无法输出了。
所以得让p重新指向字符串的开始位置；先用q保存字符串开始位置，等p++指向'\0'时，再把字符串的首地址给p吧
void mystring::changeSmall()
{
     cout<<string<<endl;
     char *p;
     p=new char[51];strcpy(p,string);
    while(*p)
   {
      if(*p>='a'&&*p<='z')
     *p=*p-'a'+'A';
     p++;                           //此时指针已经移动 
  }
                                      //while循环结束是*p的值为‘\0’
   cout<<p<<endl;          //Error     可以先保存p的值，再执行while
}
引用 3 楼 cfjtaishan 的回复:void mystring::changeSmall()
{
    cout<<string<<endl;
    char *p, *q;
    p = new char[51];
    strcpy(p,string);
    q = p;
    while(*p)
    {
        if(*p>='a'&&*p<='z')
            *p=*p-'a'+'A';
        p++;
    }

    p = q;
    cout<<p<<endl;
}

参考一下吧；
因为p已经指向了'\0'，无法输出了。
所以得让p重新指向字符串的开始位置；先用q保存字符串开始位置，等p++指向'\0'时，再把字符串的首地址给p吧
懂啦懂啦


c++有function这个关键字吗？最近看GoogleTest示例，看到sample3-inl.h文件中有这样一段代码是这样的：

  // Applies a function/functor on each element of the queue, and
  // returns the result in a new queue.  The original queue is not
  // affected.
  template <typename F>
  Queue* Map(F function) const {
    Queue* new_queue = new Queue();
    for (const QueueNode<E>* node = head_; node != NULL; node = node->next_) {
      new_queue->Enqueue(function(node->element()));
    }

    return new_queue;
  }

代码中Map函数的参数让我很疑惑，function可以代入任意函数，譬如

  // A helper function that some test uses.
  static int Double(int n) {
    return 2*n;
  }

  // A helper function for testing Queue::Map().
  void MapTester(const Queue<int> * q) {
    // Creates a new queue, where each element is twice as big as the
    // corresponding one in q.
    const Queue<int> * const new_q = q->Map(Double);
    ...
  }


这个语法大家有学过吗？我没查到啊，既不是模板函数，也不是伪函数，这个F function到底是神马？
我的理解为函数指针，类似于：

typedef int (*F)(int);
F function;
引用 1 楼 hefashion0190 的回复:我的理解为函数指针，类似于：

typedef int (*F)(int);
F function;

谢谢回复，你说的有点道理，那有没有相关的语法说明呢？
函数指针的语法？　可以度娘一下，不是什么新东西
就是模板……
C++有函数类型和函数指针类型，函数名可以作为表达式，其类型就是相应的函数类型，指代相应函数。进行模板参数推断时实参先退化成函数指针类型，然后F就被推断成了相应的函数指针类型。
VS IDE中，在不明白的符号function上点鼠标右键，选转到定义。
引用 4 楼 xsklld 的回复:就是模板……
C++有函数类型和函数指针类型，函数名可以作为表达式，其类型就是相应的函数类型，指代相应函数。进行模板参数推断时实参先退化成函数指针类型，然后F就被推断成了相应的函数指针类型。
所以我把 Map(F function)改成 Map(F G)以后不影响编译和运行，function不是关键字。
谢谢大神，应该能结帖了，我得学习下模板编程了


求助!  奇怪的C语言计算偏差  求大佬解决题目是这样的。。。。
        在项目产生利润之前需要先投入建设资金（假设称为 c0），建成后每年产生的利润（假设称为 c1,c2…）。内部回报率（记为 r，范围为 −100%∽+100%）是到项目末期的现金流为 0 的贴现率。

例如：某项目建设资金为 10000，项目生产持续期为 3 年，每年利润为 3000,4000,5000，那么 r 满足：
−10000(1+r)^3+3000(1+r)^2+4000(1+r)+5000=0
Excel 计算结果 r 大约为 8.8963%。

本题的测试数据保证 r 只有唯一解。
Input
第 1 行：整数 T (1≤T≤10) 为问题数。
第 2∽3 行：第一个问题的数据。一行整数 n (1≤n≤100) 表示项目生产年数。后面 1 行包含 n+1 个由一个空格分隔的整数，表示投入的建设资金 c0 和 n 年中每年的利润 ci。c0>0,0≤ci≤1 000 000 000。
第 4∽2T+1 行：后面问题的数据，格式与第一个问题相同。

所以我觉得应该可以用牛顿迭代法做，，，，，但是遇到了奇怪的问题    
下面的代码中举了个例子  为什么循环计算两次x得到的值    与计算一次 再将得到的值手动赋初值给x  再计算一次  得到的值不一样

输入值为 1 3 10 3 4 5时，即1个问题数，项目生产念书为3，投入建设资金为10，每年利润分别为3 4 5.
下面的代码循环计算两次x得到的值为0.093492
但是我如果将循环调成一次得到x的值是0.089060，再把这个值赋初值给x，再算一次，就成了0.088963
为啥  为啥  为啥
为啥 直接循环得不出正确答案？

讲道理 应该是一样的啊！！！为什么 ？C语言初学者 求各位大佬的解答。
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main()
{
    int n,i;int b,j;
    scanf("%d",&n);
    for(j=0;j<n;j++)
    {
        scanf("%d",&b);
        double a[b+1];
        for(i=0;i<b+1;i++)
        {
            scanf("%lf",&a[i]);
        }


    int i,n;double fx=0;double x=0.08;//赋初值给x
    double fx1=0;

      for(n=0;n<2;n++)//运算两次x
        {
       for(i=1;i<b+1;i++)//计算函数值
    {
        fx=fx+a[i]*pow(1.0+x,b-i);
    }
    fx=fx-a[0]*pow(1.0+x,b);

     for(i=1;i<b;i++)//计算函数的导数值
    {
        fx1=fx1+a[i]*(b-i)*pow(1.0+x,b-i-1);
    }
     fx1=fx1-a[0]*pow(1+x,b-1)*b;

       x=x-(fx/fx1);
      }
    printf("%lf\n",x);
    }
    return 0;
}
浮点数格式 http://bbs.csdn.net/topics/390676437
可是为什么 赋初值就可以了呢
设置断点调试一次啊 看那不一样
就是第一次循环结束时的x值时对的，，但是当这个x值进入第二次循环的时候，得出的就不对了。。
然而把第一次循环得到的x值手动赋值给x，得到的是正确的。。。可以理解为电脑自动循环时得到的是错的。。。人工手动一次次计算。。是对的。。。。
引用 4 楼 qq_34636559 的回复:就是第一次循环结束时的x值时对的，，但是当这个x值进入第二次循环的时候，得出的就不对了。。
然而把第一次循环得到的x值手动赋值给x，得到的是正确的。。。可以理解为电脑自动循环时得到的是错的。。。人工手动一次次计算。。是对的。。。。
不一样，因为精度问题，因为浮点类型的精度是最多能有7位有效数字，但绝对能保证的为6位，如果超过这个数据进行运算后，会自动进行省略小数点后的位数，所以导致第二遍循环的不准确。
那有没有什么办法解决呢
引用 6 楼 qq_34636559 的回复:那有没有什么办法解决呢
你所说的赋值是不是再把这行代码再执行一边呀？  int i,n;double fx=0;double x=0.08;//赋初值给x
除了x的值变化其他的不变么？
对 其他的不变  只把第一次得到的x值 替代原来的0.08   这样可以的得到正确答案
但是直接用for 就不行了
引用 10 楼 qq_34636559 的回复:但是直接用for 就不行了
你看看

那是你程序的问题，你看看fx的值运行中不是也发生变化了么，把fx=0和fx1=0初始化放在循环中你再试试，结果就一样了
好像是的  谢谢啦  看来以后要多注意。


vs2015 调试程序出现无法解析的外部符号问题1>------ 已启动生成: 项目: anubis, 配置: Debug Win32 ------
1>  gnut-anubis.cpp
1>gnut-anubis.obj : error LNK2019: 无法解析的外部符号 "public: __thiscall gnut::t_gmutex::t_gmutex(void)" (??0t_gmutex@gnut@@QAE@XZ)，该符号在函数 "void __cdecl gnut::`dynamic initializer for '_gmutex''(void)" (??__E_gmutex@gnut@@YAXXZ) 中被引用

1>gnut-anubis.obj : error LNK2019: 无法解析的外部符号 "public: __thiscall gnut::t_gmutex::~t_gmutex(void)" (??1t_gmutex@gnut@@QAE@XZ)，该符号在函数 "void __cdecl gnut::`dynamic atexit destructor for '_gmutex''(void)" (??__F_gmutex@gnut@@YAXXZ) 中被引用

1>gnut-anubis.obj : error LNK2019: 无法解析的外部符号 "public: __thiscall gnut::t_gtime::t_gtime(enum gnut::t_gtime::t_tsys const &)" (??0t_gtime@gnut@@QAE@ABW4t_tsys@01@@Z)，该符号在函数 _main 中被引用

1>gnut-anubis.obj : error LNK2019: 无法解析的外部符号 "public: __thiscall gnut::t_gtime::~t_gtime(void)" (??1t_gtime@gnut@@QAE@XZ)，该符号在函数 _main 中被引用


请问 这是怎么回事，有大神知道怎么修改吗？
声明了函数，未实现，有可能是这个问题，楼主检查一下！
查一下文件是否加载到工程中
无法解析的外部符号都是只有函数声明而找不到函数的实现，检查：
1.是不是声明了函数，而没有实现函数
2.函数声明是不是和函数实现一致（比如拼写，大小写，参数之类的）
3.外部导入的库检查附加库目录和附加依赖项
链接器链接时找不到XXX函数的具体实现，如果这个函数不是自己实现的函数，通常需要将依赖的库文件添加到项目设置中。 
具体位置在：项目属性——链接器——输入——附加依赖项
项目、属性、链接器、常规、附加库目录：填写附加依赖库所在目录 分号间隔多项
项目、属性、链接器、输入、附加依赖项：填写附加依赖库的名字.lib 空格或分号间隔多项
噢 又是一波骚操作


112.exe 中的 0x7549845d 处有未经处理的异常: Microsoft C++ 异常: 内存位置 0x0026f898 处的 cv::Except编程环境是vs2010+opencv2.49
新手上路，第一个程序就这样是怎么回事，恳请各位老师能指点迷津，谢谢
将文件路径中的所有/替换为\\
应该是环境配置的问题，重新配置了一遍opencv后没有问题了！


【C语言】Strtod精度问题C语言
strtod

                  用strtod时，同样的有效数字，只要夹杂了小数点精度就会下降。请问怎么解决？
比如下面第一部分所有的有效数字都在小数点以后，正常输出。
第二部分，所有有效数字都在小数点以前，正常输出。

但是

最后一部分，小数点卡在中间的时候输出就有偏差，请问这是为什么，怎么解决？
谢谢！


输入：

t1=strtod("0.123456789")
printf("(double)nomi=%030.15f")

输出：
(double)nomi= 000000000000000.1234567890000



输入：

t1=strtod("123456789")
printf("(double)nomi=%030.15f")

输出：
(double)nomi= 0000123456789.000000000000000



输入：

t1=strtod("12345.6789")
printf("(double)nomi=%030.15f")

输出：
(double)nomi= 00000000012345.678900000000795
浮点数格式 http://bbs.csdn.net/topics/390676437
#include <stdio.h>      /* printf, NULL */
#include <stdlib.h>     /* strtod */

int main()
{
    char sz[] = "12345.6789";
    char* pEnd;

    double t1 = strtod(sz, &pEnd);
    printf("%f", t1);
    return 0;
}
/* output
12345.678900
*/

好像没什么问题吧
引用 2 楼 hongwenjun 的回复:#include <stdio.h>      /* printf, NULL */
#include <stdlib.h>     /* strtod */

int main()
{
    char sz[] = "12345.6789";
    char* pEnd;

    double t1 = strtod(sz, &pEnd);
    printf("%f", t1);
    return 0;
}
/* output
12345.678900
*/

好像没什么问题吧
double类型的数据应该用%lf输出，使用%f输出会影响其精度
没有办法吧，这是浮点数的存储方式决定的。但是你可以从业务的实际出发来想办法，比如涉及金额的用分或厘做单位，以整数进行计算。
很多十进制的浮点数是无法用二进制精确表示的
引用 2 楼 hongwenjun 的回复:#include <stdio.h>      /* printf, NULL */
#include <stdlib.h>     /* strtod */

int main()
{
    char sz[] = "12345.6789";
    char* pEnd;

    double t1 = strtod(sz, &pEnd);
    printf("%f", t1);
    return 0;
}
/* output
12345.678900
*/

好像没什么问题吧

默认的6位是没什么问题，目前要用精确到20位左右，
把你的%f变成%30.20f试一下，看看后面都是0吗。
引用 1 楼 zhao4zhong1 的回复:浮点数格式 http://bbs.csdn.net/topics/390676437
受教。多谢！
用unsigned char数组来存储？这样就不会出现精度问题了....
引用 8 楼 iloveyou418 的回复:用unsigned char数组来存储？这样就不会出现精度问题了....
说的对，我就是用char来做保存的。
现在要用char保存的数据要把它变成double带入计算。。
char好像不能直接乘除吧。。
引用 9 楼 zxzr1990 的回复:Quote: 引用 8 楼 iloveyou418 的回复:
用unsigned char数组来存储？这样就不会出现精度问题了....
说的对，我就是用char来做保存的。
现在要用char保存的数据要把它变成double带入计算。。
char好像不能直接乘除吧。。
double 的精度就是如此，16位有效数字
个人觉得这个跟二进制表示浮点数的方法有关系。正如前面有朋友所说的“很多十进制的浮点数是无法用二进制精确表示的”。如果把代码改为

char* stopstring;
double t1 = strtod("12345.0625", &stopstring);
printf("%030.15f", t1);

此时的输出即为00000000000010.062500000000000
因为此时的小数部分0,0625是能够正好被二进制精确表示的。但是如果改为12345.6789，此时小数部分0.6789不能被二进制精确表示，所以就会出现小数部分不相同的情况。
引用 7 楼 zxzr1990 的回复:Quote: 引用 1 楼 zhao4zhong1 的回复:
浮点数格式 http://bbs.csdn.net/topics/390676437
受教。多谢！
引用 9 楼 zxzr1990 的回复:Quote: 引用 8 楼 iloveyou418 的回复:
用unsigned char数组来存储？这样就不会出现精度问题了....
说的对，我就是用char来做保存的。
现在要用char保存的数据要把它变成double带入计算。。
char好像不能直接乘除吧。。
我一般处理都是假装小数点不存在，先进行数据处理，最后再把小数点补上。。。
引用 13 楼 iloveyou418 的回复:Quote: 引用 9 楼 zxzr1990 的回复:
Quote: 引用 8 楼 iloveyou418 的回复:
用unsigned char数组来存储？这样就不会出现精度问题了....
说的对，我就是用char来做保存的。
现在要用char保存的数据要把它变成double带入计算。。
char好像不能直接乘除吧。。
我一般处理都是假装小数点不存在，先进行数据处理，最后再把小数点补上。。。

还需要一个专门数小数点的函数？
引用 14 楼 zxzr1990 的回复:Quote: 引用 13 楼 iloveyou418 的回复:
Quote: 引用 9 楼 zxzr1990 的回复:
Quote: 引用 8 楼 iloveyou418 的回复:
用unsigned char数组来存储？这样就不会出现精度问题了....
说的对，我就是用char来做保存的。
现在要用char保存的数据要把它变成double带入计算。。
char好像不能直接乘除吧。。
我一般处理都是假装小数点不存在，先进行数据处理，最后再把小数点补上。。。

还需要一个专门数小数点的函数？
char数组直接判断'.'，Cstring直接find。。。我都是如此偷懒


初学者，刚接触C，该怎么玩转C，以及各大问题讲解，找师傅看了视频，前三集虚拟机，看的我一脸懵逼，有没有便捷方法？
随便下个c编译器
vc 6.0   vs  什么的
都可以写c程序
可是执行gcc说需要QT那个啥的啊
可否说一下，学的什么C，再用虚拟机？这个我想了解一下
虚拟机跑 linux?
建议你去看看51自学网的视频，虽然是自学的，不过还是挺管用，比你一头雾水好得多
楼主，课程的网址是多少？
http://blog.csdn.net/lijun5635/article/details/8632363
看书
　　/  \
   /    \
练习——理解


C Primer Plus 
C语言程序设计：现代方法：第2版(被誉为"近10年来最好的一部C语言著作")
C和指针
或者谭浩强《C程序设计》
以上任选一本就差不多了，以下为参考书：
《深入理解C指针》
《C语言点滴》
《C陷阱与缺陷》
《C专家编程》
《C语言课程设计案例精编》
C语言程序开发范例宝典
C语言经典编程282例
引用 1 楼 qq_38204686 的回复:随便下个c编译器
vc 6.0   vs  什么的
都可以写c程序
建议下个最新的软件，编译器尽量用最新的。
随便下个编译器，建议根据自己学习方向（windows和Linux）来选择对应的编辑和编译器；
如果只是看而不动手写（哪怕抄别人的代码）是没用的，编程主要在动脑设计和动手实现；只是看，我看是没用的。
C语言教程（附带C语言100例）http://download.csdn.net/detail/zhao4zhong1/8830817
计算机组成原理→DOS命令→汇编语言→C语言（不包括C++）、代码书写规范→数据结构、编译原理、操作系统→计算机网络、数据库原理、正则表达式→其它语言（包括C++）、架构……

对学习编程者的忠告：
多用小脑和手，少用大脑、眼睛和嘴，会更快地学会编程！
眼过千遍不如手过一遍！
书看千行不如手敲一行！
手敲千行不如单步一行！
单步源代码千行不如单步Debug版对应汇编一行！
单步Debug版对应汇编千行不如单步Release版对应汇编一行！
不会单步Release版对应汇编？在你想单步Release版C/C++代码片断的前面临时加一句DebugBreak();重建所有，然后在IDE中运行。（一般人我不告诉他！）

VC调试时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
对VC来说，所谓‘调试时’就是编译连接通过以后，按F10或F11键单步执行一步以后的时候，或者在某行按F9设了断点后按F5执行停在该断点处的时候。


vs2012友元函数无法访问私有变量友元  C++
友元
C++

//#include "stdafx.h"
#include <iostream>
#include <cmath>
#include <iomanip>
#include <string>
//#include "Student.h"
//#include "cuboid.h"

using namespace std;
class Date;
class Time
{
public:
	Time(int,int,int);
	void display(Date &);
private:
	int hour;
	int minute;
	int sec;
};
class Date
{
public:
	Date(int,int,int);
	friend void Time::display(Date &);
private:
	int year;
	int month;
	int day;
};
Time::Time(int h,int m,int s)
{
	hour=h;
	minute=m;
	sec=s;
}
void Time::display (Date &d)
{
	cout<<d.year<<" "<<d.month <<" "<<d.day <<endl;
	cout<<hour<<" "<<minute<<" "<<sec<<endl;
}
Date::Date (int y,int m,int d)
{
	year=y;
	month=m;
	day=d;
}

int main()
{
	Time t(15,03,15);
	Date d(2015,11,13);
	t.display(d);
	return 0;
}

这段代码，我在vs2012中总是显示无法访问私有变量

但是我在vc++6.0下可以正常运行，不会提示无法访问的问题。
求指点
Data类中加上friend class Time;
简而言之，别信 IntelliSense。
楼上正解，编译器的差异
引用 1 楼 paschen 的回复:Data类中加上friend class Time;恩，声明为友元类确实可以，但是我想知道友元函数为什么为出错
引用 4 楼 earlyAutumnOfRain 的回复:Quote: 引用 1 楼 paschen 的回复:
Data类中加上friend class Time;恩，声明为友元类确实可以，但是我想知道友元函数为什么为出错

编译器 bug 。换  VS2015 吧。
引用 4 楼 earlyAutumnOfRain 的回复:Quote: 引用 1 楼 paschen 的回复:
Data类中加上friend class Time;恩，声明为友元类确实可以，但是我想知道友元函数为什么为出错

估计IntelliSense问题，可以通过编译
引用 5 楼 fefe82 的回复:Quote: 引用 4 楼 earlyAutumnOfRain 的回复:
Quote: 引用 1 楼 paschen 的回复:
Data类中加上friend class Time;恩，声明为友元类确实可以，但是我想知道友元函数为什么为出错

编译器 bug 。换  VS2015 吧。

VS2015一样会在下面有红线，但不影响编译
今天我也遇到这个问题啦！生成解决方案的时候一直报错，然而点击运行居然是没问题的！惊了~


关于陈硕书籍《服务端编程》为什么要将++it向前挪动muduo网络库
多线程
C++
Linux
设计模式

                  先贴代码，位置为第16页，小弟实在不理解为什么为什么特意去移动++it的位置。
如果有明白的朋友麻烦告诉一下这样做的理由。
这不是个循环遍历吗？   如果无++， while循环有可能无法结束。
引用 1 楼 hefashion0190 的回复:这不是个循环遍历吗？   如果无++， while循环有可能无法结束。
不是没有++，而是++从后面挪动到了前面，我想知道这么做具体有什么意义。
循环都没搞懂就去看服务端编程，无语。
STL标准库迭带器。。。
引用 3 楼 sdghchj 的回复:循环都没搞懂就去看服务端编程，无语。
STL标准库迭带器。。。
我知道这是个迭代器啊，我也知道list是双向链表实现的，关键把++it往前挪动一行到底有什么意义啊。
是在迭代器失效前进行++操作吗？但已经换成了list，即使++在update函数后面也应该没有影响才对啊。
引用 4 楼 dante502 的回复:Quote: 引用 3 楼 sdghchj 的回复:
循环都没搞懂就去看服务端编程，无语。
STL标准库迭带器。。。
我知道这是个迭代器啊，我也知道list是双向链表实现的，关键把++it往前挪动一行到底有什么意义啊。
是在迭代器失效前进行++操作吗？但已经换成了list，即使++在update函数后面也应该没有影响才对啊。

说的很明白了， 不++的话， while是死循环  死循环  死循环
引用 1 楼 hefashion0190 的回复:这不是个循环遍历吗？   如果无++， while循环有可能无法结束。

else中erase函数的返回值更新了it， 不需要在++
所以++it放在了if中

你是问这个吗？
sorry 没看明白问题

不懂帮顶
引用 4 楼 dante502 的回复:Quote: 引用 3 楼 sdghchj 的回复:
循环都没搞懂就去看服务端编程，无语。
STL标准库迭带器。。。
我知道这是个迭代器啊，我也知道list是双向链表实现的，关键把++it往前挪动一行到底有什么意义啊。
是在迭代器失效前进行++操作吗？但已经换成了list，即使++在update函数后面也应该没有影响才对啊。

这本书讲的东西也不是100%对的。
这里vector换list并没有解决本身问题，纯粹就是换了个容器，作者以为update函数里调用unregister对observers_进行了某个元素的erase或者修改会导致外部迭带器it的失效，所以在失效前赶紧先++it让它指向下一个元素，而其实现在vector的实现算法中删除和修改并不会导致已有迭带器的失效问题，因为vector内部数据是连续存储的堆内存，只有push_back增加元素时因已有堆内存不够需要重新申请才可能导致已有迭带器无效。除非update里对observers_进行了元素增加。
所以只有可能erase最后一个元素后再++it导致的越界问题，而这个问题，不是靠什么换成list以及++it提前一行所能解决的。
//以下代码只会删除第一个2，第二个2被++it跳过删除。
    std::vector<int> v{1,2,2,3,4,5,6,7,8};
    auto it = v.begin();
    while(it != v.end()){
        if(*it == 2){
            v.erase(it);
        }
        ++ it;
    }

    for(auto it:v){
        std::cout<<it <<" ";    //结果 1 2 3 4 5 6 7 8
    }




    //删除8之后，it已经指向了v的end,再++it就越界了。
    std::vector<int> v{1,2,2,3,4,5,6,7,8};
    auto it = v.begin();
    while(it != v.end()){
        if(*it == 8){
            v.erase(it);
        }
        ++ it;
    }
引用 8 楼 sdghchj 的回复:Quote: 引用 4 楼 dante502 的回复:
Quote: 引用 3 楼 sdghchj 的回复:
循环都没搞懂就去看服务端编程，无语。
STL标准库迭带器。。。
我知道这是个迭代器啊，我也知道list是双向链表实现的，关键把++it往前挪动一行到底有什么意义啊。
是在迭代器失效前进行++操作吗？但已经换成了list，即使++在update函数后面也应该没有影响才对啊。

这本书讲的东西也不是100%对的。
这里vector换list并没有解决本身问题，纯粹就是换了个容器，作者以为update函数里调用unregister对observers_进行了某个元素的erase或者修改会导致外部迭带器it的失效，所以在失效前赶紧先++it让它指向下一个元素，而其实现在vector的实现算法中删除和修改并不会导致已有迭带器的失效问题，因为vector内部数据是连续存储的堆内存，只有push_back增加元素时因已有堆内存不够需要重新申请才可能导致已有迭带器无效。除非update里对observers_进行了元素增加。
所以只有可能erase最后一个元素后再++it导致的越界问题，而这个问题，不是靠什么换成list以及++it提前一行所能解决的。


萌新的一点关于全局变量和局部变量的小问题C++

                  #include<iostream.h>
void main()
{
	int a=0;
	int b=0;
	a++;
	b++;
	cout<<"a="<<a<<"，"<<"b="<<b<<endl;
	{
		float a=0.5;
		a++;
		b++;
		cout<<"a="<<a<<"，"<<"b="<<b<<endl;
	}
	a++;
	b++;
	cout<<"a="<<a<<"，"<<"b="<<b<<endl;
}
main函数里面可以有全局变量吗？里面的括号中将a定义成了单精度浮点型，后面的a的值就为0.5，而b没有定义，就用前面的b的值，那float a未局部变量，int a和int b为全局变量，是这样吗？如果不是，那为什么第二个括号内可以用括号外的b
全局变量 局部变量
其实只要搞清楚变量的作用域就好了
编译器 会以就近原则处理同名问题
#include<iostream.h>
void main()
{
    int a=0;
    int b=0;
    a++;
    b++;
    cout<<"a="<<a<<"，"<<"b="<<b<<endl;
    {
        float a=0.5;
        a++;
        b++;
        cout<<"a="<<a<<"，"<<"b="<<b<<endl;
    }
    a++;
    b++;
    cout<<"a="<<a<<"，"<<"b="<<b<<endl;
}
这个程序里没有一个全局变量，都是局部变量。
  int a=0;
    int b=0;
这里定义的a, b生命周期是main函数从开始到结束，其作用域是整个main函数；

{
        float a=0.5;
        a++;
        b++;
        cout<<"a="<<a<<"，"<<"b="<<b<<endl;
    }
这里定义的a生命周期是大括号内，并且大括号内定义的float类型的a会屏蔽开始定义的int类型的a；并且float类型的a在括号外是无效，即大括号外还是int类型的a；
大括号里的b是外部定义的int类型的b；

每个变量都会有自己的作用域和生命周期；可以从这两个方面来理解局部变量和全局变量的区别；


opengl动画问题求助opengl

                  要做的是一个流水线，方块到第一个机床变色，第二个机床变形状，第三个机床加盖子。
然后现在用定时器做动画，第一条第二条是正常运行的，第三条和第四条流水线运动就非常奇怪，不知道该怎么修改，感觉好像是受到了前两条流水线下movex,movez函数的影响？
希望有大佬能帮忙，万分感谢
#include<Windows.h>
#include"head.h"

static float shoulder = 0, elbow1 = 0, elbow2 = 0,movex=0.2,movez=5,movey=2.0,t=0;

void init(void)
{
	GLfloat mau[] = { 1.0,1.0,0.5,1.0 };
	GLfloat mcu[] = { 50.0 };
	GLfloat light_position[] = { 1.0,1.0,1.0,2.0 };//光照位置
	GLfloat white_light[] = { 1.0,1.0,1.0,1.0 };
	GLfloat msu[] = { 0.1,0.1,0.1,1.0 };
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glShadeModel(GL_SMOOTH);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mau);
	glMaterialfv(GL_FRONT, GL_SHININESS, mcu);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, white_light);
	glLightfv(GL_LIGHT0, GL_SPECULAR, white_light);
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, msu);
	glEnable(GL_LIGHTING);//启动光照
	glEnable(GL_LIGHT0);//启动第一盏灯的光照
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_COLOR_MATERIAL);
	glEnable(GL_TEXTURE_2D);

}

void display(void)
{
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);
	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
	glColor3f(1.0, 1.0, 1.0);
	glLoadIdentity();
	gluLookAt(3, 10, 10, 10, 0.0, 0.0, 0.0, 1.0, 0.0);
	//机床
	glPushMatrix();
	glTranslatef(0, 1.75, -5);
	glScalef(3, 3, 4);
	glColor3f(5, 1, 0);
	glutSolidCube(1.0);
	glPopMatrix();

	//地面
	glPushMatrix();
	glColor3f(0.0, 0.2, 0.5);
	glTranslatef(2.0, -2.0, 0.0);
	glScalef(50.0, 1.0, 50.0);
	glutSolidCube(1.0);
	glPopMatrix();
	//天花板
	glPushMatrix();
	glColor3f(0.2, 0.2, 0.3);
	glTranslatef(4.0, 17.0, -20.0);
	glScalef(50.0, 1.0, 100.0);
	glutSolidCube(1.0);
	glPopMatrix();
	//可乐瓶
	glPushMatrix();
	if (t == 1.0)//瓶 
	{
		glColor3f(1.0, 1.0, 0.0);
		GLUquadricObj *pobj;
		pobj = gluNewQuadric();
		gluQuadricNormals(pobj, GLU_SMOOTH);
		glTranslatef(movex, 2, movez);
		glPushMatrix();
		glRotatef(90, 1, 0, 0);
		gluCylinder(pobj, 0.5, 0.5, 1.2, 26, 13);
		//gluDisk(pobj,0.0f, 0.5f, 20, 20);
		glPopMatrix();
	}
	if (t == 1.5)//+盖子 
	{
		glColor3f(1.0, 1.0, 0.0);
		GLUquadricObj *pobj;
		pobj = gluNewQuadric();
		gluQuadricNormals(pobj, GLU_SMOOTH);
		glTranslatef(movex, movey, movez);
		glPushMatrix();
		glRotatef(90, 1, 0, 0);
		gluCylinder(pobj, 0.5, 0.5, 1.2, 26, 13);
		gluDisk(pobj, 0.0f, 0.5f, 20, 20);
		glPopMatrix();
		glPushMatrix();
		glTranslatef(0, 0.45, 0);
		glColor3f(1, 0, 0);
		glRotatef(90, 1, 0, 0);
		gluCylinder(pobj, 0.3, 0.3, 0.4, 26, 13);
		gluDisk(pobj, 0.0f, 0.3f, 20, 20);
		glPopMatrix();
	}
	else if (t == 0)//方块 
	{
		glColor3f(1.0, 0.0, 0.0);
		glTranslatef(movex, 1.3, movez);
		glScalef(0.8, 1.2, 0.8);
		glutSolidCube(1.0);
	}
	else if (t == 0.5)//变色方块 
	{
		glColor3f(1.0, 1.0, 0.0);
		glTranslatef(movex, 1.3, movez);
		glScalef(0.8, 1.2, 0.8);
		glutSolidCube(1.0);
	}
	glPopMatrix();
	//机械臂1
	glColor3f(0.5, 2, 2);

	glPushMatrix();
	glTranslatef(-2, 0, 0);
	glRotatef((GLfloat)shoulder, 0, 0, 1);
	glTranslatef(0, 1, 0);
	glPushMatrix();
	glScalef(0.4, 4, 1.0);
	glutSolidCube(1);
	glPopMatrix();
	glTranslatef(0, 2, 0);
	glRotatef((GLfloat)elbow1, 0, 0, 1);
	glTranslatef(1, 0, 0);
	glPushMatrix();
	glScalef(2, 0.4, 1);
	glutSolidCube(1);
	glPopMatrix();

	glPopMatrix();
	//机械臂2

	glPushMatrix();
	glTranslatef(10, 0, 0);
	glRotatef((GLfloat)shoulder, 0, 0, 1);
	glTranslatef(0, 1, 0);
	glPushMatrix();
	glScalef(0.4, 4, 1.0);
	glutSolidCube(1);
	glPopMatrix();
	glTranslatef(0, 2, 0);
	glRotatef((GLfloat)elbow2, 0, 0, 1);
	glTranslatef(1, 0, 0);
	glPushMatrix();
	glScalef(2, 0.4, 1);
	glutSolidCube(1);
	glPopMatrix();

	glPopMatrix();
	//传输带 
	glColor3f(1.0, 1.0, 1.0);
	glScalef(1.2, 1.5, 12);
	glutSolidCube(1.0);

	glPushMatrix();
	glTranslatef(10.0, 0.0, 0.0);
	glScalef(1.0, 1.0, 1.0);
	glutSolidCube(1.0);
	glPopMatrix();

	glPushMatrix();
	glTranslatef(5.0, 0.0, -0.5);
	glScalef(11.0, 1.0, 0.2);
	glutSolidCube(1.0);
	glPopMatrix();

	glPushMatrix();
	glTranslatef(15.0, 0.0, 0.5);
	glScalef(11, 1.0, 0.1);
	glutSolidCube(1.0);
	glPopMatrix();




	glutSwapBuffers();

	//glFlush();

}
//机械臂控制动画 
void down1(void)
{

	if (elbow1> -30)
		elbow1 = elbow1 - 0.02;
	glutPostRedisplay();
}
void up1(void)
{
	if (elbow1<0)
		elbow1 = elbow1 + 0.02;
	glutPostRedisplay();
}
void down2(void)
{

	if (elbow2> -30)
		elbow2 = elbow2 - 0.02;
	glutPostRedisplay();
}
void up2(void)
{
	if (elbow2<0)
		elbow2 = elbow2 + 0.02;
	glutPostRedisplay();
}

//传送带控制动画
void move(int id)
{
	if (movez >= 0.05)
		movez -=0.03;
	glutPostRedisplay();
	glutTimerFunc(10, move, 0);
}

void move2(int id)
{
	if (movez > -6)
	{
		t = 0.5;
		movez -= 0.03;
	}
	glutPostRedisplay();
	glutTimerFunc(10, move2, 2);
}

void move3(int id)
{
	if (movex < 12)
	{
		t = 1;
		movex = movex + 0.03;
	}
	glutPostRedisplay();
	glutTimerFunc(10, move3, 3);
}

void move4(int id)
{
	if (movez<0.1)
		movez = movez + 0.03;
	glutPostRedisplay();
	glutTimerFunc(10, move4, 4);
}

void move5(int id)
{
	if (movez<6)
		movez = movez + 0.03;
	glutPostRedisplay();
	glutTimerFunc(10, move5, 6);
}

void move6(int id)
{
	if (movex < 25)
		movex = movex + 0.03;
	else if (movey > -1)
		movey = movey - 0.1;
	glutPostRedisplay();
	glutTimerFunc(10, move6, 7);
}

void keyboard(unsigned char key, int x, int y)
{
	switch (key) {
	case'q':
		glutIdleFunc(up1);
		break;
	case'a':
		glutIdleFunc(down1);
		break;
	case'e':
		glutIdleFunc(up2);
		break;
	case'd':
		glutIdleFunc(down2);
		break;
	case's':
	{
		glutTimerFunc(0, move, 0);
		glutTimerFunc(3000, move2, 2);
		glutTimerFunc(5000, move3, 3);
		glutTimerFunc(80000, move4, 4);
		glutTimerFunc(8000, move5, 6);
		glutTimerFunc(145000, move6, 7); 
	}
	break;
	}
}

	void reshape(int width, int height)
		{
		glViewport(0, 0, width, height);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		gluPerspective(120, (GLfloat)width / (GLfloat)height, 1.0f, 25.0f);//建立一个透视投影视图体，格式为：gluPerspective(视域的角度，宽高比，视点到近裁剪面的距离（总为正），视点到远裁剪面的距离（总为正））
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		}

	int main(int argc, char* argv[])
		{
		glutInit(&argc, argv);
		glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
		glutInitWindowPosition(50, 50);
		glutInitWindowSize(800, 800);
		glutCreateWindow("Cola Factory");
		init();
		glutDisplayFunc(&display);
		glutKeyboardFunc(&keyboard);
		glutReshapeFunc(&reshape);
		glutMainLoop();
		return 0;
		}
void move(int id)
{
    if (movez >= 0.05)
    {
        movez -=0.03;
        glutPostRedisplay();
        glutTimerFunc(10, move, 0);
    }
}

glutTimerFunc这个函数的执行是有条件的。 
可以先把所有的glutTimerFunc都放入大括号中、至少图形能走到最后。 具体条件你自己再考虑


求教，用c语言基于VISA驱动，实现安捷伦和usb设备通讯采集数据本帖最后由 delylin 于 2016-05-16 20:37:32 编辑

c++，visa，通讯，采集数据

                  用c语言编写采集软件基于VISA驱动，实现和usb设备通讯采集数据的功能。
 问题来源：之前用的是安捷伦34970a采集数据，C++编写的采集软件，采用安捷伦提供的rs232通讯接口代码，可以正常采集数据；由于设备更新换成安捷伦34792a的采集仪， 坑爹的没有rs232通讯功能，只有报警功能，只能使用usb和电脑连接，需要修改代码，求高手帮忙？问了好多人，都不了解visa。
我就贴出一段安捷伦提供的rs232 的open_port这段代码，全码我放网盘里地址：http://pan.baidu.com/s/1miguXOs
USB的地址：USB0::0x3923::0x12C0::00B50DAE::INSTR

 void open_port()
//************************************************************************************
// This function opens a port (the communication between the instrument and computer). 
// Be sure that the GPIB address has been set in the 'GPIBAddr' variable before 
// calling this routine.
//************************************************************************************
{
	long	start,finish;
	char	ch;

	// Open the Visa session
	errorStatus = viOpenDefaultRM(&videfaultRM);

	// Open communication to the instrument
	errorStatus = viOpen(videfaultRM, "ASRL1::INSTR", VI_TRUE, VI_TRUE, &vi);
	// If an error occurs, give a message
	if (errorStatus < VI_SUCCESS)
	{
		printf("Unable to Open port; check address.\nPress any key to exit.");
		scanf("%c", &ch);
		exit(1);
	}

	// Set the RS-232 parameters; refer to the 34970A and VISA documentation
	// to change the settings. Make sure the instrument and the following
	// settings agree.
	errorStatus = viSetAttribute(vi, VI_ATTR_ASRL_BAUD, 115200);
	errorStatus = viSetAttribute(vi, VI_ATTR_ASRL_DATA_BITS, 8);
	errorStatus = viSetAttribute(vi, VI_ATTR_ASRL_PARITY, VI_ASRL_PAR_NONE);
	errorStatus = viSetAttribute(vi, VI_ATTR_ASRL_STOP_BITS, VI_ASRL_STOP_ONE);
	errorStatus = viSetAttribute(vi, VI_ATTR_ASRL_FLOW_CNTRL, VI_ASRL_FLOW_XON_XOFF);

	// Set the instrument to remote
	send_cmd ("SYSTem:REMote");

	// Wait 1 second
	time(&start);
	finish=start + 1;
	do
	{
		time(&start);
	} while (start < finish); 

}
请问实现了吗？求教


C语言的一个问题  菜鸟求助如图
练习5.5
这是我写的语句
#include<stdio.h>

int main()
{
	size_t c=0;
	size_t max=0;
	size_t n=0;
	size_t s=0;
	printf("enter the amounts of classes:");
	scanf("%zd",&c);
	n=c;
	s=c;
    printf("How many students are in the largest class? :");
    scanf("%zd", &max);
    float grades[c][max];
    size_t num[n];
	float sum[s];
   
    size_t i=0;
	size_t j=0;
	for(;i<c;i++)
	{
		printf("\nenter the number of students in class %zd:",i+1);
		scanf("%zd",&num[i]);
		printf("\nenter the grades of students in class %zd.\n",i+1);
	    for(;j<num[i];j++)
		{
             grades[i][j]=0;
	         scanf("%f",&grades[i][j]);
             sum[i]+=grades[i][j];
	    }
    } 
    
    size_t k=0;
	size_t l=0;
	for(;k<c;k++)
	{
		printf("\nstudent grades of class %zd are:\n",k+ 1);
        for(;l<num[k];l++)
		{
			if(grades[k][l]!=0.0)
              printf("%.1f\t",grades[k][l]);
            else
              break;
		}
        printf("\naverage grade of class %zd is %.1lf\n",k+1,sum[k]/(double)num[k]);
	}

	return 0;
}
但运行的结果是这样的

高手能指出错误么
单步调试
#include<stdio.h>

int main()
{
    size_t c=0;
    size_t max=0;
    size_t n=0;
    size_t s=0;
    printf("enter the amounts of classes:");
    scanf("%zd",&c);
    n=c;
    s=c;
    printf("How many students are in the largest class? :");
    scanf("%zd", &max);
    float grades[c][max];
    size_t num[n];
    float sum[s];

    size_t i=0;
    size_t j=0;
    for(i = 0; i < c; i++)
    {
        printf("\nenter the number of students in class %zd:",i+1);
        scanf("%zd",&num[i]);
        printf("\nenter the grades of students in class %zd.\n",i+1);
        for(j = 0; j < num[i]; j++)
        {
            grades[i][j]=0;
            scanf("%f",&grades[i][j]);
            sum[i]+=grades[i][j];
        }
    }

    for(i = 0; i < c; i++)
    {
        printf("\nstudent grades of class %zd are:\n",i + 1);
        for(j = 0; j < num[i]; j++)
        {
            if(grades[i][j]!=0.0)
                printf("%.1f\t",grades[i][j]);
            else
                break;
        }
        printf("\naverage grade of class %zd is %.1lf\n", i + 1, sum[i]/(double)num[i]);
    }

    return 0;
}
参考一下吧；
问题主要出在
 for(j = 0; j < num[i]; j++)
在第二个班级时，j不能从0开始，即从第二次循环开始，j还是从0开始；
程序还有一个问题，定义的变量太多，n, s没必要定义，直接用c就可以了。
i, j可以再次利用，所以k, l没必要定义；
为什么说没必要定义呢，为了程序的可读性。变量定义多了，会使程序臃肿，简洁的代码可以提高代码的可读性，也可以让代码理解起来更好；
当然代码的可读性，易于阅读性还需要其他方面一起配合才行，比如变量名的定义


Qt编程的关于自定义QListWidgetItem的问题qt
编程
c++

                  问题描述：添加item时，添加一个自定义的设计师类Qwidget，并设置其内容，但是每次添加都会把前面已经添加的内容都改变，刚接触QT，求指导啊！
问题解决了么？


位数组  c和指针 第5章 第5道题c和指针

                  大神给我讲解一下这个  mask是怎么生成的 
也就是这个行代码的意思是什么
mask = (unsigned)(-1);   //把～0强制转换为无符号值?????????
//      printf("%ld\n",mask);
        mask >>= INT_BITS - (starting_bit-ending_bit+1);
        mask <<= ending_bit;
以下是源代码
#include <stdio.h>
#include <limits.h>
#define  INT_BITS     ( CHAR_BIT * sizeof( int ) )

int store_bit_field( int original_value, int value_to_store, unsigned starting_bit, unsigned ending_bit )
{
    unsigned mask;
/*
** Validate the bit parameters. If an error is found, do nothing.
** is not great error handling.
*/
    if( starting_bit < INT_BITS && ending_bit < INT_BITS &&starting_bit >= ending_bit ){
/*
** Construct the mask, which is unsigned to ensure that we get a
** logical, not arithmetic shift.
*/
//      printf("%ld\n",mask);
        mask = (unsigned)(-1);   //把～0强制转换为无符号值?????????
//      printf("%ld\n",mask);
        mask >>= INT_BITS - (starting_bit-ending_bit+1);
        mask <<= ending_bit;
/*
** Clear the field in the original value.
*/
        original_value &= ~mask;
/*
** Shift the value to store to the right position
*/
        value_to_store <<= ending_bit;
/*
** Mask excess bits off of the value, and store it.
*/
        original_value |= value_to_store & mask;
    }

    return original_value;
}
int main()
{
    printf("%d\n%d\n",INT_BITS,sizeof(int));
    int m=store_bit_field(0xffff,0x123,15,4);
    printf("0x%0x\n",m);
    return 0;
}
-1在内存中的存储方式
原码 反码 补码
大神给我讲解一下这个  mask是怎么生成的 
也就是这个行代码的意思是什么
mask = (unsigned)(-1);   //把～0强制转换为无符号值?????????
//      printf("%ld\n",mask);
        mask >>= INT_BITS - (starting_bit-ending_bit+1);
        mask <<= ending_bit;[code=c][/code]
你好  能具体讲一下这个掩码mask的生成原理吗
 万分感谢
http://edu.csdn.net/course/detail/2344 C语言指针与汇编内存地址-一.代码要素
自己根据位运算方法，在纸上推一下就懂了
#include <stdio.h>

#define WIRTE_UINT(des ,x ,pos ,len)  (                                   \
    (des)                                                                 \
    &                                                                     \
       ~(                                /* 除要修改的位为0，其余都为1 */ \
            (                                                             \
                (1<<(len))-1             /* 长度为len位的1             */ \
            )                                                             \
            <<(32-(pos)-(len))           /* 左移32-(pos)-(len)位       */ \
        )                                                                 \
    |                                                                     \
        (                                                                 \
            (x)                                                           \
            <<(32-(pos)-(len))                                            \
        )                                                                 \
)
#define READ_UINT(src ,pos ,len)      (                                   \
    (                                                                     \
        (                                                                 \
            (unsigned)(src)                                               \
        )                                                                 \
        >>(32-(pos)-(len))               /* 逻辑右移32-(pos)-(len)位   */ \
    )                                                                     \
    &                                                                     \
    (                                                                     \
        (1<<(len))-1                     /* 长度为len位的1             */ \
    )                                                                     \
)

int main()                              //                1111111111222222222233
{                                       //bit   01234567890123456789012345678901
    unsigned int des = 0x661;           //      00000000000000000000011001100001
    unsigned int r;

    des = WIRTE_UINT(des ,3 ,28 ,2);    //      00000000000000000000011001101101
    printf("des==0x%08X\n",des);
	r =	READ_UINT(des ,28 ,2);
    printf("r==%d\n",r);
    return 0;
}
//des==0x0000066D
//r==3
mask = (unsigned)(-1);  //意思是mask的类型能表达的最大的正整数，所有的二进制位都是1
假如mask的类型是32位正整数，那么这样做就是 0xFFFF。
写(unsigned)(-1) 比直接写 0xFFFF更好，因为不同编译器中，unsigned int的长度可能是不同的。
 mask >>= INT_BITS - (starting_bit-ending_bit+1); //这是位操作，右移
你的例子里有大量的位操作，是可以在纸上一步步演算的。
感谢大家的解答，这是我结合大家的答案，和我的理解 ，搞清了这个输入到输出的过程：
以下是我的理解  和源代码的改动：

MASK1 4294967295
MASK2 4095
MASK3 65520
originl_value1 65535
originl_value2 15
value_to_store1 4656
0x123f
#include <stdio.h>
#include <limits.h>
#define  INT_BITS     ( CHAR_BIT * sizeof( int ) )

int store_bit_field( int original_value, int value_to_store, unsigned starting_bit, unsigned ending_bit )
{
    unsigned mask;

    if( starting_bit < INT_BITS && ending_bit < INT_BITS &&starting_bit >= ending_bit ){

//      printf("%32d\n",INT_BITS);
//      printf("%ld\n",mask);
        mask = (unsigned)(-1);   //把～0强制转换为无符号值?????????
        printf("MASK1 %ld\n",mask);
        mask >>= INT_BITS - (starting_bit-ending_bit+1);
        printf("MASK2 %ld\n",mask);
        mask <<= ending_bit;
        printf("MASK3 %ld\n",mask);

        printf("originl_value1 %ld\n",original_value);                                      //以上为创建MASK
        original_value &= ~mask;
        printf("originl_value2 %ld\n",original_value);
        value_to_store <<= ending_bit;
        printf("value_to_store1 %ld\n",value_to_store);
        original_value |= value_to_store & mask;
        
    }

    return original_value;
}
int main()
{
    printf("%d\n%d\n",INT_BITS,sizeof(int));
    int m=store_bit_field(0xffff,0x123,15,4);
    printf("0x%0x\n",m);
    return 0;
}


新人基础问题c++

                  #include<iostream>
using namespace std;
class Teacher
{
public:
 Teacher();
 Teacher(int i)
 { m_zhichen=i;
 }
protected:
int m_zhichen;
};
class Level
{
public:
 Level();
 Level(int j)
 { m_zhiwei=j;}
protected:
int m_zhiwei;
};
class Teacher_Level:public Teacher,Level
{
public:
Teacher_Level();
Teacher_level(int a,int b,int gongzi):Teacher( a),Level( b)
{m_gongzi=gongzi;
}
show()
{
cout<< "职称是:"<<m_zhichen<<endl;
cout<<"职位是:"<<m_zhiwei<<endl:
cout<<"工资是:"<<m_gongzi<<endl:
}
protected:
int m_gongzi;
};
void main()
{
Teacher_Level s(20,30，2000）；
s.show();
}
萌新刚学c++自己看了n遍不知道哪里错了各位高手帮我看看
class Teacher
{
public:
	Teacher() {};
	Teacher(int i)
	{
		m_zhichen = i;
	}
protected:
	int m_zhichen;
};
class Level
{
public:
	Level() {};
	Level(int j)
	{
		m_zhiwei = j;
	}
protected:
	int m_zhiwei;
};
class Teacher_Level :public Teacher, Level
{
public:
	Teacher_Level() {};
	Teacher_Level(int a, int b, int gongzi) :Teacher(a), Level(b)//名称错了
	{
		m_gongzi = gongzi;
	}
	void show()//没有返回值
	{
		cout << "职称是:" << m_zhichen << endl;
		cout << "职位是:" << m_zhiwei << endl:
		cout << "工资是:" << m_gongzi << endl :
	}
protected:
	int m_gongzi;
};
void main()
{
	Teacher_Level s(20, 30, 2000);//用了中文字符
		s.show();
}
注释了的。
最后，建议用VS，报错更加规范
引用 1 楼 codedoctor 的回复:class Teacher
{
public:
	Teacher() {};
	Teacher(int i)
	{
		m_zhichen = i;
	}
protected:
	int m_zhichen;
};
class Level
{
public:
	Level() {};
	Level(int j)
	{
		m_zhiwei = j;
	}
protected:
	int m_zhiwei;
};
class Teacher_Level :public Teacher, Level
{
public:
	Teacher_Level() {};
	Teacher_Level(int a, int b, int gongzi) :Teacher(a), Level(b)//名称错了
	{
		m_gongzi = gongzi;
	}
	void show()//没有返回值
	{
		cout << "职称是:" << m_zhichen << endl;
		cout << "职位是:" << m_zhiwei << endl:
		cout << "工资是:" << m_gongzi << endl :
	}
protected:
	int m_gongzi;
};
void main()
{
	Teacher_Level s(20, 30, 2000);//用了中文字符
		s.show();
}
注释了的。
最后，建议用VS，报错更加规范
这两句之后应该是;分号
cout << "职位是:" << m_zhiwei << endl:
        cout << "工资是:" << m_gongzi << endl :
以下是通过编译和测试过得：

#include<iostream>

using namespace std;
class Teacher
{
    public:
        Teacher();
        Teacher(int i)
        {
            m_zhichen=i;
        }
    protected:
        int m_zhichen;
};
class Level
{
    public:
        Level();
        Level(int j)
        {
            m_zhiwei = j;
        }
    protected:
        int m_zhiwei;
};
class Teacher_Level:public Teacher,Level
{
    public:
        Teacher_Level();
        Teacher_Level(int a,int b,int gongzi):Teacher(a), Level( b) {
            m_gongzi = gongzi;
        }
        void show()
        {
            cout<< "职称是:"<<m_zhichen<<endl;
            cout<<"职位是:"<<m_zhiwei<<endl;
            cout<<"工资是:"<<m_gongzi<<endl;
        }
    protected:
        int m_gongzi;
};

int main()
{
    Teacher_Level s(20,30,2000);
    s.show();
}
平时写代码时，建议注意单词拼写。若是拼写错误，编译器一般会提示错误，建议熟悉编译器的各种提示错误或警告；
引用 2 楼 cfjtaishan 的回复:Quote: 引用 1 楼 codedoctor 的回复:
class Teacher
{
public:
	Teacher() {};
	Teacher(int i)
	{
		m_zhichen = i;
	}
protected:
	int m_zhichen;
};
class Level
{
public:
	Level() {};
	Level(int j)
	{
		m_zhiwei = j;
	}
protected:
	int m_zhiwei;
};
class Teacher_Level :public Teacher, Level
{
public:
	Teacher_Level() {};
	Teacher_Level(int a, int b, int gongzi) :Teacher(a), Level(b)//名称错了
	{
		m_gongzi = gongzi;
	}
	void show()//没有返回值
	{
		cout << "职称是:" << m_zhichen << endl;
		cout << "职位是:" << m_zhiwei << endl:
		cout << "工资是:" << m_gongzi << endl :
	}
protected:
	int m_gongzi;
};
void main()
{
	Teacher_Level s(20, 30, 2000);//用了中文字符
		s.show();
}
注释了的。
最后，建议用VS，报错更加规范
这两句之后应该是;分号
cout << "职位是:" << m_zhiwei << endl:
        cout << "工资是:" << m_gongzi << endl :
以下是通过编译和测试过得：

#include<iostream>

using namespace std;
class Teacher
{
    public:
        Teacher();
        Teacher(int i)
        {
            m_zhichen=i;
        }
    protected:
        int m_zhichen;
};
class Level
{
    public:
        Level();
        Level(int j)
        {
            m_zhiwei = j;
        }
    protected:
        int m_zhiwei;
};
class Teacher_Level:public Teacher,Level
{
    public:
        Teacher_Level();
        Teacher_Level(int a,int b,int gongzi):Teacher(a), Level( b) {
            m_gongzi = gongzi;
        }
        void show()
        {
            cout<< "职称是:"<<m_zhichen<<endl;
            cout<<"职位是:"<<m_zhiwei<<endl;
            cout<<"工资是:"<<m_gongzi<<endl;
        }
    protected:
        int m_gongzi;
};

int main()
{
    Teacher_Level s(20,30,2000);
    s.show();
}

对的，谁能想到，全是这种编译器扫一眼都能看出来的错误，
谢谢各位高手，我以后会注意的谢谢！
引用 4 楼 codedoctor 的回复:Quote: 引用 2 楼 cfjtaishan 的回复:
Quote: 引用 1 楼 codedoctor 的回复:
class Teacher
{
public:
	Teacher() {};
	Teacher(int i)
	{
		m_zhichen = i;
	}
protected:
	int m_zhichen;
};
class Level
{
public:
	Level() {};
	Level(int j)
	{
		m_zhiwei = j;
	}
protected:
	int m_zhiwei;
};
class Teacher_Level :public Teacher, Level
{
public:
	Teacher_Level() {};
	Teacher_Level(int a, int b, int gongzi) :Teacher(a), Level(b)//名称错了
	{
		m_gongzi = gongzi;
	}
	void show()//没有返回值
	{
		cout << "职称是:" << m_zhichen << endl;
		cout << "职位是:" << m_zhiwei << endl:
		cout << "工资是:" << m_gongzi << endl :
	}
protected:
	int m_gongzi;
};
void main()
{
	Teacher_Level s(20, 30, 2000);//用了中文字符
		s.show();
}
注释了的。
最后，建议用VS，报错更加规范
这两句之后应该是;分号
cout << "职位是:" << m_zhiwei << endl:
        cout << "工资是:" << m_gongzi << endl :
以下是通过编译和测试过得：

#include<iostream>

using namespace std;
class Teacher
{
    public:
        Teacher();
        Teacher(int i)
        {
            m_zhichen=i;
        }
    protected:
        int m_zhichen;
};
class Level
{
    public:
        Level();
        Level(int j)
        {
            m_zhiwei = j;
        }
    protected:
        int m_zhiwei;
};
class Teacher_Level:public Teacher,Level
{
    public:
        Teacher_Level();
        Teacher_Level(int a,int b,int gongzi):Teacher(a), Level( b) {
            m_gongzi = gongzi;
        }
        void show()
        {
            cout<< "职称是:"<<m_zhichen<<endl;
            cout<<"职位是:"<<m_zhiwei<<endl;
            cout<<"工资是:"<<m_gongzi<<endl;
        }
    protected:
        int m_gongzi;
};

int main()
{
    Teacher_Level s(20,30,2000);
    s.show();
}

对的，谁能想到，全是这种编译器扫一眼都能看出来的错误，
恩，想不到的语法错误，那就让编译器去想吧


（OSG3.4.0）编译osgShadow项目时，ViewDependentShadowMap编译失败OSG
osgShadow
min
max

                  E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1722): warning C4003: “min”宏的实参不足
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1722): error C2062: 意外的类型“unsigned int”
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1722): error C2334: “:”的前面有意外标记；跳过明显的函数体
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1734): error C2143: 语法错误 : 缺少“)”(在“}”的前面)
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1734): error C2143: 语法错误 : 缺少“}”(在“)”的前面)
在WIN7+VS2012环境下，使用32位平台，编译osgShadow项目时，ViewDependentShadowMap编译失败，提示：
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1734): error C2059: 语法错误:“)”
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1734): error C2143: 语法错误 : 缺少“;”(在“}”的前面)
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1734): error C2238: 意外的标记位于“;”之前
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1736): error C2628: “ConvexHull”后面接“double”是非法的(是否忘记了“;”?)
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1736): warning C4003: “max”宏的实参不足
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1736): error C2143: 语法错误 : 缺少“;”(在“<L_TYPE_raw>”的前面)
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1736): error C2059: 语法错误:“<L_TYPE_raw>”
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1736): error C2059: 语法错误:“)”
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1737): error C2143: 语法错误 : 缺少“;”(在“{”的前面)
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1737): error C2447: “{”: 缺少函数标题(是否是老式的形式表?)
1>E:\osg\OpenSceneGraph-3.4.0\src\osgShadow\ViewDependentShadowMap.cpp(1751): error C2270: “minRatio”: 非成员函数上不允许修饰符
...
问题代码为：
double min(unsigned int index) const
    {
        double m = DBL_MAX;
        for(Edges::const_iterator itr = _edges.begin();
            itr != _edges.end();
            ++itr)
        {
            const Edge& edge = *itr;
            if (edge.first[index]<m) m = edge.first[index];
            if (edge.second[index]<m) m = edge.second[index];
        }
        return m;
    }

    double max(unsigned int index) const
    {
        double m = -DBL_MAX;
        for(Edges::const_iterator itr = _edges.begin();
            itr != _edges.end();
            ++itr)
        {
            const Edge& edge = *itr;
            if (edge.first[index]>m) m = edge.first[index];
            if (edge.second[index]>m) m = edge.second[index];
        }
        return m;
    }
该怎么处理呢，谢谢大家。
偶遇到类似问题都是用
“每次用/*...*/注释掉不同部分再重新编译，直到定位到具体语法出错的位置。”
的方法解决的。
参考另外一个帖子得到了解决方法，使用预处理器来屏蔽min和max：
项目属性 ——> C/C++ ——> 预处理器 ——> 预处理器定义 ——>加入NOMINMAX，
具体见http://blog.csdn.net/wangshubo1989/article/details/50597178。


（OSG3.4.0）编译osgAnimation项目时，MorphGeometry编译失败OSG;
osgAnimation
;MorphGeometry

                  在WIN7+VS2012环境下，使用32位平台，编译osgAnimation项目时，MorphGeometry编译失败，提示：
E:\osg\OpenSceneGraph-3.4.0\include\osgAnimation/MorphGeometry(32): error C2059: 语法错误:“常量”；
E:\osg\OpenSceneGraph-3.4.0\include\osgAnimation/MorphGeometry(32): error C3805: “常量”: 意外标记，应输入“}”或者“,”；
这两处错误对应了Method定义
enum Method {
   NORMALIZED,
   RELATIVE
};
请问该如何处理？谢谢。
偶遇到类似问题都是用
“每次用/*...*/注释掉不同部分再重新编译，直到定位到具体语法出错的位置。”
的方法解决的。
1楼很好的提示，我发现Method中虽然定义了RELATIVE，但后面并没有使用到RELATIVE，于是就把它改为RELATIVE1，编译就通过了，至于后面会不会遇到问题再说了


PCL 安装失败PCL
入门
安装失败

                  下载了个PCL 1.7.2   但安装的时候总是安装到一半就失败 导致在运行的时候少了 libboost_system-vc120-mt-gd-1_55.lib 等多个文件



按确定后会弹出个很诡异的



虽然显示安装完成，但应该是少了很多文件的，这问题怎么解决， 有大神能救活吗·················
自顶(〜￣△￣)〜
顺便一题·····运行程序是报错是这样的
应该是boost缺少库文件吧。提示缺debug版的文件，你试试编译release版的
我也遇到了这个问题，但是在lib文件夹下面确实有动态链接库啊


关于宏的问题宏


&(x)为什么不直接写成 &x
是优先级问题吗？
当x是一个复合表达式的时候呢？
比如：
#define Mul(x)    x*x

Mul(5+1)   //应该等于6*6=36

但 5+1*5+1
加（）是严谨。
不加（）是不好的。
比如说&a+b 与&（a+b） ，真实需要的是a+b 再取地址，而你用第一个的话就走岔了。
因为宏定义展开就是等价替换，若x是一个表达式，就会有问题；

比如
#define MUL(x, y)  (x * y)
MUL(6-2, 8+4)；    /*即: 6-2 * 8 + 4 */
 
MUL(6-2, 8+4)展开就变成(6-2 * 8 + 4)
若加上括号；就变成：
(6-2) * (8+4) 这样就正常了 。
建议用inline函数代替宏
&(x)为什么不直接写成 &x -->当x是个复杂的表达式时，两者是有差别的
学习了，谢谢各位。


C/C++批量处理问题，菜鸟求助C/C++ 批量处理
C/C++
批量处理
文件操作

                  要解决的问题：一个父文件夹下面有多个子文件夹，每个子文件夹里面都是相同数量和相同类型的文件，要把每个子文件夹里面的数据都读出来，然后处理完后再把结果写到该子文件夹里面。我目前已经可以实现一个子文件夹里面的操作，但是不知道怎么去实现批量处理，而且我的程序把文件的路径都固定了，批量处理的话肯定是要修改的，子文件夹的名字是不同的，但是子文件夹里面的文件名字可以相同。求高手指导，谢谢！
父文件夹要做成参数的形式，运行时输入；
子文件夹、文件，都用扫描的方式找出来，再一个个处理就好了。
使用文件搜索的方法搜索，遍历目录
引用 1 楼 hzy_76 的回复:父文件夹要做成参数的形式，运行时输入；
子文件夹、文件，都用扫描的方式找出来，再一个个处理就好了。
请问，能不能说的再详细一些呢？比如会涉及到哪些函数或者类？
引用 2 楼 jack960330 的回复:使用文件搜索的方法搜索，遍历目录
涉及到哪些函数或者类呢？
遍历文件目录，然后依次调用你的处理程序即可，遍历方法网上很多代码
这时候我就建议用python了









个人网站www.qtdoc.cn
dir /S /A /B *.cpp  > list.txt
涉及的函数，要看你的环境了，Windows/Linux/VC？
引用 8 楼 hzy_76 的回复:涉及的函数，要看你的环境了，Windows/Linux/VC？
windows环境。能不能给写个例子啊，比如D盘下面有个文件夹AAA，AAA下面有很多个子文件夹。每个子文件夹里面有相同名字的文件，111.txt  222.txt   333.txt。要依次访问每一个子文件夹里面的txt，并将处理的结果写成txt，放在该子文件夹下面。
可以使用cmd命令， system(...)中调用此命令
FindFirstFile,FindNextFile
我有写过VC的，要晚上才能给你翻翻代码，貌似楼上说的是对的。
system("dir /b /a-d c:\\*.* >d:\\allfiles.txt");
//读文件d:\\allfiles.txt的内容即C:\\下所有文件的名字
system("dir /b /a-d /s c:\\*.* >d:\\allfilesinsub.txt");
//读文件d:\\allfilesinsub.txt的内容即C:\\下所有文件的名字包含子目录
system("dir /b /ad  c:\\*.* >d:\\alldirs.txt");
//读文件d:\\alldirs.txt的内容即C:\\下所有子目录的名字
请记住，能用shell命令获取文件、文件夹信息或者操作文件、文件夹最好用shell命令获取或者操作，而不要用各种API获取或者操作，因为当遇到非法文件夹名或非法文件名或非法文件长度、非法文件日期、压缩文件、链接文件、稀疏文件……等各种意料之外的情况时，API会处理的不全面或陷入死循环，而shell命令不会。
如果嫌system黑窗口一闪，将system("...")替换为WinExec("cmd /c ...",SW_HIDE);
找到一段VC代码，仅供参考：

void CHYXQuantTraderDlg::OnImpStrategyBtn()
{
	TCHAR pszPath[MAX_PATH];
	CString pathAndSuffix;
	CString fileName[MAX_IMP_FILE_NUM];
	int fileNum = 0;
	BROWSEINFO bi;
	bi.hwndOwner = this->GetSafeHwnd();
	bi.pidlRoot = NULL;
	bi.pszDisplayName = NULL;
	bi.lpszTitle = TEXT("请选择策略文件所在目录");
	bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT;
	bi.lpfn = NULL;
	bi.lParam = 0;
	bi.iImage = 0;

	if (!CTPStatus.initFinished)
	{
		AfxMessageBox(_T("系统未初始化完毕，请稍候"));
		return;
	}

	if (addingNewStrategy)
	{
		AfxMessageBox(_T("有新策略未初始化完毕，请稍候"));
		return;
	}

	if (impStrategyDlg.IsWindowVisible())
	{
		DEBUG_LOG("导入窗口已打开");
		return;
	}

	LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
	if (pidl == NULL)
	{
		return;
	}

	if (SHGetPathFromIDList(pidl, pszPath))
	{
		//AfxMessageBox(pszPath);
		CFileFind tempFind;
		//是否成功找到文件
		BOOL bFound;

		pathAndSuffix.Format(_T("%s\\*.sth"), pszPath);	//修改"*.*"可限定查找文件类型
		bFound = tempFind.FindFile(pathAndSuffix);


		//遍历文件，找够100个就中断
		while (bFound && fileNum < MAX_IMP_FILE_NUM)
		{
			//第一次执行FindNextFile是选择第一个文件，以后执行为选择下一个文件
			bFound = tempFind.FindNextFile();

			//如果找到的是返回上层的目录 则结束本次查找
			if (tempFind.IsDots())
				continue;

			if (tempFind.IsDirectory())
			{
				//找到的是文件夹，不处理
			}
			else
			{
				//得到文件名，包括后缀名，存入数组
				fileName[fileNum] = tempFind.GetFileName();
				fileNum ++;
			}
		}

		tempFind.Close();

		//打开导入管理窗口
		impStrategyDlg.SetFileList(pszPath, fileName, fileNum);
		impStrategyDlg.ShowWindow(SW_SHOW);
	}

	return;
}


这段程序是不是哪里越界了？void old(string &s, string &oldVal, string &newVal)
{
	if (s.empty())
		return;
	auto iter = s.begin();
	while (iter != s.end())
	{
		auto iter2 = oldVal.begin();
		auto iter3 = iter;
		while (*iter2 == *iter&&iter2 != oldVal.end())
		{
			++iter2;
			++iter;
		}
		if (iter2 == oldVal.end())
		{
			if (!newVal.empty())
			{
				iter = s.erase(iter3, iter);
				iter = s.insert(iter, newVal.begin(), newVal.end());
				iter += newVal.size() - 1;
			}
		}
		++iter;
	}
}
while (*iter2 == *iter&&iter2 != oldVal.end())
		{
			++iter2;
			++iter;
		}
这里出现问题了，越界了，因为最后一次循环之后，iter2是oldVal.end()，对吧，不能对end()解引用，其实是解引用用错误
后面也有错误，如果iter到了end(),最后大循环那里++end()就会越界，还有第二个while erase()s中元素之后迭代器失效
引用 2 楼 qiangzhenyi1207 的回复:#include<iostream>
#include<string>
using namespace std;
void old(string &s,const string &oldVal,const string &newVal);
int main()
{
	string k = "abcdef tho kk tho";
	old(k, "tho", "though");
	cout << k << endl;
	system("pause");
	return 0;
}
void old(string &s,const string &oldVal,const string &newVal)
{
	if (s.empty())
		return;
	auto iter = s.begin();
	while (iter != s.end())
	{
		auto iter2 = oldVal.begin();
		auto iter3 = iter;
		while (iter2 != oldVal.end()&&iter!=s.end()&&*iter2 == *iter)
		{
			++iter2;
			++iter;
		}
		if (iter2 == oldVal.end())
		{
			if (!newVal.empty())
			{
				iter = s.erase(iter3, iter);
				iter = s.insert(iter, newVal.begin(), newVal.end());
				iter += newVal.size() - 1;
			}
		}
		if (iter == s.end())
			break;
		++iter;
	}
}
大神这样可以吗？还有哪些错误？
是的，越界了，你可以出错了中断下来，看是在哪越界，分析原因是的，越界了，你可以出错了中断下来，看是在哪越界，分析原因
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
上次看错了，我那个第二个回答不用看，你后来这个就对了，另外最后那里if可以去掉。
引用 6 楼 qiangzhenyi1207 的回复:上次看错了，我那个第二个回答不用看，你后来这个就对了，另外最后那里if可以去掉。把最后if删掉的话、如果给的第一个参数字符串最后是t或是th还是会越界。


小萌新求带。请问：vs中while语句和VC中是不是有区别。有代码。。#include<stdio.h>
int main()
{
int n = 0; int m = 0; int x = 0; int y = 0;
	int c;
	while (c != '\n')
	{
		c = getchar();
		if (c >= 'a'&&c <= 'z'||c >= 'a'&&c <= 'z')
			n++;	
	//	else if (c == 32)
		//	m++;
		    else if (c >= 48 && c <= 57)
			x++;
		else
			y++;

	}
		printf("字母 total:%d\n", n);
	//	printf("空格 total:%d\n", m);
		printf("数字 total:%d\n", x);
		printf("其他字符 total:%d\n", y);

	return 0;

}


比如说这个程序，vs报错c4700，但是VC正常运行。
还有个题外话= = ，请问这个程序最后其他字符为啥是1呢，就算不输入除了字母空格数字的其他字符也是1。。奇怪
#include<stdio.h>

int main()
{
    int n = 0;
    int x = 0;
    int y = 0;
    int c;

    while (c != '\n')
    {
        c = getchar();
        if ((c >= 'A'&& c <= 'Z')|| (c >= 'a'&&c <= 'z'))
            n++;
        else if (c >= 48 && c <= 57)
            x++;
        else
            y++;

    }
    printf("字母 total:%d\n", n);
    printf("数字 total:%d\n", x);
    printf("其他字符 total:%d\n", y);

    return 0;

}
while都是一样的。不可能是while的问题；
注意遇到换行符'\n'退出循环，但是在退出循环前，已经计算了，即其他字符就已经加1；
即使不输入数字和字母，直接输入回车，得到其他字符为1，就是计算了'\n'

如此判断就不会将换行符算入其他字符了：
#include<stdio.h>

int main()
{
    int n = 0;
    int x = 0;
    int y = 0;
    int c;

    while ((c = getchar()) != '\n')
    {
        if ((c >= 'A'&& c <= 'Z')|| (c >= 'a'&&c <= 'z'))
            n++;
        else if (c >= 48 && c <= 57)
            x++;
        else
            y++;

    }
    printf("字母 total:%d\n", n);
    printf("数字 total:%d\n", x);
    printf("其他字符 total:%d\n", y);

    return 0;

}
谢谢楼上大神，不过请问，为啥我这么写，在vs中报错，在VC中可以使用捏
c 没有初始化
引用 3 楼 hdt 的回复:c 没有初始化正解
啊。。。
那怎么给c初始化呢?此程序的c不需要赋值啊
如果按2楼大神的，相当于c初始化了吗？（在while语句的循环条件表达式中写）
1，第一可以随便给c一个不为'\n'的值
2、改while循环为do while循环


C++学生管理系统再次修改的错误C++
析构函数
学生管理系统
成员函数
构造函数

                  课本上的一道题，老师改了一下，上机操作总是有错误，不知道怎么改，请教大神，谢谢

老师要求身份证号改为成绩A，B，C，D，和日期一样做一个类，不需要使用内联函数。
不会引用只能复制粘贴，可能看起来比较麻烦，求大神帮帮忙啦！！！
谢谢！！！（引用上一次发帖内容）
又修改了一次错误实在不会改

实在看不懂什么意思
#include <iostream>
#include <string>
using namespace std;

class Date
{
public:
	Date(int,int,int);
	int getYear();
	int getMonth();
	int getDay();
private:
	int year;
	int month;
	int day;
};
Date::Date(int Year,int Month,int Day):year(Year),month(Month),day(Day)
{
	year=Year;
	month=Month;
	day=Day;
}
int Date::getYear()
{
	return year;
}
int Date::getMonth()
{
	return month;
}
int Date::getDay()
{
	return day;
}

class Score
{
public:
	Score(char);
    char getScore();
private:
	char score;
};
Score:: Score(char score)
{
	score=score;
}
char Score::getScore ()
{
	return score;
}
class Student
{
public:
	Student(int,string,char,int,int,int,char);
	Student(Student &s);
	void Show();
	int getNumber();
	string getName();
	char getSex();

	~Student(){};
private:
	int number;
	string name;
	char sex;

	Date d;
	Score score;
};
Student::Student(int Number,string Name,char Sex,int Year=0,int Month=0,int Day=0,char Score)
	:number(Number),name(Name),sex(Sex),d(Year,Month,Day),score(Score)
{}
int Student::getNumber()
{
	return number;
}
string Student::getName()
{
	return name;
}
char Student::getSex()
{
	return sex;
}

Student::Student(Student &s):d(s.d.getYear(),s.d.getMonth(),s.d.getDay()),score(s.score.getScore())
{
	number=s.getNumber();
	name=s.getName();
	sex=s.getSex();

}

void Student::Show()
{
	cout<<"学号：	"<<getNumber()<<endl;
	cout<<"姓名：	"<<getName()<<endl;
	cout<<"性别：	"<<getSex()<<endl;
	cout<<"出生年月：	"<<d.getYear()<<"	"<<d.getMonth()<<"	"<<d.getDay()<<"	"<<endl;
	cout<<"成绩："<<score.getScore()<<endl;
}

void Set()
{
	int inu,iye,imo,ida;
	char cse,iscore;
	string sna;
	cout<<"请输入学号：	";
	cin>>inu;
	cout<<"请输入名字：	";
	cin>>sna;
	cout<<endl;
	cout<<"请输入性别（男性输入M，女性输入W）：	";
	cin>>cse;
	cout<<"请输入出生年月日（中间用空格隔开）：	";
	cin>>iye>>imo>>ida;
	cout<<"请输入成绩：	";
	cin>>iscore;

	Student s(inu,sna,cse,iye,imo,ida,iscore);
	s.Show();
}
int main()
{
    for(int i=0;i<10000;i++)
	{
		cout<<"请输入第"<<i+1<<"个学生信息"<<endl;
	   Set();
	   cout<<endl;
	}
	return 0;
}
Student(int,string,char,int Year = 0,int Month = 0,int Day = 0,char Score = 'A');

Student::Student(int Number,string Name,char Sex,int Year,int Month,int Day,char Score)
    :number(Number),name(Name),sex(Sex),d(Year,Month,Day),score(Score)
{}
引用 1 楼 hefashion0190的回复:Student(int,string,char,int Year = 0,int Month = 0,int Day = 0,char Score = 'A');

Student::Student(int Number,string Name,char Sex,int Year,int Month,int Day,char Score)
    :number(Number),name(Name),sex(Sex),d(Year,Month,Day),score(Score)
{}
手打输入字符也要赋初值吗
Student::Student(int Number,string Name,char Sex,int Year=0,int Month=0,int Day=0,char Score)

还是这个问题       Score没有默认参数
因为编译器认为你这里引起歧义了啊。。把不需要默认的放在前面就OK了
Student::Student(int Number, string Name, char Sex,  char Score, int Year = 0, int Month = 0, int Day = 0)
	:number(Number), name(Name), sex(Sex), d(Year, Month, Day), score(Score)
{}
编译器并不知道你这里输入的是字符还是整型，所以，把没有默认初始的放在前面
引用 1 楼 hefashion0190的回复:Student(int,string,char,int Year = 0,int Month = 0,int Day = 0,char Score = 'A');

Student::Student(int Number,string Name,char Sex,int Year,int Month,int Day,char Score)
    :number(Number),name(Name),sex(Sex),d(Year,Month,Day),score(Score)
{}
这样改之后成绩没有输出
引用 3 楼 destory27的回复:Student::Student(int Number,string Name,char Sex,int Year=0,int Month=0,int Day=0,char Score)

还是这个问题       Score没有默认参数
设置参数值后最后输出却没有成绩，为啥啊，和前边对比了一下找不着错误，谢谢！
手机客户端拍不了照


Windows读取命名管道时阻塞，直接关闭管道句柄ReadFile能否安全返回？多线程
管道
windows api
windows
windows核心编程

                  一个线程在读取CreateNamedPipe创建的命名管道，没有数据的情况下ReadFile会阻塞。
现在我想让该线程返回，直接关闭管道句柄是安全的做法吗？是否有人尝试过？

注：

我知道可以用Pending I/O或者PeekNamedPipe模型解决，但现在有一个程序用的是我上面提到的方法。该程序在多线程压力测试中卡死，发现个别线程卡在ReadFile没有返回，怀疑关闭句柄并不能安全解除ReadFile阻塞。

请问是否有人遇到过相同的问题，或者是用关闭句柄实现过但并没有遇到问题？

感谢解答。
《Windows核心编程》？
CancelSynchronousIo
直接关闭管道句柄，阻塞的ReadFile会返回吧，出错返回。具体没试过。
1楼，回答无具体内容。
2楼，提供的CancelSynchronousIo不知为啥没效果，但受该启发用了CancelIoEx，问题解决。
3楼，鉴于改用CancelIoEx方案后我提到的问题已解决，且未再发现其他问题，故基本可以判明问题是直接CloseHandle引起的。另外，原程序在Server版系统上测试，数据传输线程有偶发崩溃现象，在更换方案后解决，基本也可判明是CloseHandle引起。故得出结论，CloseHandle关闭正在读写操作中的句柄是不规范的调用方法，可能引发严重问题。如果你程序中存在这种使用方法，建议更改。

综上，分给2楼。


.bat自动登录Telnet，显示的账号与脚本中的账号不一致Telnet
脚本

                  以下是代码。账户lifl102，密码abC*&#，但是在命令框里显示的却不是lifl102。求问为什么

@echo off
echo set sh=WScript.CreateObject("WScript.Shell") >telnet_tmp.vbs
echo WScript.Sleep 300 >>telnet_tmp.vbs
echo sh.SendKeys "lifl102{ENTER}" >>telnet_tmp.vbs
echo WScript.Sleep 300 >>telnet_tmp.vbs
echo sh.SendKeys "abC*&#{ENTER}">>telnet_tmp.vbs
echo WScript.Sleep 300 >>telnet_tmp.vbs
start telnet 192.168.1.1
cscript //nologo telnet_tmp.vbs
echo message
del telnet_tmp.vbs
已经解决了。是因为dos默认输入法是中文的，改成英文就行。在输入账号之前加一句切换下输入法的命令就可以
引用 1 楼 qq_40137976 的回复:已经解决了。是因为dos默认输入法是中文的，改成英文就行。在输入账号之前加一句切换下输入法的命令就可以
楼主加的一句什么?谢谢!


DirectX11程序在VS内可以运行,但双击不行,请教怎么回事?C++
DirectX
DirectX11

                  自己参考教程写了个DirectX11程序,在VS内可以运行,但双击该程序却不能运行(Release和Debug都双击不能运行),如图提示:

我写的其它程序在它们的目录内双击是可以运行的!
请教高手要怎么解决啊?
将dll所在文件夹添加到系统环境变量path中。


转义转义

                  我想做一个转义的代码，就是遇到'\',0x12,0x33,就转义为0xef,就是转不对
void transferStr(char tempStr[29], int tempStrLen, char rawStr[29], int &rawDataLen){
	//EF转义为0X11,0X23,EE转义为0X22,0X44
	int j = 0;
	//int tempInt = 0;
	int tempLen = tempStrLen;
	memcpy(rawStr, tempStr, 29);
	rawDataLen = tempStrLen;
	for (int i = 0; i < tempLen - 2;){
		if ((tempStr[i] == '\\') && (tempStr[i + 1] == 0x11) && (tempStr[i + 2] == 0x23)){
			rawStr[i] = 0xEF;
			/*for (j = i + 1; j < tempLen; j++){
				rawStr[j] = rawStr[j + 2];
			}*/

			i += 2;
			rawDataLen -= 2;
		}else if ((tempStr[i] == '\\') && (tempStr[i + 1] == 0x33) && (tempStr[i + 2] == 0x44)){
			rawStr[i] = 0xEE;
			/*for (j = i + 1; j < tempLen; j++){
				rawStr[j] = rawStr[j + 2];
			}*/
			i += 2;
			rawDataLen -= 2;
		}
		else{
			rawStr[i] = tempStr[i];		
		}
	}
}
void transferStr(char tempStr[29], int tempStrLen, char rawStr[29], int &rawDataLen)
{
	//EF转义为0X11,0X23,EE转义为0X22,0X44
	int n = 0, i = 0;

	for(i = 0; i < tempStrLen; i++)
	{
		if ((tempStr[i] == '\\') && (tempStr[i + 1] == 0x11) && (tempStr[i + 2] == 0x23))
		{
			rawStr[n++] = 0xEF;
			i += 2;
		}
		else if ((tempStr[i] == '\\') && (tempStr[i + 1] == 0x33) && (tempStr[i + 2] == 0x44))
		{
			rawStr[n++] = 0xEE;
			i += 2;
		}
		else
		{
			rawStr[n++] = tempStr[i];
		}
	}

	rawDataLen = n;
}
单步跟踪你的程序，观察每一步执行结果与你期望的是否一致，很容易找出问题原因
注意边界条件


opencv用solve进行直线拟合出错。。求大神帮忙。。。opencv
把出错信息放在百度翻译http://fanyi.baidu.com中翻译一下。


关于通信中C/C++数据交换的一个问题typedef struct fighter

{
int32 seriesNo；
int32 gunNum；

int32 speed；

} stFighter;

stFighter myFigther;

目前我们的通信是这样的，服务端将myFigther 以二进制流 figtherBuff的方式传到客户端，客户端根据协议知道 speed在数据流的8-11字节，将8-11字节拿出，解析为int32 的参量。

我就想，既然myFigther是结构体，那可以不可以两端都定义stFighter;，在figtherBuff传到客户端之后，客户端通过stFighter *pmyFigther =null ,pmyFigther = (*stFighter)figtherBuff  将二进制数据强制转换的方式得到协议的内容，直接pmyFigther ->speed的方式使用数据？

如果可以，这样做除了不能跨语言（只能在c与C/C++之间，与C#（好像C#也可以强制转换）之间通信）之外，还有什么缺点吗？
是不是如果两端机器的大小端不一样就会出问题？
必须保证都是C/C++语言，且大小端、对齐字节相同
只要字节序列和协议相符，用什么语言以及如何实现没关系
如果是完全可控的项目开发，字节对其和大小端都一致的情况下，可以直接传递结构体。但往往我们在定义协议的时候，
比如不同语言结构体对齐方式可能不同，只要保证按存储的方式去解析结构体中的各数据，程序就能正常运行
http://www.json.org


帮我看一下这个一元多项式的乘法函数哪里错了，不需要给我多正确的代码，帮我检查一下mutpoly函数哪里错了就行其他基本没问题，谢谢你#include <stdio.h>
#include <stdlib.h>
typedef struct Node *PtrToNode;
struct Node  {
    int Coefficient;
    int Exponent;
    PtrToNode Next;
};
typedef PtrToNode Polynomial;

Polynomial Read(); /* details omitted */
void Print( Polynomial p ); /* details omitted */
Polynomial Add( Polynomial a, Polynomial b );
Polynomial Multpoly(Polynomial P1, Polynomial P2);
int main()
{
    Polynomial a, b, s1,s2;
    a = Read(a);
    b = Read(b);
//    s2 = Add(a, b);
  //  Print(s2);
    s1=Multpoly(a, b);

    Print(s1);

    return 0;
}



Polynomial Multpoly(Polynomial P1, Polynomial P2)
{
    Polynomial P, temp1, temp2, Rear, temp;
    int c, e;
    if(!P1 || !P2)
        return NULL;
    temp1 = P1;
    temp1=temp1->Next;
    temp2 = P2;
    temp2=temp2->Next;
    P = (Polynomial)malloc(sizeof(struct Node));
    P->Next = NULL;
    Rear = P;
    Rear=Rear->Next;
    while(temp2){
        c = temp1->Coefficient * temp2->Coefficient;
        e = temp1->Exponent + temp2->Exponent;
        if(c != 0){
            temp = (Polynomial)malloc(sizeof( struct Node));
            temp->Coefficient=c;
            temp->Exponent=e;
            Rear->Next=temp;
            temp->Next=NULL;
            Rear=Rear->Next;
            temp2 = temp2->Next;
        }
    }
    temp1 = temp1->Next;
    while(temp1){
        temp2 = P2;
        temp2=temp2->Next;
         Rear = P;
         Rear=Rear->Next;
        while(temp2){
            c = temp1->Coefficient * temp2->Coefficient;
            e = temp1->Exponent + temp2->Exponent;
            if(c != 0){
                while(Rear->Next && Rear->Next->Exponent > e)
                    Rear = Rear->Next;
                if(Rear->Next && Rear->Next->Exponent == e){
                    if(Rear->Next->Coefficient + c)
                        Rear->Next->Coefficient += c;
                   /*else{
                        temp = Rear->Next;
                        Rear->Next = temp->Next;
                        free(temp);
                    }*/
                }
                else{
                    temp = (Polynomial)malloc(sizeof( struct Node));
                    temp->Coefficient = c;
                    temp->Exponent = e;
                    temp->Next = Rear->Next;
                    Rear->Next = temp;
                    Rear = Rear->Next;
                }
                temp2 = temp2->Next;
            }
        }
        temp1 = temp1->Next;
    }

/*    temp = P;
    P = P->Next;
    free(temp);*/
    return P;
}



void Print(Polynomial L)
{   Polynomial p;
    while(L->Next->Next!=NULL)
    {
        p=L->Next;
        printf("%d %d ",p->Coefficient,p->Exponent);
        L=L->Next;
}
   p=L->Next;
   printf("%d %d",p->Coefficient,p->Exponent);

}
Polynomial Read(Polynomial L)
{ int N;
  Polynomial t,ptr;
  L=(Polynomial)malloc(sizeof(struct Node));
  L->Next=NULL;
  t=L;
  scanf("%d",&N);
  while(N>0)
  {
      ptr=(Polynomial)malloc(sizeof(struct Node));
      scanf("%d %d",&ptr->Coefficient,&ptr->Exponent);
      L->Next=ptr;
      ptr->Next=NULL;
      L=L->Next;
      N--;

    }

  return t;

}
出错了可以中断下来分析原因，经检查，你的Rear = Rear->Next;后，你的Rear得到的值是NULL，在接下来的循环中又执行Rear->Next = temp;，这里解引NULL指针导致出错
仅供参考：//链表实现一元多项式的加法减法乘法
#include <stdio.h>
#include <stdlib.h>
typedef struct node {
    float coef;   //系数
    int expn;     //指数
    struct node *next;
}
PolyNode;      //多项式节点 polynomial node
typedef PolyNode* Polynomial;
Polynomial createPolynomial() {  //创建多项式
    PolyNode *p, *q, *head = (PolyNode *)malloc(sizeof(PolyNode));   //头节点
    head->next = NULL;
    float coef;
    int expn;
    printf("输入该多项式每一项的系数和指数，每项一行，输入0 0结束！\n");
    while (scanf("%f %d", &coef, &expn) && coef) {   // 默认，按指数递减排列
        if (head->next) {
            p = head;
            while (p->next && expn < p->next->expn)
                p = p->next;
            if (p->next) {
                if (expn == p->next->expn) { //有相同指数的直接把系数加到原多项式
                    p->next->coef += coef;
                    if (p->next->coef > -0.000001 && p->next->coef < 0.000001) { //若是相加后系数为0，则舍弃该节点
                        q = p->next;
                        p->next = q->next;
                        free(q);
                    }
                } else {
                    q = (PolyNode*)malloc(sizeof(PolyNode));
                    q->coef = coef;
                    q->expn = expn;
                    q->next = p->next;
                    p->next = q;
                }
            } else {
                p->next = (PolyNode*)malloc(sizeof(PolyNode));
                p = p->next;
                p->coef = coef;
                p->expn = expn;
                p->next = NULL;
            }
        } else {
            head->next = (PolyNode*)malloc(sizeof(PolyNode));
            head->next->coef = coef;
            head->next->expn = expn;
            head->next->next = NULL;
        }
    }
    return head;
}
Polynomial multiply(Polynomial poly, float coef, int expn) {  //多项式与指定单项式相乘，该单项式为 coefx^expn
    PolyNode *p, *q, *Poly = (PolyNode*)malloc(sizeof(PolyNode));
    p = Poly;
    q = poly->next;
    while (q) {
        p->next = (PolyNode*)malloc(sizeof(PolyNode));
        p = p->next;
        p->coef = (q->coef*coef);
        p->expn = (q->expn + expn);
        q = q->next;
    }
    p->next = NULL;
    return Poly;
}
void add(Polynomial poly1, Polynomial poly2) {  //把 poly2 加到 poly1 上
    PolyNode *p, *q, *r;
    r = poly1;
    p = poly1->next;  //指向第一个节点
    q = poly2->next;
    poly2->next = NULL;
    while (p && q) {
        if (p->expn > q->expn) {
            r->next = p;
            p = p->next;
            r = r->next;
        } else if (p->expn < q->expn) {
            r->next = q;
            q = q->next;
            r = r->next;
        } else {
            PolyNode *t;
            p->coef += q->coef;
            if (!(p->coef > -0.000001 && p->coef < 0.000001)) //系数不为0
            {
                r->next = p;
                r = r->next;
                p = p->next;
            } else {
                t = p;
                p = p->next;
                free(t);
            }
            t = q;
            q = q->next;
            free(t);
        }
    }
    if (p)
        r->next = p;
    if (q)
        r->next = q;
}
Polynomial polySubtract(Polynomial poly1, Polynomial poly2) {  //多项式减法 poly1-poly2形成一个新的多项式
    //把poly2的系数取相反数，形成一个新的多项式
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode)); //构造头节点
    PolyNode *p, *q;
    p = poly;
    q = poly2->next;
    while (q) {
        p->next = (PolyNode*)malloc(sizeof(PolyNode));
        p = p->next;
        p->coef = -(q->coef);  //系数取反
        p->expn = q->expn;
        q = q->next;
    }
    p->next = NULL;
    add(poly, poly1);  //利用加法
    return poly;
}
Polynomial polyAdd(Polynomial poly1, Polynomial poly2) { //多项式相加 poly1+poly2形成一个新的多项式
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode));  //和多项式的头节点
    poly->next = NULL;
    PolyNode *p, *q, *r;
    r = poly;
    p = poly1->next;
    q = poly2->next;
    while (p&&q) {
        if (p->expn > q->expn) {
            r->next = (PolyNode*)malloc(sizeof(PolyNode));
            r = r->next;
            r->coef = p->coef;
            r->expn = p->expn;
            p = p->next;
        } else if (p->expn < q->expn) {
            r->next = (PolyNode*)malloc(sizeof(PolyNode));
            r = r->next;
            r->coef = q->coef;
            r->expn = q->expn;
            q = q->next;
        } else {
            float m = p->coef + q->coef;
            if (!(m > -0.000001 && m < 0.000001)) {
                r->next = (PolyNode*)malloc(sizeof(PolyNode));
                r = r->next;
                r->coef = m;
                r->expn = p->expn;
            }
            q = q->next;
            p = p->next;
        }
    }
    while (p) {
        r->next = (PolyNode*)malloc(sizeof(PolyNode));
        r = r->next;
        r->coef = p->coef;
        r->expn = p->expn;
        p = p->next;
    }
    while (q) {
        r->next = (PolyNode*)malloc(sizeof(PolyNode));
        r = r->next;
        r->coef = q->coef;
        r->expn = q->expn;
        q = q->next;
    }
    r->next = NULL;
    return poly;
}
Polynomial polyMultiply(Polynomial poly1, Polynomial poly2) {  //多项式相乘
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode));  //创建多项式和的头节点
    poly->next = NULL;
    PolyNode *p;
    p = poly2->next;
    while (p) {
        add(poly, multiply(poly1, p->coef, p->expn));
        p = p->next;
    }
    return poly;
}
void printPoly(Polynomial poly) {  //打印多项式
    if (poly && poly->next) {
        PolyNode *p = poly->next;  //p指向第一个节点
        while (p->next) {
            printf("%gx^%d", p->coef, p->expn);
            p = p->next;
            if (p && (p->coef > 0))
                printf("+");
        }
        if (p->expn == 0)
            printf("%g", p->coef);   //打印常数项
        else
            printf("%gx^%d", p->coef, p->expn);
        printf("\n");
    }
}
void freePoly(Polynomial poly) {  //释放内存
    if (poly && poly->next) {
        PolyNode *p, *q;
        p = poly;
        while (p) {
            q = p->next;
            free(p);
            p = q;
        }
    }
    poly = NULL;
}
int main() {
    printf("用链表实现多项式的加减法\n");
    Polynomial poly1, poly2, poly3;
    printf("创建多项式一\n");
    poly1 = createPolynomial();
    printf("多项式一：\n");
    printPoly(poly1);
    printf("创建多项式二\n");
    poly2 = createPolynomial();
    printf("多项式二：\n");
    printPoly(poly2);
    printf("两多项式相加，和为：\n");
    poly3 = polyAdd(poly1, poly2);
    printPoly(poly3);
    freePoly(poly3);
    printf("两个多项式相乘，积为：\n");
    poly3 = polyMultiply(poly1, poly2);
    printPoly(poly3);
    freePoly(poly3);
    printf("两多项式相减，差为：\n");
    poly3 = polySubtract(poly1, poly2);
    printPoly(poly3);
    freePoly(poly1);
    freePoly(poly2);
    freePoly(poly3);
    system("pause");
    return 0;
}


问一个关于C和C++数据交换的问题现在客户端和服务端需要交互数据，目前是数据传输到对方后，对方根据协议，从数据流中逐一的截取二进制数据段，然后转换为对应的变量类型，如

typedef struct fighter{
　int32 seriesNo;
int32 gunNum;

int32 speed;
……
}  stFighter；

stFighter myFigher；

 根据协议 8-12字节是 变量speed，客户端接收到数据后，就截取8-12字节，转换成int32类型的参量。

我在想，既然在服务端要交换的数据myFigher是一个 结构体，那么我可不可以 服务端和客户端 定义同样的结构体stFighter，然后服务端传到客户端之后，客户端不需要再像上面一样解析，而是直接将 二进制流fighterBuff接收到之后， 直接定义一个 stFighter *pmyFighter ,直接pmyFighter  = (stFighter*)fighterBuff 强制转换之后用呢？

除了不能跨语言（C和C++不算跨语言吧，C#貌似也可以强制转换），还有什么弊端吗？ 是不是客户端和服务大小端不一样的时候不能用这样的方法？
比如不同语言结构体对齐方式可能不同，只要保证按存储的方式去解析结构体中的各数据，程序就能正常运行，大小端不同需要进行转换，否则直接用也不行
http://www.json.org
如果没有复杂数据类型可以使用json作为数据格式来传递，接收到后转换为json对象就行了，同样，发送前转换成json串就行了。可以搜jsoncpp这个库


读取文件内容时，被判定为EOF？文件内有那么一段内容（十六进制）
... 001A  0500  0000 ...

我用FILE对红色部分读取（4字节）时候，被判定为文件结束？

对此，我写了个测试程序进行验证，依旧如此，是VS下FILE设计的本意 还是我本地的Bug？

下面是我的测试程序（我此处把1306替换为其他，就读取正常）

#include <cstdio>
#include <cstring>

int main()
{
    FILE *fp = fopen("E:\\111.txt", "w");
    if (!fp)
    {
        printf("Save failed.");
        return 0;
    }

    int val = 1306;
    unsigned char buf[6] = { 0 };
    memcpy(&buf[1], &val, sizeof(int));
    fwrite(buf, sizeof(char), 6, fp);
    fclose(fp);

    fp = fopen("E:\\111.txt", "r");
    if (!fp)
    {
        printf("Open failed.");
        return 0;
    }

    char c = 0;
    int rval = 0;
    int ret1 = fread(&c, 1, 1, fp);
    int ret2 = fread(&rval, 4, 1, fp);

    printf("%d %d %d %d\n", ret1, ret2, feof(fp) ? 1 : 0, ferror(fp) ? 1 : 0);
    printf("%d %d\n", c, rval);

    fclose(fp);

    return 0;
}
你文件是用文本方式打开，读的时候却是按二进制读，你重新按二进制方式打开文件再读即可
引用 1 楼 paschen 的回复:你文件是用文本方式打开，读的时候却是按二进制读，你重新按二进制方式打开文件再读即可
感谢提醒。不记得我工程里面怎么使用了，明天我看看。
最近老是犯低级错误，忧伤！
本帖最后由 paschen 于 2017-11-03 00:37:42 编辑
引用 2 楼 幻夢之葉的回复:Quote: 引用 1 楼 paschen 的回复:
你文件是用文本方式打开，读的时候却是按二进制读，你重新按二进制方式打开文件再读即可
感谢提醒。不记得我工程里面怎么使用了，明天我看看。
最近老是犯低级错误，忧伤！
fp = fopen("s:\\111.txt", "r"); 改成 fp = fopen("s:\\111.txt", "rb");
引用 3 楼 paschen 的回复:Quote: 引用 2 楼 幻夢之葉的回复:Quote: 引用 1 楼 paschen 的回复:
你文件是用文本方式打开，读的时候却是按二进制读，你重新按二进制方式打开文件再读即可
感谢提醒。不记得我工程里面怎么使用了，明天我看看。
最近老是犯低级错误，忧伤！
fp = fopen("s:\\111.txt", "r"); 改成 fp = fopen("s:\\111.txt", "rb");
明白的，我说的工程是指在我的项目不是这里的代码 =。=
引用 1 楼 paschen 的回复:你文件是用文本方式打开，读的时候却是按二进制读，你重新按二进制方式打开文件再读即可
我感觉跟这个打开方式没关系，只要是fwrite写入的，用fread读应该没问题；
我在Linux下测试了你的程序，没做任何修改；输出的结果是：

1  1  0 0
0  1306

说明读的时候并没有到文件末尾，因为写的时候其实是写了6个字节，但是读的时候读了5个字节，所以不到文件末尾；
当读第7个字节时，此时就会提示EOF
稍微修改的代码如下：

#include <iostream>
#include <cstdio>
#include <cstring>

int main()
{
    FILE *fp = fopen("111.txt", "w");
    if (!fp)
    {
        printf("Save failed.");
        return 0;
    }

    int val = 1306;
    unsigned char buf[6] = { 0 };
    memcpy(&buf[1], &val, sizeof(int));
    fwrite(buf, sizeof(char), 6, fp);
    fclose(fp);

    fp = fopen("111.txt", "r");
    if (!fp)
    {
        printf("Open failed.");
        return 0;
    }

    char c = 0, c1 = 0, c2 = 0;
    int rval = 0;
    int ret1 = fread(&c, 1, 1, fp);
    int ret2 = fread(&rval, 4, 1, fp);
    int ret3 = fread(&c1, 1, 1, fp);
    int ret4 = fread(&c2, 1, 1, fp);

    printf("%d %d %d %d %d %d\n", ret1, ret2, ret3, ret4, feof(fp) ? 1 : 0, ferror(fp) ? 1 : 0);
    printf("%d %d %d\n", c, c1, rval);

    fclose(fp);

    return 0;
}

结果如下：

1 1 1 0 1 0
0 0 1306

因为我是在Linux下操作的，所以结果仅供参考～
引用 5楼自信男孩 的回复:Quote: 引用 1 楼 paschen 的回复:
你文件是用文本方式打开，读的时候却是按二进制读，你重新按二进制方式打开文件再读即可
我感觉跟这个打开方式没关系，只要是fwrite写入的，用fread读应该没问题；所以用文本方式打开按二进制读取行为未定义，你可以跟踪进fread代码分析原因
不要把
fopen("...","...");fscanf,fprintf,fgets,fgetc,fclose //读时把\r\n替换成\n，写时把\n替换成\r\n;读到\x1a就设置EOF;读写的内容当字符看待
和
fopen("...","...b");fseek,ftell,fread,fwrite,fgetc,fclose //不作以上替换，遇到\x1a仍继续读;读写的内容当字节看待
弄混了


C\C++ 如何读取pdf内容，进行关键字匹配我是用了xpdf，但是xpdf是先将pdf转化成txt，而且是直接获取流然后直接写入txt里，再读取匹配，这样感觉效率比较低。
如何能像txt一样直接获取字符串，然后匹配呢？
无profiler不要谈效率！！尤其在这个云计算、虚拟机、模拟器、CUDA、多核 、多级cache、指令流水线、多种存储介质、……满天飞的时代！
引用 1 楼 zhao4zhong1 的回复:无profiler不要谈效率！！尤其在这个云计算、虚拟机、模拟器、CUDA、多核 、多级cache、指令流水线、多种存储介质、……满天飞的时代！那能不能有更好的方法去读取pdf，感觉网上提供的都是Java和C#封装好的库，C++方面的资料比较少
参考谷歌桌面软件自带的pdftotext.exe ?
引用 3 楼 zhao4zhong1 的回复:参考谷歌桌面软件自带的pdftotext.exe ?参考的就是这货但是它是流存储到txt里，我现在想直接获得pdf文本内容，即字符串，然后做匹配。存入到文件然后再读文件再做匹配不是会慢吗。
Xpdf可以同时提取pdf中每个文字的坐标位置信息吗？
引用 5 楼 WSonGG 的回复:Xpdf可以同时提取pdf中每个文字的坐标位置信息吗？这个不太清楚，没试过获取坐标，不过xpdf可以获取很多的pdf信息，你可以去看看
引用 4 楼 sky821305 的回复:Quote: 引用 3 楼 zhao4zhong1 的回复:
参考谷歌桌面软件自带的pdftotext.exe ?参考的就是这货但是它是流存储到txt里，我现在想直接获得pdf文本内容，即字符串，然后做匹配。存入到文件然后再读文件再做匹配不是会慢吗。
1楼回复就是用来回答你“慢”的疑问的。


qt工程编译的时候异常qt

                  QML debugging is enabled. Only use this in a safe environment
https://stackoverflow.com/questions/21913189/bb10-qml-debugging-is-enabled-only-use-this-in-a-safe-environment

That comment is just telling you are running in a development environment, it is not related to your crash. You need to look for some other messages to find your error.
程序能运行就可以 这个应该没关系


char下面的红线看不懂，提示信息是：类型说明符的组合无效数据结构
串


#include "stdafx.h"
#define OK 1
#define ERROR 0
#define maxstrlen 255      // 可在 255 以内定义最大串长。 
typedef unsignde char SString[maxstrlen+1]; 
                                      // 0 号单元存放串的长度。
unsigned拼错了
是unsigned而不是unsignde，拼写有错误；


求助，C++调用一个原本用于java程序的dll文件C++
Java
DLL

                  简单点来说的话，我在使用C++调用一个原本用于java程序的dll文件时，总是被bad_alloc踢出来。
复杂点说的话.....
/***********************************/
现在想要提取一个java程序里面的算法函数原理，用于C++编程。
目标是找到它的算法原代码或者能够让我用黑箱子调用它都可以。
首先用zip对exe进行解压，然后反编译了一个关键class文件，得到目标java函数：
public native short function1(byte[] para1,int para2);
看到native便开始准备黑箱子调用。

用dumpbin.exe处理了与之相关的DLL文件，得到：
          1    0 00005910 Java_function1
我没有这个dll文件的源码，没有h、pdb、lib文件，仅有一个dll。
只知道它本来是供java程序使用，不知道此dll由什么语言写成。
/***********************************/
我的C++环境是VS2015，把dll文件放进cpp文件所在目录，然后尝试动态调用它：

#include<Windows.h>
#include<iostream>
using namespace std;
typedef short (*fit_type)(char[], int);
int main()
{
	const char* dllName = "resource_x64.dll";
	const char* funName1 = "Java_function1";
	char seq1[] = "seq1";
	HMODULE hDLL = LoadLibrary(dllName);
	if (hDLL != NULL)
	{
		fit_type function1 = fit_type(GetProcAddress(hDLL, funName1));
		if (function1 != NULL)
		{
			cout << "test start!" << endl;
			cout << function1(seq1, 0)<<endl;
		}
		else
		{
			std::cout << "Cannot Find Function " << funName1 << std::endl;
		}
		FreeLibrary(hDLL);
	}
	else
	{
		std::cout << "Cannot Find " << dllName << std::endl;
	}
	return 0;
}
在32位debug下找不到dll文件。
在64位debug下，"test start!"输出到了屏幕上，紧接着在function1被调用的那一行因bad_alloc而被踢了出来。
首先认为可能是数据类型问题。
我尝试了把int改成short，把char改成unsigned char，加上__stdcall，更改seq1的定义方式为char* seq1="seq1"等等众多方法，改过来改过去各种组合，都没有解决问题。
可能是思考方向有问题，研究的方向不太对，但又不知道问题出在哪里，只能继续摸索。
/***********************************/
动态没成功，我想切换静态方法尝试一下：
首先用dumpbin.exe得到dll的export信息，然后修改为ref格式，然后用lib.exe制成lib文件，和dll一起放在cpp文件所在目录。
然后在cpp中写下以下代码，尝试静态调用：

#include<Windows.h>
#include<iostream>
using namespace std;
#pragma comment (lib,"resource_x64.lib")
extern short Java_function1(char seq[], int num);
int main()
{
	char seq1[] = "seq1";
	cout << "test start!" << endl;
	cout << Java_function1(seq1,0)<<endl;
	return 0;
}
编译结果：
error LNK2019: 无法解析的外部符号
fatal error LNK1120: 1 个无法解析的外部命令

替换第二行。
extern "C" __declspec(dllexport) short Java_function1(char seq[], int num);
运行结果：
输出了"test start!",然后在Java_function1被调用的那一行因bad_alloc而被踢了出来。
是不是说明这个dll是用C写成的？

修改倒数第二行为
Java_function1("seq1",0);
依然因bad_alloc而被踢了出来。

再改：这次用new来分配内存

#include<Windows.h>
#include<iostream>
using namespace std;
#pragma comment (lib,"resource_x64.lib")
extern short Java_function1(char seq[], int num);
int main()
{
	char* seq1 = new char[5];
	seq1 = "seq1\0";
	cout << "test start!" << endl;
	cout << Java_function1(seq1,0)<<endl;
	return 0;
}
依然因bad_alloc而被踢了出来。
/***********************************/
无果，决定反汇编/反编译。
ildasm和Reflector都提示这不是.NET，无法反汇编/反编译
考虑过使用java来调用这个dll，然后用C++通过JNI调用java。
不过这样效率是不是有些低？C++模块中存在多线程部分，而且比较要求性能。
我不知道Java_function1中是否存在修改seq1的行为。
/***********************************/
综上：
我三天来的自行思考过程都在上面了，实在没想到好的解决办法。
我的目标是想要提取这个java程序里面的算法函数原理，用于C++编程，无论是找到它的算法原代码或者能够让我用黑箱子调用它都可以。
谢谢~
第二个参数不用0试一下.
本帖最后由 CharlesSimonyi 于 2017-07-29 04:21:48 编辑

                  如果这个DLL是专为JNI调用设计的
public native short function1(byte[] para1,int para2);
这个函数在dll的c代码中，肯定不止这两个参数，还有JNIEnv * env等参数
了解一下JNI的相关知识
使用Depends和DLL Export Viewer等工具查看一下dll导出函数的原型
也可以用IDA Pro反编译一下这个dll，按F5查看dll函数的C伪代码，弄清楚函数的形状
原先java里面所有调用都用的0，并不知道有什么含义。直觉认为还是不要改的好……

好的我去试试depends、DLL Export Viewer和IDA Pro。
程序要移动到其他电脑运行。如果要把C++、JNI和java运行时库都安装才能用，可能不是上策。如果其他方法不行会试试的。

谢谢~
估计要过段时间才能回来发进一步测试结果。
怎么样，我也遇到和你类似的问题，我的是只有dll和lib文件而没有h文件。显示的结果也是：无法解析外部符号-》Unresolved Externals？？？求解，或者是大神点拨一二，，，，万分感谢


模板参数，如何匹配到引用特化上模板

                  下面的代码输出了2次int，请问如何匹配到int &上？
#include <stdio.h>

template<typename T>
void func(T arg)
{
    printf("var\n");
}

template<>
void func(int arg)
{
    printf("int\n");
}

template<>
void func(int &arg)
{
    printf("int &\n");
}


int main(int argc, char *argv[])
{
    int n1; 
    int &n2 = n1; 

    func(n1);
    func(n2);

    return 0;
}
这种必须显示的指定一下 func<int&>(n2);
本来就是想使用自动匹配的功能，如果手动指定了，那就不必用函数模板了。
看来只能用指针了，不能用引用。
这种有二意性的，必须显示指定。
去看看关于函数匹配优先级吧，普通函数的完全匹配是比模板高级的
因为模板函数不支持偏特化
调用可以func<int>(5);
函数直接重载，不需要的。
http://en.cppreference.com/w/cpp/language/function_template
http://blog.csdn.net/hou09tian/article/details/77425358


服务器方向实习问题职业规划
C++
服务器

                  我想问下各位大佬，如果想从事服务器的开发，想要实习，但是要求都有服务器开发经验，可是我没有，可以做些什么小项目来弥补这方面的欠缺？
找一家相关的公司实习吧
实习一般都会要的 工资不需要太高 
学点东西
这种情况太普遍了,最好是有内推
如果没路子只能耐心找了,一定要正规的,待遇可以低,但必须有保障
也不用找什么项目,好好准备面试就行
重要还是耐心,不能迁就
引用 1 楼 qq_38204686 的回复:找一家相关的公司实习吧
实习一般都会要的 工资不需要太高 
学点东西谢谢
引用 2 楼 qq_31709097 的回复:这种情况太普遍了,最好是有内推
如果没路子只能耐心找了,一定要正规的,待遇可以低,但必须有保障
也不用找什么项目,好好准备面试就行
重要还是耐心,不能迁就谢谢，我会加油找的。坚定自己的方向！！


switch中不能有输入语句吗？小白提问

                  switch 内不能输入？
case 't':				
	printf("next char: ");
	if (c == 't')
	{
		printf("ijasd\n");
		scanf("%c", &c2);
		if ((c2 = getchar()) == 'u')
		{
			printf("Tuesday!\n");
		}
		else //if (c2 == 'h')
		{
		printf("Thursday!\n");
		}
	}
你前面已经用scanf读入过c2了
然后你判断的时候又用getchar一遍？
所以你想干什么
好吧，谢谢你的回复。


static 遇到extern，会如何？一个项目中用到了一个extern变量，，


然后，某些.c文件中。也定义了同名变量， 

同名变量用static修饰， 

请问该extern变量，，会对static 变量造成什么干扰？
static 声明的全局变量只能在当前源文件中使用;
extern 不是定义，是引入(声明)在其它源文件中定义的非 static 全局变量;
引用 1 楼 qq423399099 的回复:static 声明的全局变量只能在当前源文件中使用;
extern 不是定义，是引入(声明)在其它源文件中定义的非 static 全局变量;

啥？其它源文件？你的意思是我这样不行咯：

int x;

void f (void)
{
    extern int x;
    if (/* ... */)
    {
        extern int x;
     }
}
引用 2 楼 sholber 的回复:Quote: 引用 1 楼 qq423399099 的回复:
static 声明的全局变量只能在当前源文件中使用;
extern 不是定义，是引入(声明)在其它源文件中定义的非 static 全局变量;

啥？其它源文件？你的意思是我这样不行咯：

int x;

void f (void)
{
    extern int x;
    if (/* ... */)
    {
        extern int x;
     }
}
楼主是要干嘛？
引用 3 楼 qq423399099 的回复:Quote: 引用 2 楼 sholber 的回复:
Quote: 引用 1 楼 qq423399099 的回复:
static 声明的全局变量只能在当前源文件中使用;
extern 不是定义，是引入(声明)在其它源文件中定义的非 static 全局变量;

啥？其它源文件？你的意思是我这样不行咯：

int x;

void f (void)
{
    extern int x;
    if (/* ... */)
    {
        extern int x;
     }
}
楼主是要干嘛？

我就是想问，这3个x是不是同一个。
引用 1 楼 qq423399099 的回复:static 声明的全局变量只能在当前源文件中使用;
extern 不是定义，是引入(声明)在其它源文件中定义的非 static 全局变量;

我刚才回复你了，结果回复不见了。再次回复。

xx.h里有 extern int data_handle;

a.c里有static int data_handle,

其他.c也用到了data_handle， 其他.c里有没有用static修饰该变量，我没有关注！！！！

我的问题是： 如果a.c包含 xx.h，那么 data_handle; 会有什么后果？

a.c如果没有包含xx.h，那么data_handle又有什么后果？

我想对a.c里的static int data_handle;重命名，由于没有搞定这语法，所以不敢随意重命名。
引用 5 楼 u012879787 的回复:xx.h里有 extern int data_handle;

a.c里有static int data_handle,

其他.c也用到了data_handle， 其他.c里有没有用static修饰该变量，我没有关注！！！！

我的问题是： 如果a.c包含 xx.h，那么 data_handle; 会有什么后果？

a.c如果没有包含xx.h，那么data_handle又有什么后果？

我想对a.c里的static int data_handle;重命名，由于没有搞定这语法，所以不敢随意重命名。


xx.h里有 extern int data_handle;

a.c里有static int data_handle,
两个文件中的data_handle 没有关系，
a.c中的 data_handle只是在a.c中起作用，不能被其它文件访问，也不影响xx.h中外部变量data_handle的值
楼主你可以自己试一下呗
a.c如果没有包含xx.h，那肯定没关系，这个显而易见
a.c如果包含xx.h，也没关系，别的文件中的全局变量，会被本文件的static覆盖
（楼主也可以看看强符号，弱符号加深理解）
static 关键字可以避免编译器的小(?)聪明.
明确不需要被其他文件extern的全局变量,显式的告诉编译器,表extern我
引用If, within a translation unit, the same identiﬁer appears with both internal and external linkage, the behavior is undeﬁned.
而
引用For an identiﬁer declared with the storage-class speciﬁer extern in a scope in which a prior declaration of that identiﬁer is visible, if the prior declaration speciﬁes internal or external linkage, the linkage of the identiﬁer at the later declaration is the same as the linkage speciﬁed at the prior declaration. If no prior declaration is visible, or if the prior declaration speciﬁes no linkage, then the identiﬁer has external linkage.
所以先出现 extern 后出现 static 是不行的，先出现 static 后出现 extern 则为 static
引用 8 楼 iyomumx 的回复:引用If, within a translation unit, the same identiﬁer appears with both internal and external linkage, the behavior is undeﬁned.
而
Quote:For an identiﬁer declared with the storage-class speciﬁer extern in a scope in which a prior declaration of that identiﬁer is visible, if the prior declaration speciﬁes internal or external linkage, the linkage of the identiﬁer at the later declaration is the same as the linkage speciﬁed at the prior declaration. If no prior declaration is visible, or if the prior declaration speciﬁes no linkage, then the identiﬁer has external linkage.
所以先出现 extern 后出现 static 是不行的，先出现 static 后出现 extern 则为 static

你引用的帖子丢失了？
引用 9 楼 bsnry 的回复:你引用的帖子丢失了？  
引用的是 C 语言标准（C11草案）
引用 10 楼 iyomumx 的回复:Quote: 引用 9 楼 bsnry 的回复:

你引用的帖子丢失了？  
引用的是 C 语言标准（C11草案）

什么叫先出现static, 后出现extern， 先出现extern后出现 static？ 是不是这么理解： 

1. 
statci int data_handle;

#include" xx.h"  //头文件里包含extern 的申明


2.  

#include "xx.h"

staic int data_handle;
引用 11 楼 u012879787 的回复:什么叫先出现static, 后出现extern， 先出现extern后出现 static？ 是不是这么理解： 

1. 
statci int data_handle;

#include" xx.h"  //头文件里包含extern 的申明


2.  

#include "xx.h"

staic int data_handle;
和头文件没什么关系，你可以试试：
$ echo 'static int i;' > si.c
$ echo 'extern int i;' > ei.c
$ cat si.c ei.c > sei.c
$ cat ei.c si.c > esi.c
$ gcc - c sei.c
$ gcc - c esi.c
esi.c:2 : 12 : error : static declaration of ‘i’ follows non - static declaration
static int i;
^
esi.c:1 : 12 : note : previous declaration of ‘i’ was here
extern int i;
^
引用 7 楼 qq423399099 的回复:楼主你可以自己试一下呗
a.c如果没有包含xx.h，那肯定没关系，这个显而易见
a.c如果包含xx.h，也没关系，别的文件中的全局变量，会被本文件的static覆盖
（楼主也可以看看强符号，弱符号加深理解）
static 关键字可以避免编译器的小(?)聪明.
明确不需要被其他文件extern的全局变量,显式的告诉编译器,表extern我

请问“a.c如果包含xx.h, 会被本文件的static覆盖”在哪里可以求证呢？  可以推荐相关资料吗


单链表的插入排序c++
单链表

                  这是单链表的插入排序，不懂为什么p->next一定要为空？
void sortlist()
{
    node * newhead, * s, * pre ,* p;
    p=head->next;
    newhead=p->next;
    p->next=NULL;//这里p为什么一定要为空？
    while(newhead)
    {
        s=newhead;
        newhead=newhead->next;
        pre=head;
        p=head->next;
        while(p!=NULL && p->a < s->a)
        {
            pre=p;
            p=p->next;
        }
        s->next=p;
        pre->next=s;
    }
}
初始化 方便下面循环判断
代码有问题，输入空的或者单节点的链表，会崩溃。所以换一个答案参考。
你看下面有一句判断 while(p!=NULL && p->a < s->a)；如果不赋NULL初值的化这句判断就无效过了！
结束下面的while()循环，p->next=NULL后相当于先建了另一条新链表，该链表只包含头结点和原链表的第一个数据结点。
然后newHead指向原链表的第二个数据结点，然后开始依次通过比较方法插入新链表中，当新链表中的结点数据均小于newHead指向的旧链表数据结点时，此时需要结束while循环，此时p==NULL退出while循环，然后将newHead指向的数据结点插入新链表的末尾。
#include <stdio.h>
#include <windows.h>
#include <malloc.h>
#include <string.h>

typedef struct LoopList{
	int num;
	struct LoopList *next;
}list;

void cursor(void)
{
	system("color 0A");
	system("title Circular points list");
	system("mode con  lines=20 cols=40");
	//HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);
	//DWORD dword = 18;
    //BOOL SetConsoleFont(handle, dword);

    return ;	
}

void chooseMenu(void)
{
	printf("----------------------------------------");
	printf("\tLoop singly linked list \t");
	printf("----------------------------------------");
	printf("\t************************\t");
	printf("\t*1.初始化\t2.添加*\t\t");
	printf("\t*3.元素个数\t4.插入*\t\t");
	printf("\t*5.显示\t\t6.排序*\t\t");
	printf("\t*7.查找\t\t8.取出*\t\t");
	printf("\t*\t 0.退出 \t\t");
	printf("\t************************\t");
	printf("----------------------------------------");


	return ;
}

list * init(list **head)
{
	*head = (list *)malloc(sizeof(list));
	(list *)memset(*head, 0x00, sizeof(list));
	(*head)->next = *head;
	printf("初始化成功。\012");
	Sleep(3000);
	return *head;
}

list *add(list **head)
{
	list *s = *head;
	int n;
	printf("你要添加的元素个数:");
	while((scanf("%d", &n)) == 0){
		fflush(stdin);
		printf("Enter again:");
	}

	while(n--){
		list *p = (list *)malloc(sizeof(list));
		(list *)memset(p, 0x00, sizeof(list));
		printf("input data:");
		while((scanf("%d", &p->num)) == 0){
			fflush(stdin);
			printf("Enter again:");
		}
		while(s->next != *head){
			s = s->next;
		}
		s->next = p;
		p->next = *head;
	}
	printf("添加完成。\012");
	Sleep(3000);

	return *head;
}

void size(list **head)
{
	int size = 0;
	list *p = *head;
	while(p->next != *head){
		p = p->next;
		++size;
	}
	printf("元素个数:%d\012", size);
	Sleep(3000);

    return ;	
}

void insert(list **head)
{
	list *s = *head;
	list *p = (list *)malloc(sizeof(list));
	(list *)memset(p, 0x00, sizeof(list));
	printf("insert num:");
	while((scanf("%d", &p->num)) == 0){
			fflush(stdin);
			printf("Enter again:");
		}
	while(s->next != *head)
		s = s->next;
	s->next = p;
    p->next = *head;
    printf("插入完成.\012");
	Sleep(3000);

	return ;
}

void sort(list **head)
{
	list *p = *head;

	if(p->next == *head || p->next->next == *head){
		printf("数据为空或只有一个无法进行排序.\012");
		Sleep(3000);
	}
	else{
		int i = 0;
		int arr[100];
		while(p->next != *head){
		    arr[i++] = p->next->num;
		    p = p->next;
	    }

		int t = i;
		for(i = 0; i < t-1; ++i){
			int j = i;
			int temp = arr[j+1];		
			while(j > -1 && temp < arr[j]){
				arr[j+1] = arr[j];
				--j;
			}
			arr[j+1] = temp;
		}

		p = *head;
		i = 0;
		while(p->next != *head && i < t){
			p->next->num = arr[i++];
			p = p->next;
		}
		printf("排序完成.\012");
		Sleep(3000);
	}

	return ;
}

void show(list **head)
{
	list *p = *head;
	if(p->next == *head){
		printf("要显示的内容为空.\012");
		Sleep(3000);
	}
	else{
		while(p->next != *head){
		    printf("%d ", p->next->num);
		    p = p->next;
	    }
	    printf("\012");
	    printf("已显示完.");
	    printf("\012");
	    Sleep(3000);
	}

	return;
}

void seek(list **head)
{
	list *p = *head;
	if(p->next == *head){
		printf("数据内容为空.\012");
		Sleep(3000);
	}
	else{
		 int n;
		printf("输入你要查找的数:");
		while((scanf("%d", &n)) == 0){
		fflush(stdin);
			printf("Enter again:");
		}

		int i  = 1;
		int count = 0;
		while(p->next != *head){
			if(p->next->num == n){
				printf("第%d个数是%d.\012", i, n);
				++i;
				++count;
				p = p->next;
			}
			else {
				++i;
				p = p->next;
			}

		}
		if(count == 0)
			printf("没有此数据.\n");
		Sleep(3000);
		}

	return ;
}

void delete(list **head)
{
	list *p = (*head)->next;
	if(p == *head){
		printf("数据内容为空.\012");
		Sleep(3000);
	}
	else{
		list *s = *head;
		list *temp = NULL;
		int n;
		printf("输入你要查找的数:");
		while((scanf("%d", &n)) == 0){
			fflush(stdin);
			printf("Enter again:");
		}

		while(p != *head){
			if(p->num != n){
				s = p;
				p = p->next;
			}
			else{
				temp = p;
				s->next = p->next;
				p = p->next;
			}

		}

		if(temp == NULL)
			printf("未找到要删除的数据.\012");
		else
			printf("已取出 %d \012", temp->num);
		Sleep(3000);
		}


	return;
}

int main(void)
{
	cursor();
	chooseMenu();
	list *head;
	int flag = 1;
	while(1){
		int choose;
		system("cls");
		chooseMenu();
	    printf("please choose:");
	    while((scanf("%d", &choose)) == 0){
		    fflush(stdin);
		    system("cls");
			chooseMenu();
		    printf("Enter again:");
		}
        
        while(flag){
			if(choose == 1)
				flag = 0;
			else if(choose == 0)
				exit(0);
			else {
				printf("必须先初始化.\012");
				printf("please choose:");
	            while((scanf("%d", &choose)) == 0){
		            fflush(stdin);
		            system("cls");
					chooseMenu();
		            printf("Enter again:");
		        }
			}
		}
		switch(choose){
			case 1:
			    head = init(&head);break;
			case 2:
				head = add(&head);break;
			case 3:
			   size(&head);break;
			case 4:
			    insert(&head);break;
			case 5:
				show(&head);break;
			case 6:
			    sort(&head);break;
			case 7:
				seek(&head);break;
			case 8:
			    delete(&head);break;
			case 0: 
			    exit(0);
			default: 
			    printf("error!\012");Sleep(2000);break;
		}
	}

	return 0;
}


服务端和客户端聊天服务端和客户端聊天  只能服务端用send发送 客户端recv接收  怎么才能客户端也能send 


 服务端:SOCKET sockfonn=accept(sockSrv,(SOCKADDR*)&addrClient，&nlength);  

		char szSendbuf[100]= "你好";
		while (1)
		{   
			send(sockfonn, szSendbuf, strlen(szSendbuf)+1, 0);
			scanf("%s", &szSendbuf);
                 }
客户端:	while (1)
	{
		char szRevcbuf[100];
		recv(sockClient, szRevcbuf, 100, 0);
		printf("服务器发来消息:%s\n", szRevcbuf);
	}
客户端建立套接字连接服务器以后
就可以send啊

都是调用函数 百度不少源码
如果是简单的一问一答形式，很容易，recv后再send
如果不是这样简单的形式，那么多线程。一个线程recv，一个线程send，多线程要处理线程同步的情况，比较复杂了。


线程间无名信号量问题这个什么原理？


C语言求助，简单的球和#include <stdio.h>

void sum(int begin, int end)
{
    int i;
    int sum = 0;
    for(i=begin; i<=end; i++)
    {
        sum += 1;
    }
    printf("sum = %d \n", &sum);   
}

int main()
{
    sum(54, 77);
    return 0;
}

结果：
Windows PowerShell
版权所有 (C) 2009 Microsoft Corporation。保留所有权利。

PS C:\Users\Administrator> cd "c:\Users\Administrator\Desktop\" ; if ($?) { gcc sum.c -o sum } ; if ($?) { .\sum }
sum = 2686752

！！！！结果为什么是2686752呀！！！
我用的vscode的coderunner
谢谢谢谢
printf("sum = %d \n", &sum);     // 这里你取 sum的地址，是错误的
1、printf内对sum取址
2、求和应该是每次sum+=i吧
打印的是sum的地址信息
//printf("sum = %d \n", &sum);  //scanf才需要对sum取地址 
     printf("sum = %d \n", sum);   
 }
printf("sum = %d \n", &sum);   //error


初学Opencv  使用split()遇到的内存问题opencv
内存

                  错误提示：(opencv_world300.dll) (test1.exe 中)处有未经处理的异常: 0xC0000005: 写入位置 0xDDDDDDE9 时发生访问冲突。

代码：Mat dota_Image,dota_Logo;
	    vector<Mat> channel;
	   dota_Image = imread("dota2_jugg.jpg");
	   dota_Logo = imread("dota2_logo.jpg",0);

	assert(dota_Image.data != NULL);
	assert(dota_Logo.data != NULL);
	split(dota_Image,channel);

调试运行到split函数的时候程序当掉，感觉是vector内存越界的问题，求大神看下怎么解决？如果自己用new分配内存则没有问题，然后再release模式下也没问题
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
检查一下看看是不是使用的dll，lib版本不对，我猜有可能是这个原因
楼主解决没？什么问题？
求问最后是怎么解决的？？
楼主解决了没？
找了一些论坛以后，发现了一个办法就是给vector定义一个大小
我也出现这个问题了，没有找到原因，因为dll文件设置应该是没有问题的；

后来找了个解决方案：将“vector<Mat> rgbPlanes;"改为“Mat rgbPlanes[3]”;

使用Mat矩阵可以解决这个问题
引用 6 楼 yingsongwu 的回复:找了一些论坛以后，发现了一个办法就是给vector定义一个大小


我的，使用vector就不行，定义大小还是不行，只能用Mat rgbPlanes[3]
跟楼上一样，这个到底是什么原因呀？
7,8楼都可以解决问题，但是为啥啊？以前这么定义的没出错！
调试运行到split函数的时候程序当掉，感觉是vector内存越界的问题，求大神看下怎么解决？如果自己用new分配内存则没有问题，然后再release模式下也没问题 。。。 我也是同样的问题，怎么用new分配内存啊？？？


(1 & 0x0ff0) >> 4得出结果是多少?怎么算的?本人新手,求指教位运算

                  m_pDayFrame[unitOffset] = (unsigned char)((frameIndex & 0x0ff0)>>4);
m_pDayFrame[unitOffset + 1] = (unsigned char)((m_pDayFrame[unitOffset + 1] &0x0f) + ((frameIndex &0x0f)<<4));
结果为0，

先按位与，结果为0
0000 0000 0000 0001 (1)
0000 1111 1111 0000   (0x0ff0)

0向右移四位，结果还是为0
引用 1 楼 hefashion0190 的回复:结果为0，

先按位与，结果为0
0000 0000 0000 0001 (1)
0000 1111 1111 0000   (0x0ff0)

0向右移四位，结果还是为0

那如果不是1,是80这样的数,算出来是多少呀
80 的二进制为  0000 0000 0101 0000，自己算一下就好啦！
复习C语言位运算章节
引用 2 楼 zaxzhixing 的回复:Quote: 引用 1 楼 hefashion0190 的回复:
结果为0，

先按位与，结果为0
0000 0000 0000 0001 (1)
0000 1111 1111 0000   (0x0ff0)

0向右移四位，结果还是为0

那如果不是1,是80这样的数,算出来是多少呀

80的二进制是0000 0000 0101 0000
与1的二进制0000 0000 0000 0001位与
结果是0000 0000 0000 0000
再向右移4位 结果还是0


C语言链表输出少一个数据怎么办c语言 链表


#include"stdafx.h"
#include"stdio.h"
#include"stdlib.h"
#include "malloc.h"
#define LEN sizeof(struct Student)
struct student
{
    int num;
    int score;
    struct student *next;
};
int n;
struct student *creat(void){
	student *ptr,*p1,*p2;
	n=0;
	int t;
	printf("please input number of students:\n");
	scanf("%d",&t);
	printf("please input student data:\n");
	p1=p2=(struct student *)malloc(sizeof(student));
	scanf("%d,%d",&p1->num,&p1->score);
		ptr=NULL;
		t=t-1;
	do{
		n=n+1;
		if(n==1)ptr=p1;
		else p2->next=p1;
		p2=p1;
		p1=(struct student *)malloc(sizeof(student));
		scanf("%d,%d",&p1->num,&p1->score);
	}while(n<t);
	p2->next=NULL;
	printf("\n");
	return(ptr);
}

   



int main()
{
	struct student *ptr;
	int i=1;
	ptr=creat();
	printf("please output linklist data:\n");
	while(ptr!=NULL)
	{
		printf("student%d:num=%d,score=%d\n",i++,ptr->num,ptr->score);
		ptr=ptr->next;
	}
	return 0;
}

在自己觉得有问题的地方, 用printf将存疑的变量打印输出,  直到发现问题
不要使用
while (条件)
更不要使用
while (组合条件)
要使用
while (1) {
 if (条件1) break;
 //...
 if (条件2) continue;
 //...
 if (条件3) return;
 //...
}
因为前两种写法在语言表达意思的层面上有二义性，只有第三种才忠实反映了程序流的实际情况。
典型如：
下面两段的语义都是当文件未结束时读字符
while (!feof(f)) {
 a=fgetc(f);
 //...
 b=fgetc(f);//可能此时已经feof了！
 //...
}
而这样写就没有问题：
while (1) {
 a=fgetc(f);
 if (feof(f)) break;
 //...
 b=fgetc(f);
 if (feof(f)) break;
 //...
}
类似的例子还可以举很多。


“多一少一”问题占程序员常犯错误的10%以上！
避免“多一少一”问题的方法之一是将比如<10甚至<5的数代入程序片断，掰手指头心算验证一下程序到底应该写为
x、x-1、x+1中的哪个？
<、<=、==、>、>=中的哪个？
数据结构对单链表进行数据排序 http://bbs.csdn.net/topics/392201633
少一个的原因是创建的时候就少创建一个，最后输入的节点其实并没有加入链表；只需要将最后输入的节点加入链表即可：如下，
//#include"stdafx.h"
#include <stdio.h>
#include <stdlib.h>
//#include "malloc.h"

#define LEN sizeof(struct student)   /* 注意单词的大小写*/

struct student
{
    int num;
    int score;
    struct student *next;
};

int n;

struct student *creat(void)
{
    struct student *ptr,*p1,*p2;
    int t;
    printf("please input number of students:\n");
    scanf("%d", &t);
    printf("please input student data:\n");
    p1 = p2 = (struct student *)malloc(sizeof(struct student));
    scanf("%d,%d", &p1->num,&p1->score);
    ptr = NULL;
    t = t-1;
    n = 0;
    do {
        n = n + 1;
        if(n==1)
            ptr = p1;
        else
            p2->next=p1;
        p2=p1;
        p1 = (struct student *)malloc(sizeof(struct student));
        scanf("%d,%d", &p1->num,&p1->score);
    }while(n < t);
    /*将最后一个节点加入链表*/
    p2->next = p1;
    p1->next = NULL;
    //p2->next=NULL;
    printf("\n");
    return(ptr);
}





int main()
{
    struct student *ptr, *phead;
    int i = 1;
    phead = creat();
    printf("please output linklist data:\n");
    ptr = phead;
    while(ptr)
    {
        printf("student%d:num=%d,score=%d\n",i++,ptr->num,ptr->score);
        ptr = ptr->next;
    }
    return 0;
}
对于系统库文件，建议用<>，对于自定义头文件，建议用""
谢谢各位！已解决


跪求大神分析下代码哪里有错哈（题目是：一个整数，它加上100 后是一个完全平方数，再加上168 又是一个完全平方数，请问该数是多少？）#include<stdio.h>
int judge(int i)
{
	int m,k;
	    for(k=1;k<=i;k++)
		{
			if(k*k==i)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}

}
int main()
{
	int i,m,n;
	for(i=1;i<=10000;i++)
	{
		m=judge(i+100);
		n=judge(i+268);

		if(m==1&&n==1)
		{
			printf("%d",i);
		}
	}
	return 0;
}
return 0 应该放到最外面，当所有的平方数都测试完成，没有符合的才是返回 false。
当有符合的就返回 true。
这样改没用啊，程序运行还是什么也没有
我明白了，judge函数else里面应该是continue


关于opencv和vs2017做opencv作业的时候，每次运行过后就很快的闪过一个空的命令提示符

然后输出一大堆

没有错误和警告
ctrl+f5也只是这样

图片什么的根本没有显示出来
请问一下这样该怎么解决
你最后有木有加waitKey(0)呀？
引用 1 楼 kuangbao9 的回复:你最后有木有加waitKey(0)呀？加了的
代码如下：
#include "stdafx.h"


#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char **argv)
{
	const char* filename = "E:\TIGER\cat.jpg";

	Mat srcImg = imread(filename, CV_LOAD_IMAGE_COLOR);
	if (srcImg.empty())
		return -1;
	imshow("source", srcImg);

	int channels = srcImg.channels();
	int nRows = srcImg.rows;
	int nCols = srcImg.cols* channels;
	if (srcImg.isContinuous())
	{
		nCols *= nRows;
		nRows = 1;
	}
	int i, j;
	uchar* p;

	for (i = 0; i < nRows; ++i)
	{
		p = srcImg.ptr<uchar>(i);
		for (j = 0; j < nCols; ++j)
		{
			cout << int(srcImg.ptr(i)[j]) << "  ";
		}
		cout << "\n";
	}
	cout << "请输入你想要访问的像素点的坐标:";
	cin >> i >> j;
	if (i<0 || i>nRows - 1 || j<0 || j>nCols - 1) {
		cout << "你想要访问的像素点的坐标不存在";
	}
	else {
		p = srcImg.ptr<uchar>(i);
		cout << int(srcImg.ptr(i)[j]) << "  ";
		cout << "\n";
	}
	waitKey(0);
	return(0);
}
我用的是opencv3.30版本和vs2017
图片没加载成功，返回-1了。你可以把图片放在程序的目录下试下，把const char* filename = "E:\TIGER\cat.jpg";改为const char* filename = "cat.jpg";
你路径写错了，'\'改为'\\'
const char* filename = "E:\TIGER\cat.jpg"改为const char* filename = "E:\\TIGER\\cat.jpg"


内存双重释放问题#include <iostream>
#include <vector>
#include <string>
#include <memory>

void process(std::shared_ptr<int> ptr)
{

}

int main()
{
	auto i1 = new int(10);
	process(std::shared_ptr<int>(i1));
}

上面这段代码中，std::shared_ptr<int>(i1)是临时对象，然后当  process(std::shared_ptr<int>(i1));  语句执行完成后就自动释放临时对象的内存，然后在process函数中ptr因为计数器为1，所以函数结束后就自动释放内存，临时对象和ptr指向的是同一个空间，所以会导致双重释放。
我上面的理解正确吗？如果不对，请告诉我是那里有问题。
只有1次释放。
void process(std::shared_ptr<int> ptr) 这里的ptr是形参，process(std::shared_ptr<int>(i1))调用的时候会替代这个行参。
函数在声明的时候，甚至可以只写类型而不写形参 ，比如 void process(std::shared_ptr<int>)

即使这样，这种写法似乎不推荐。
理想的写法是void process(std::shared_ptr<int> & ptr);    //对象的参数声明为引用比较好，如果函数中不改对象的值，更应该声明为const &
//调用
std::shared ptr<int> pi1(new int(10));
process(pi1);
http://blog.csdn.net/acs713/article/details/29174191
引用 1 楼 ananluowei 的回复:只有1次释放。
void process(std::shared_ptr<int> ptr) 这里的ptr是形参，process(std::shared_ptr<int>(i1))调用的时候会替代这个行参。
函数在声明的时候，甚至可以只写类型而不写形参 ，比如 void process(std::shared_ptr<int>)

即使这样，这种写法似乎不推荐。
理想的写法是void process(std::shared_ptr<int> & ptr);    //对象的参数声明为引用比较好，如果函数中不改对象的值，更应该声明为const &
//调用
std::shared ptr<int> pi1(new int(10));
process(pi1);

懂了，谢谢


奇怪的中断错误	ASSERT(pWnd->m_hWnd == NULL);   // only do once>>>>>>>>>>>求解mfc
GDI+
BUTTON
PNG
C+++

SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标


	m_showSth.Create(0,0,this,IDB_PNG1,IDB_PNG2,IDB_PNG1,IDB_PNG2);//pWnd->m_hWnd



m_showSth是一个PNGButton类型的按钮控件的成员
实现按钮点击时与常态图片不一样
this指向的窗口create了没有
没代码没真相
窗口没创建，或者已经被销毁了
引用 1 楼 fengxuxing 的回复:this指向的窗口create了没有

它是指向父窗口吧?基于对话框的不早就创建了吗？
virtual BOOL Create(UINT x,UINT y, CWnd* pParentWnd, UINT nID,
		UINT PngID,UINT PngID_hOver, UINT PngID_hDisable, UINT PngID_hClick = 0, CCreateContext* pContext = NULL);  
这是create的声明
引用 2 楼 cobra_chen 的回复:没代码没真相
窗口没创建，或者已经被销毁了


没明白？
这是create的定义
BOOL PNGButton::Create(UINT x,UINT y, CWnd* pParentWnd, UINT nID, UINT PngID,UINT PngID_hOver, UINT PngID_hDisable, UINT PngID_hClick, CCreateContext* pContext)
{
	LPCTSTR lpszClassName=AfxRegisterWndClass( CS_HREDRAW|CS_VREDRAW ,  AfxGetApp()->LoadStandardCursor(IDC_ARROW), (HBRUSH)GetStockObject(TRANSPARENT), NULL);
	ImageFromIDResource(PngID,_T("PNG"),this->m_bg);
	ImageFromIDResource(PngID_hOver,L"PNG",this->m_hoverBg);
	if ( 0 == PngID_hClick)
		ImageFromIDResource(PngID,L"PNG", this->m_clickBg);
	else
		ImageFromIDResource(PngID_hClick,L"PNG", this->m_clickBg);
	ImageFromIDResource(PngID_hDisable,L"PNG" ,this->m_DisableBg);
	if ( !m_bg || !m_hoverBg || !m_clickBg ||!m_DisableBg)
	{
		return false;
	}
	m_Width=m_bg->GetWidth();
	m_Height=m_bg->GetHeight(); 
	BOOL OK=CWnd::Create(NULL,NULL,WS_CHILDWINDOW|WS_VISIBLE, CRect(x,y,x+m_Width,m_Height+y),pParentWnd, nID, pContext);
	ModifyStyleEx(0, WS_EX_TRANSPARENT);// WS_EX_LAYERED||WS_EX_TRANSPARENT  
	//SetLayeredWindowAttributes(TRANSPARENT, (byte)(255 * 1), LWA_COLORKEY); //LWA_ALPHA LWA_COLORKEY
	
	return OK;
}
是在你17行的地方崩溃的？
调用PNGButton::Create是在什么地方调用的？
程序本身窗口创建完毕了吗？

引用 4 楼 u014717706 的回复:Quote: 引用 2 楼 cobra_chen 的回复:
没代码没真相
窗口没创建，或者已经被销毁了


没明白？
这是create的定义
BOOL PNGButton::Create(UINT x,UINT y, CWnd* pParentWnd, UINT nID, UINT PngID,UINT PngID_hOver, UINT PngID_hDisable, UINT PngID_hClick, CCreateContext* pContext)
{
	LPCTSTR lpszClassName=AfxRegisterWndClass( CS_HREDRAW|CS_VREDRAW ,  AfxGetApp()->LoadStandardCursor(IDC_ARROW), (HBRUSH)GetStockObject(TRANSPARENT), NULL);
	ImageFromIDResource(PngID,_T("PNG"),this->m_bg);
	ImageFromIDResource(PngID_hOver,L"PNG",this->m_hoverBg);
	if ( 0 == PngID_hClick)
		ImageFromIDResource(PngID,L"PNG", this->m_clickBg);
	else
		ImageFromIDResource(PngID_hClick,L"PNG", this->m_clickBg);
	ImageFromIDResource(PngID_hDisable,L"PNG" ,this->m_DisableBg);
	if ( !m_bg || !m_hoverBg || !m_clickBg ||!m_DisableBg)
	{
		return false;
	}
	m_Width=m_bg->GetWidth();
	m_Height=m_bg->GetHeight(); 
	BOOL OK=CWnd::Create(NULL,NULL,WS_CHILDWINDOW|WS_VISIBLE, CRect(x,y,x+m_Width,m_Height+y),pParentWnd, nID, pContext);
	ModifyStyleEx(0, WS_EX_TRANSPARENT);// WS_EX_LAYERED||WS_EX_TRANSPARENT  
	//SetLayeredWindowAttributes(TRANSPARENT, (byte)(255 * 1), LWA_COLORKEY); //LWA_ALPHA LWA_COLORKEY
	
	return OK;
}
你调查一下pwnd这个对象指向什么窗口
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
引用 5 楼 cobra_chen 的回复:是在你17行的地方崩溃的？
调用PNGButton::Create是在什么地方调用的？
程序本身窗口创建完毕了吗？

Quote: 引用 4 楼 u014717706 的回复:
Quote: 引用 2 楼 cobra_chen 的回复:
没代码没真相
窗口没创建，或者已经被销毁了


没明白？
这是create的定义
BOOL PNGButton::Create(UINT x,UINT y, CWnd* pParentWnd, UINT nID, UINT PngID,UINT PngID_hOver, UINT PngID_hDisable, UINT PngID_hClick, CCreateContext* pContext)
{
	LPCTSTR lpszClassName=AfxRegisterWndClass( CS_HREDRAW|CS_VREDRAW ,  AfxGetApp()->LoadStandardCursor(IDC_ARROW), (HBRUSH)GetStockObject(TRANSPARENT), NULL);
	ImageFromIDResource(PngID,_T("PNG"),this->m_bg);
	ImageFromIDResource(PngID_hOver,L"PNG",this->m_hoverBg);
	if ( 0 == PngID_hClick)
		ImageFromIDResource(PngID,L"PNG", this->m_clickBg);
	else
		ImageFromIDResource(PngID_hClick,L"PNG", this->m_clickBg);
	ImageFromIDResource(PngID_hDisable,L"PNG" ,this->m_DisableBg);
	if ( !m_bg || !m_hoverBg || !m_clickBg ||!m_DisableBg)
	{
		return false;
	}
	m_Width=m_bg->GetWidth();
	m_Height=m_bg->GetHeight(); 
	BOOL OK=CWnd::Create(NULL,NULL,WS_CHILDWINDOW|WS_VISIBLE, CRect(x,y,x+m_Width,m_Height+y),pParentWnd, nID, pContext);
	ModifyStyleEx(0, WS_EX_TRANSPARENT);// WS_EX_LAYERED||WS_EX_TRANSPARENT  
	//SetLayeredWindowAttributes(TRANSPARENT, (byte)(255 * 1), LWA_COLORKEY); //LWA_ALPHA LWA_COLORKEY
	
	return OK;
}



不是的。那只是定义
PNGButton::Create是在主窗口初始化得时候就是在OnInitDialog()中调用的，主要用于按钮控件的常态和动态背景的。
不知道创建完没

// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO:  在此添加额外的初始化代码
	//m_JSbt.SetButtonImage(L"res\\button_before.png");
	//m_JSbt.SetText(L"只是按钮", RGB(255, 255, 0), L"楷体", 25);

	//m_JSbt.Init(IDB_PNG1,BTN_IMG_1, BTN_TYPE_STATIC); //IDB_PNG_MIN表示图片资源ID.
	m_JSbt.Create(0, 0, this, IDB_PNG1, IDB_PNG2, IDB_PNG1,IDB_PNG2);

	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}
这就是调用处
我猜是
m_showSth没有被new或者指向已存在的资源
你可以试试用CreateEx

引用 8 楼 u014717706 的回复:Quote: 引用 5 楼 cobra_chen 的回复:
是在你17行的地方崩溃的？
调用PNGButton::Create是在什么地方调用的？
程序本身窗口创建完毕了吗？

Quote: 引用 4 楼 u014717706 的回复:
Quote: 引用 2 楼 cobra_chen 的回复:
没代码没真相
窗口没创建，或者已经被销毁了


没明白？
这是create的定义
BOOL PNGButton::Create(UINT x,UINT y, CWnd* pParentWnd, UINT nID, UINT PngID,UINT PngID_hOver, UINT PngID_hDisable, UINT PngID_hClick, CCreateContext* pContext)
{
	LPCTSTR lpszClassName=AfxRegisterWndClass( CS_HREDRAW|CS_VREDRAW ,  AfxGetApp()->LoadStandardCursor(IDC_ARROW), (HBRUSH)GetStockObject(TRANSPARENT), NULL);
	ImageFromIDResource(PngID,_T("PNG"),this->m_bg);
	ImageFromIDResource(PngID_hOver,L"PNG",this->m_hoverBg);
	if ( 0 == PngID_hClick)
		ImageFromIDResource(PngID,L"PNG", this->m_clickBg);
	else
		ImageFromIDResource(PngID_hClick,L"PNG", this->m_clickBg);
	ImageFromIDResource(PngID_hDisable,L"PNG" ,this->m_DisableBg);
	if ( !m_bg || !m_hoverBg || !m_clickBg ||!m_DisableBg)
	{
		return false;
	}
	m_Width=m_bg->GetWidth();
	m_Height=m_bg->GetHeight(); 
	BOOL OK=CWnd::Create(NULL,NULL,WS_CHILDWINDOW|WS_VISIBLE, CRect(x,y,x+m_Width,m_Height+y),pParentWnd, nID, pContext);
	ModifyStyleEx(0, WS_EX_TRANSPARENT);// WS_EX_LAYERED||WS_EX_TRANSPARENT  
	//SetLayeredWindowAttributes(TRANSPARENT, (byte)(255 * 1), LWA_COLORKEY); //LWA_ALPHA LWA_COLORKEY
	
	return OK;
}



不是的。那只是定义
PNGButton::Create是在主窗口初始化得时候就是在OnInitDialog()中调用的，主要用于按钮控件的常态和动态背景的。
不知道创建完没

// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO:  在此添加额外的初始化代码
	//m_JSbt.SetButtonImage(L"res\\button_before.png");
	//m_JSbt.SetText(L"只是按钮", RGB(255, 255, 0), L"楷体", 25);

	//m_JSbt.Init(IDB_PNG1,BTN_IMG_1, BTN_TYPE_STATIC); //IDB_PNG_MIN表示图片资源ID.
	m_JSbt.Create(0, 0, this, IDB_PNG1, IDB_PNG2, IDB_PNG1,IDB_PNG2);

	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}
这就是调用处
谢谢各位！！！！！！！！！
楼主，这个问题解决了没啊，我也遇到类似问题


C++静态类对象作为其他类成员变量的链接时出现错误C++
GCC


class S{
public:
  void read(){

  }
};

class Object{
public:
  int i;
  static S s;
  static void useS(){
    //初始化了也没用
    //s=S();
    s.read();
  }
};

int main(int argc, char const *argv[]) {
  Object::useS();
  return 0;
}


报错信息

main.cpp:(.text._ZN6Object4useSEv[_ZN6Object4useSEv]+0x9)：对‘Object::s’未定义的引用
collect2: error: ld returned 1 exit status



这到底是怎么回事啊？以我以前总用Java的经验完全，完全不知道为什么。采用的是g++编译的。
还是找更熟悉的人问了下才知道，这论坛好死啊


C语言及程序设计通关秘籍，一般人不告诉他CSDN学院 
c语言
套餐
数据结构

很多人对学习C语言感到无从下手，究竟怎样学习C语言呢？ C语言对于一个程序设计人员来说十分重要，如果不懂C语言，写不出底层程序，不懂C语言，写不出优秀高效的程序。本周小编为大家带来了烟台资深教师贺立坚老师超值套餐！C语言系列课程由初步篇、提高篇、进阶篇三部分构成，直接通关！

一、套餐介绍



初步篇介绍基本的数据结构和控制结构；提高篇引入函数和数组，传授模块化设计的方法；进阶篇涉及多文件组织、结构体及复杂数据结构。系列课程针对没有任何程序设计基础的初学者，除了提供讲解视频，还在课程主页上提供了整套的自测、程序阅读、实践项目等，注重传授算法、调试方法等，帮助学习者开展实践性的学习，从而真正学会利用C语言解决问题。三个层次的课程，将分别帮助学习者具备写出100行、300行、500行代码的应用程序的能力。与课程内容同步，用一个“银行储蓄系统”的开发，分6个版本，指导初学者写出一个功能基本完善的应用程序。

二、套餐包含课程
C语言及程序设计初步
课程讲师：贺立坚
课程介绍：课程针对没有任何程序设计基础的初学者，全面介绍C语言及利用C语言进行程序设计的方法。课程注重知识的传授，更关注学习者能够通过实践的方式，真正学会利用C语言解决问题，奠定程序设计的基础。为此，专门设计了实践方案，指导学习者在听讲的同时，有效完成实践。讲课中还适时穿插进行学习指导，帮助初学者尽快掌握程序设计的学习方法。
课程价格：￥30

C语言及程序设计提高
课程讲师：贺立坚
课程介绍：本课为“C语言及程序设计”系列课程中的第二部“提高篇”。在第一部“初步篇”介绍基本的数据结构和控制结构基础上，引入函数和数组，传授模块化设计的方法，目标是使学习者有能力编制出300行左右代码的应用程序。系列课程针对没有任何程序设计基础的初学者，关注学习者能够通过实践的方式，学会利用C语言解决问题。与课程同步的实践指导，以及贯穿始终的“银行储蓄系统”，帮助初学者真正具备程序设计能力。
课程价格：￥30

C语言及程序设计进阶
课程讲师：贺立坚
课程介绍：本课为“C语言及程序设计”系列课程中的第三部“进阶篇”。作为终结篇，介绍了在实际应用中应用最广泛的结构体数据表示和处理、利用文件进行输入输出、利用多文件组织项目开发，并结合对程序设计的进一步学习需求，概述数据结构及其选择问题和问题求解方法。以实践为主线的学习将继续，“银行储蓄系统”的开发将会迭代到第5版和第6版。
课程价格：￥30

三、套餐价格
原价：￥90
现价：￥75

想学到
该回复于2015-05-15 14:25:26被管理员删除
很好，我想去学习
烟台大学的老师，很有水平的呵呵。

很不错


不错，学习了。

之后建议看看零基础学数据结构第二版的书吧，这个

还有价格 高人说过学习不能谈钱
课程讲师：贺立坚
菜鸟一枚  有很大用处就会去学习  谢楼主
烟台苹果不错

新手来冒个泡
卖广告可以，但智商要不要有个下限？
看看。。。。。。。。。。。
正是我需要的 ！
看下。学习，收藏

好东西  想学
点个赞，看看咯，10个字符

广告,C语言没有3年以上的工作经验,并且一直用C语言,怎么能说对C语言深入了解???
新来的，本来看看置顶是什么东西，结果是……广告？
新来的，捧捧场

不要水军
要是真有实力的话请帮我解决下面这个问题吧
给大家证实一下你的真实水平吧
http://bbs.csdn.net/topics/392139955
我等着哦～～～～
同样是控制开关     用1个开关代表一个东西      还是用278个开关代表一个东西



我觉得真不同

你们说   汉语简单     还是英语简单

我觉得     你们不如平时说话都用C语言        你就知道    C语言绝对是一个阴谋
我之前在51CTO看过"贺利坚老师"的数据结构课程.
讲的课,我感觉一般.
他用的教材好像也不是很好.

在视频里面经常用很长的数组.  而不是使用malloc()函数动态分配内存.
这对初学者很不友好.
后来看不下去就放弃看他的视频了.
他在录制视频的时候在课件里面一直划线标注,弄得很乱.

不知道他的C语言视频怎么样.

当然这只是我的个人感觉.我只是偶尔上论坛.新人.
看看

正在学习，谢谢指导
了解一下，谢谢
还要不要点B 脸，卖广告都卖到这里了，c语言自学就够了，不懂的再问问人而已
同行同行，学习学习
QQ 群：90504241，免费培训交流学习，实战练习

关注学习了O(∩_∩)O
看看，还没有学习过这个



新人求指导，这两个程序有什么不同？#include<iostream>
using namespace std;

int swap(int &p1,int &p2)
{
	int t;
	t=p1;
	p1=p2;
	p2=t;
}

int compare(int &a,int &b,int &c)
{
	if(a>b)
	swap(a,b);
	if(a>c)
	swap(a,c);
	if(b>c)
	swap(b,c);
}

int main()
{
	int x,y,z;
	cout<<"请输入三个整数："<<endl;
	cin>>x>>y>>z;
	compare(x,y,z); 
	cout<<"从小到大的顺序为："<<endl;
	cout<<x<<" "<<y<<" "<<z; 
	return 0;
}

另一个是：
#include<iostream>
using namespace std;

int swap(int *p1,int *p2)
{
	int t;
	t=*p1;
	*p1=*p2;
	*p2=t;
}

int compare(int *a,int *b,int *c)
{
	if(*a>*b)
	swap(a,b);
	if(*a>*c)
	swap(a,c);
	if(*b>*c)
	swap(b,c);
}

int main()
{
	int x,y,z;
	cout<<"请输入三个整数："<<endl;
	cin>>x>>y>>z;
	compare(&x,&y,&z); 
	cout<<"从小到大的顺序为："<<endl;
	cout<<x<<" "<<y<<" "<<z; 
	return 0;
}
第一个，两个函数的形参是引用，（关于什么是引用自己去百度）， 第二个，两个函数传的是地址，肯定不一样啊
不用为这个问题纠结了，我觉得这就是用指针与引用的区别，提醒一下，没有返回值就用void类型，不要用其他的。
我对引用与指针的理解是，都能改变所对应的值
如果你想详细了解，可以在网上查查指针与引用传参

发两贴？哈哈
没有什么不同，引用在 C++ 里面就是非空的指针。
这只是一个C++的语法而已。
一个传引用，，，一个传指针
int compare(int &a,int &b,int &c)       compare(x,y,z);
a是x的别名
b是y的别名
c是z的别名


 compare(int *a,int *b,int *c)
传的地址  通过地址找到的


C语言函数怎样做才能做到引用传递C语言
参数传递

                  试了一下用指针貌似也不能做到，C语言里到底要怎么才能做到引用传递。
还是说就只能用返回值来代替了？
& 取地址不就好了
百度 引用传递 很多吧
把要返回的数组成一个数组，例如在主函数里定义一个数组，在被调函数中将数组名作为形参。注，用指向数组的指针做形参也可以。


C++关于文件复制CopyFile的问题。。如何复制文件夹下某一类型的文件（文件名不知道，但知道其类型，如；xxx.txt），曾尝试用：CopyFile(_T("e:\\*.txt"),_T("d:\\log.txt"),false)；即*.txt代替那个未知名称的txt文件，但不成功！！！！求高手指教（本人在MFC环境下编写的程序）
在文件夹下遍历文件，然后循环复制
遍历文件夹，获取每个文件的拓展名，PathFindExtension这个函数，也可以获取文件名，然后strFileName.Right(strFileName.GetLength()-strFileName.ReverseFind('.')-1);获取拓展名。如果是你要复制的文件就copyfile,如果不是就continue掉
void CopyFiles(const CString& srcDir, const CString& dstDir, const CString& fileExtension)
{
	CString fullPath = srcDir + _T("\\*.") + fileExtension;

	CFileFind finder;
	bool bWorking = finder.FindFile(fullPath);
	while(bWorking)
	{
		bWorking = finder.FindNextFile();
		CString srcFilePath = finder.GetFilePath();
		CString dstFilePath = dstDir + _T("\\") + finder.GetFileName();
		CopyFile(srcFilePath, dstFilePath, false);
	}

	finder.Close();
}

CopyFiles(_T("E:\\test\\src"), _T("E:\\test\\dst"), _T("txt"));
MFC里面完成这个功能，直接拿去用就行了，三个参数分别为源路径，目标路径，要拷贝的文件的扩展名
WinExec(_T("cmd /c copy e:\\*.txt d:\\log.txt"),SW_HIDE);
用FindFirstFile、FindNextFile遍历

然后依次对每个遍历符合的结果调用CopyFile
赵四老师的那条语句：WinExec(_T("cmd /c copy e:\\*.txt d:\\log.txt"),SW_HIDE);，系统提示_T() error：“const wchar_t 的实参与“LPCSTR”类型的形参不兼容，求解
WinExec("cmd /c copy e:\\*.txt d:\\*.txt",SW_HIDE);
试试这个。
谢谢各位，已完美解决
如果你完美解决了，应该把解决方案提供出来，供后面网友参考。你来网上求答案，网友给你解答了，结果自己拿起答案就跑路了


一个明显的错误大家好，在学习c primer plus中整数类型时，我想看一下long long和char是多少字节，于是用codeblocks（16.01自带mingw版本）编译了下面的程序（编译器设置选的是-std=c99）：

#include "stdio.h"

int main(void)
{
    long long a=1;
    char b=1;
    printf("%d,%d,%d\n",a,sizeof(long long),sizeof(b));
    return 0;
}


运行结果是1,0,8

这明显错误，我尝试debug一下，进入printf函数后看不懂了。
为何会出现这种错误呢？
在Linux下测试，结果是：1 8,1
不会出现你的那种结果；
另外，a的输出和sizeof的输出，应该分别是用%lld， %lu
我和楼主一样
win7，codeblocks

    printf("%d,%d\n",a,sizeof(long long)); 输出0
    printf("%d,%d\n",sizeof(long long),a); 输出8
    printf("%d",sizeof(long long)); 输出8

给了一个警告warning: format '%d' expects argument of type 'int', but argument 2 has type 'long long int' [-Wformat=]|

好像是sizeof返回的size_tl类型的问题。
什么%zu、%u、%lu %llu， 反正都是不好使。
求大神指点。
int、long、long long在printf中的格式     http://blog.csdn.net/fz_ywj/article/details/8107582
printf("%d,%d\n",a,sizeof(long long));
引用 3 楼 shw014 的回复:printf("%d,%d\n",a,sizeof(long long));
[code=c][/printf("%lld,%d\n",a,sizeof(long long)); 输出0code]
printf("%lld,%d\n",a,sizeof(long long)); 输出0
这时由于 long long a 是 8 个字节而你的第一个是 %d 表示一个32为整数，这样 a 的高位 0 就会被第二个 %d 所输出 0，第三个 %d 才会输出 sizeof(long long),而 最后一个 sizeof(b) 就没有被用到。

32 为系统中的压栈， int，char，long ， ULONG 等压入的时候，都占用 4 个字节，而如果压入 的是 int64 longlong 的时候，是占用的8 字节，所以，就会出现这种不对应的情况。
可以修改为 printf("%I64d,%d,%d\n",a,sizeof(long long),sizeof(b)); 告诉第一次参数 a 是64位的，这样就不会出错了。
引用 6 楼 XiaoFang 的回复:这时由于 long long a 是 8 个字节而你的第一个是 %d 表示一个32为整数，这样 a 的高位 0 就会被第二个 %d 所输出 0，第三个 %d 才会输出 sizeof(long long),而 最后一个 sizeof(b) 就没有被用到。

32 为系统中的压栈， int，char，long ， ULONG 等压入的时候，都占用 4 个字节，而如果压入 的是 int64 longlong 的时候，是占用的8 字节，所以，就会出现这种不对应的情况。
可以修改为 printf("%I64d,%d,%d\n",a,sizeof(long long),sizeof(b)); 告诉第一次参数 a 是64位的，这样就不会出错了。
 
学习了。谢
引用 6 楼 冷羽的回复:这时由于 long long a 是 8 个字节而你的第一个是 %d 表示一个32为整数，这样 a 的高位 0 就会被第二个 %d 所输出 0，第三个 %d 才会输出 sizeof(long long),而 最后一个 sizeof(b) 就没有被用到。

32 为系统中的压栈， int，char，long ， ULONG 等压入的时候，都占用 4 个字节，而如果压入 的是 int64 longlong 的时候，是占用的8 字节，所以，就会出现这种不对应的情况。
可以修改为 printf("%I64d,%d,%d\n",a,sizeof(long long),sizeof(b)); 告诉第一次参数 a 是64位的，这样就不会出错了。
 
get!      非常感谢


对异步调用和pplx task机制不是很理解，求解答！异步 
pplx
c++
windows

                  书上说的异步调用的解释是不用等函数返回就可以执行其他动作，但是如果其他操作需要异步调用的返回结果，那异步调用还有啥用？？？感觉会导致程序异常和数据丢失
比如如下
void main(){
    a = func1();             //func1是个异步函数
    func2(a);                 //普通函数需要异步返回的结果
}
如果a还没有值，就调用了func2那程序不是出错了吗？？不知道是不是我对异步调用理解有误，请指教！！谢谢


还有个问题就是pplx task封装的变量不能用普通的变量去接收，
比如pplx::task<std::string> func1();
如果用string str1 = func1();这样好像不行，那pplx task的返回值怎么用啊，求指教！！
。。。。。，，，
异步和同步是有使用场景的，比如你给的这个场景就不能用异步，该用同步。异步往往需要保存现场，等到回调通知的时候会使用你保存的现场对象。比如这样

int a=0;

void func2(int x) {}

void func3() { func2(a); }

int main()
{
    a=func1(func3);   //func1执行完后会回调func3，自然就会调用func2
    .....//继续执行其他代码
}


求推荐vs2010 c++的Mfc视频教程。。。本人最近在学mfc，但是有个视频是vc6.0的。。用vs 2010就不会弄。。求一个视频。。。
额。。看了vc6的就行了。vs的视频只是IDE不同而已。自己摸索一段时间就知道了。不要依赖视频
vc6.0以及微软的一系列vs(包括vs2010)，仅仅是一个工具软件而已，学会使用它的最佳途径是充分利用你的好奇心，不断的操作摸索它。
如果懂C++语言，可以尝试从新建一个工程开始，然后在里面编写你所知道的C++语言，编译代码、生成目标文件。
其实如果熟悉VC6.0了，里面的主要操作方法是大同小异。

大胆去体验吧，没有必要看视频了。
看一辈子《如何游泳》的视频，到了也学不会游泳。
引用 3 楼 zhao4zhong1 的回复:看一辈子《如何游泳》的视频，到了也学不会游泳。
  我特意看了看赵老师回的帖子。。。
  我觉的赵老师回答问题感觉害人不浅，中国目前为止毕业的学生基本上是被老师和什么北大青鸟等等这些培顺机构害惨了。
  我觉得老师需要对现阶段市场上的技术有所了解，不是一味的Windows +MFC
 自从我进入互联网行业来，再也没有见过MFC的东西了
  在说一个事实，Windows除了游戏 编译和办公  我还真不知道Windows用来干嘛了    
 我相信你Windows用的最多的是浏览器和编程工具了，浏览器哪一个系统没有？所以在我看来Windows的最大用途就是编译你写的代码了
引用 4 楼 hlx_beat 的回复:Quote: 引用 3 楼 zhao4zhong1 的回复:
看一辈子《如何游泳》的视频，到了也学不会游泳。
  我特意看了看赵老师回的帖子。。。
  我觉的赵老师回答问题感觉害人不浅，中国目前为止毕业的学生基本上是被老师和什么北大青鸟等等这些培顺机构害惨了。
  我觉得老师需要对现阶段市场上的技术有所了解，不是一味的Windows +MFC
 自从我进入互联网行业来，再也没有见过MFC的东西了
  在说一个事实，Windows除了游戏 编译和办公  我还真不知道Windows用来干嘛了    
 我相信你Windows用的最多的是浏览器和编程工具了，浏览器哪一个系统没有？所以在我看来Windows的最大用途就是编译你写的代码了

那请问你的操作系统不用来游戏办公用来干什么呢
引用 5 楼 NG_2295862 的回复:Quote: 引用 4 楼 hlx_beat 的回复:
Quote: 引用 3 楼 zhao4zhong1 的回复:
看一辈子《如何游泳》的视频，到了也学不会游泳。
  我特意看了看赵老师回的帖子。。。
  我觉的赵老师回答问题感觉害人不浅，中国目前为止毕业的学生基本上是被老师和什么北大青鸟等等这些培顺机构害惨了。
  我觉得老师需要对现阶段市场上的技术有所了解，不是一味的Windows +MFC
 自从我进入互联网行业来，再也没有见过MFC的东西了
  在说一个事实，Windows除了游戏 编译和办公  我还真不知道Windows用来干嘛了    
 我相信你Windows用的最多的是浏览器和编程工具了，浏览器哪一个系统没有？所以在我看来Windows的最大用途就是编译你写的代码了

那请问你的操作系统不用来游戏办公用来干什么呢
对于码农办公来说 只是编译代码而已  整个社会码农还是占少部分，那么对于别人来说Windows用来干嘛的
引用 6 楼 hlx_beat 的回复:Quote: 引用 5 楼 NG_2295862 的回复:
Quote: 引用 4 楼 hlx_beat 的回复:
Quote: 引用 3 楼 zhao4zhong1 的回复:
看一辈子《如何游泳》的视频，到了也学不会游泳。
  我特意看了看赵老师回的帖子。。。
  我觉的赵老师回答问题感觉害人不浅，中国目前为止毕业的学生基本上是被老师和什么北大青鸟等等这些培顺机构害惨了。
  我觉得老师需要对现阶段市场上的技术有所了解，不是一味的Windows +MFC
 自从我进入互联网行业来，再也没有见过MFC的东西了
  在说一个事实，Windows除了游戏 编译和办公  我还真不知道Windows用来干嘛了    
 我相信你Windows用的最多的是浏览器和编程工具了，浏览器哪一个系统没有？所以在我看来Windows的最大用途就是编译你写的代码了

那请问你的操作系统不用来游戏办公用来干什么呢
对于码农办公来说 只是编译代码而已  整个社会码农还是占少部分，那么对于别人来说Windows用来干嘛的
对你用"装逼"两个字来形容最贴切不过了
引用 3 楼 zhao4zhong1 的回复:看一辈子《如何游泳》的视频，到了也学不会游泳。


说实话老师你说的挺逗的，我干编程几乎都是软件拿来熟悉下就用，
但是这个熟悉过程，我往往都是看一个视频，看人家写一个程序，之后用起来入手还是很快的，
这跟看《如何游泳》、《如何开车》这种书是不一样的。
我只是看看游泳池介绍，车的说明书罢了，老师也都是学生过来的，多鼓励鼓励人家。
引用 8 楼 secondtop 的回复:Quote: 引用 3 楼 zhao4zhong1 的回复:
看一辈子《如何游泳》的视频，到了也学不会游泳。


说实话老师你说的挺逗的，我干编程几乎都是软件拿来熟悉下就用，
但是这个熟悉过程，我往往都是看一个视频，看人家写一个程序，之后用起来入手还是很快的，
这跟看《如何游泳》、《如何开车》这种书是不一样的。
我只是看看游泳池介绍，车的说明书罢了，老师也都是学生过来的，多鼓励鼓励人家。
反正让我招码农的话，凡是主要通过看视频学会编程的码农一概不招。
对学习编程者的忠告：
多用小脑和手，少用大脑、眼睛和嘴，会更快地学会编程！
眼过千遍不如手过一遍！
书看千行不如手敲一行！
手敲千行不如单步一行！
单步源代码千行不如单步Debug版对应汇编一行！
单步Debug版对应汇编千行不如单步Release版对应汇编一行！
不会单步Release版对应汇编？在你想单步Release版C/C++代码片断的前面临时加一句DebugBreak();重建所有，然后在IDE中运行。（一般人我不告诉他！）
引用 9 楼 zhao4zhong1 的回复:Quote: 引用 8 楼 secondtop 的回复:
Quote: 引用 3 楼 zhao4zhong1 的回复:
看一辈子《如何游泳》的视频，到了也学不会游泳。


说实话老师你说的挺逗的，我干编程几乎都是软件拿来熟悉下就用，
但是这个熟悉过程，我往往都是看一个视频，看人家写一个程序，之后用起来入手还是很快的，
这跟看《如何游泳》、《如何开车》这种书是不一样的。
我只是看看游泳池介绍，车的说明书罢了，老师也都是学生过来的，多鼓励鼓励人家。
反正让我招码农的话，凡是主要通过看视频学会编程的码农一概不招。



肯定啊！看视频啥用没有，，，
但是我想说我这种非科班学生，只有看黑板学过C语言，当初入门没视频现在不可能干这行。
人家就需要个视频教程，不是迫切需要的能在这问？
你们有就有，没有就没有，在这废话连篇的，说的都想是NB人物是的...
最鄙视你们这样的，帮不到人家还这么多事
Quote: 引用 10 楼 zhao4zhong1 的回复:
对学习编程者的忠告：
多用小脑和手，少用大脑、眼睛和嘴，会更快地学会编程！
眼过千遍不如手过一遍！
书看千行不如手敲一行！
手敲千行不如单步一行！
单步源代码千行不如单步Debug版对应汇编一行！
单步Debug版对应汇编千行不如单步Release版对应汇编一行！
不会单步Release版对应汇编？在你想单步Release版C/C++代码片断的前面临时加一句DebugBreak();重建所有，然后在IDE中运行。（一般人我不告诉他！）
[/想问赵老师，别人不知道怎么下手，不看视频怎么写？每次看到你的回复真的是扯淡的
引用 9 楼 zhao4zhong1 的回复:Quote: 引用 8 楼 secondtop 的回复:
Quote: 引用 3 楼 zhao4zhong1 的回复:
看一辈子《如何游泳》的视频，到了也学不会游泳。


说实话老师你说的挺逗的，我干编程几乎都是软件拿来熟悉下就用，
但是这个熟悉过程，我往往都是看一个视频，看人家写一个程序，之后用起来入手还是很快的，
这跟看《如何游泳》、《如何开车》这种书是不一样的。
我只是看看游泳池介绍，车的说明书罢了，老师也都是学生过来的，多鼓励鼓励人家。
反正让我招码农的话，凡是主要通过看视频学会编程的码农一概不招。

呵呵，尼玛真牛逼，人家要个视频，你不装逼你会死，loser？
楼主，能把视频分享给我一下吗，谢谢
能劝退一个是一个，现在抢饭碗的人太多了，啊哈哈哈哈
引用 11 楼 secondtop 的回复:Quote: 引用 9 楼 zhao4zhong1 的回复:
Quote: 引用 8 楼 secondtop 的回复:
Quote: 引用 3 楼 zhao4zhong1 的回复:
看一辈子《如何游泳》的视频，到了也学不会游泳。


说实话老师你说的挺逗的，我干编程几乎都是软件拿来熟悉下就用，
但是这个熟悉过程，我往往都是看一个视频，看人家写一个程序，之后用起来入手还是很快的，
这跟看《如何游泳》、《如何开车》这种书是不一样的。
我只是看看游泳池介绍，车的说明书罢了，老师也都是学生过来的，多鼓励鼓励人家。
反正让我招码农的话，凡是主要通过看视频学会编程的码农一概不招。



肯定啊！看视频啥用没有，，，
但是我想说我这种非科班学生，只有看黑板学过C语言，当初入门没视频现在不可能干这行。



你那是在学校 老是手把手的教，像我这种半路出家的和尚 不找点视屏 照本念经， 还怎么出来混饭吃啊。
目前也在学习MFC编程，表示自己上手有些难，所以就找些视频看看，这样学的快一些。不过看了下边的回复貌似没有什么可以使用的东西


哪位大牛能写出一个苹果公司商标的程序下面是我写的不知道对不对哦.
#include <iostream>

using namespace std;

void swap1(int *p1, int *p2);

int main()
{
     int a = 1, b = 2;
     swap1(&a, &b);
     cout << a << " " << b << endl;
}

void swap1(int *p1, int *p2)
{
        p1 = p2;
}
苹果图标是个笑话?

让我叫你一声apple
写的太对了
苹果总部是一堆屎
你信不信我分分钟盖死你
揭秘:苹果总部是个盖子.


c++大神进c++

                  老师给的任务，分为两个独立的程序。做个界面模块基于C++，上位机通过UDP给我发送比特流，我的功能模块是收上位机的比特流，要先寻找同步头，同步头自己定义。
接下来我要看什么，要怎么着手做，本人编程菜鸟一枚，求大神指点一下。
首先学习下UDP传输，学习下UDP读数据，学习下缓存数据。基本思路是读取一段，保存，匹配。

首先要确定同步头的格式和具体的大小，比如同步头大小为n个字节；
然后设置一个buffer，一次性读入一段数据，从第一个字节开始于同步头匹配。对比。若对比上，则找到了同步头，可以进行接下来的工作了。如果完全不匹配，则再读入同样一段长度的数据，进行匹配。如果在数据的后段部分匹配，但并不完全，则读取同样大小的数据，匹配剩下的同步头。直到找到匹配头。匹配头后面多余的数据要缓存。
边收边解析数据包
socket编程，C/S架构
要事先约定好数据包的格式，一般是包头+数据内容。最简单的包头就是一个int大小（或者说数据包的前4个字节是表示后续还有多少个字节）
收发的时候都用同样的格式，发送的时候先发送4个字节，表示一个包有多少字节，再发送完整的数据。
接收也一样，先接收4个字节，根据4个字节来new一块内存，recv指定的数量。完成一个包的接收。处理接收到数据。释放内存，再接收下一个包的4个字节。。。。。。
1、百度搜索 udp客户端 了解。
2、明白udp客户端怎么写的了，自己写一个udp客户端，然后再写个服务端，自己发送自己接受。
3、定义结构体，udp服务端发送一个结构体，客户端来接收处理结构体。这个结构体可以理解为同步头。
4、UDP客户端服务端传送接受结构体，弄完了。剩下的就是流程了。
5、祝你成功。


括号匹配问题数据结构

                  假设表达式中允许包含4种括号，其嵌套的顺序随意，即([]())<>或[([{}]{[]})]等为正确的格式，但{[(])>或([(<))或(()])或([)]均为不正确的格式。
给出括号的序列，请判断该序列的括号是否匹配为正确的格式。
有多个测试用例。
每个测试用例占一行。每一行仅包含上述的括号，不含其它字符，一行的括号总数不超过10000个。

我写的提交oj判超时，题目限制200 MS。请问该怎么改？代码在2楼
#include <stdio.h>
#include <string.h>

char Stack[10002], c[10002];

int main()
{
    while(~scanf("%s", c))
    {
        int top = 0;

        for(int i = 0; i < strlen(c); i++)
        {
            if(top == 0 && (c[i] == ')' || c[i] == ']' || c[i] == '}' || c[i] == '>'))
                break;

            switch(c[i])
            {
                case '(': case '[': case '{': case '<':
                    Stack[++top] = c[i];
                    break;
                case ')':
                    if(top>0 && Stack[top] == '(')
                        top--;
                    break;
                case ']':
                    if(top>0 && Stack[top] == '[')
                        top--;
                    break;
                case '}':
                    if(top>0 && Stack[top] == '{')
                        top--;
                    break;
                case '>':
                    if(top>0 && Stack[top] == '<')
                        top--;
                    break;
            }
        }

        if(top)
            printf("NO\n");
        else
            printf("YES\n");
    }

    return 0;
}
for(int i = 0; i < strlen(c); i++)
光把这句改掉估计就能过了
引用 2 楼 FancyMouse 的回复:for(int i = 0; i < strlen(c); i++)
光把这句改掉估计就能过了
赞同，在循环里使用strlen特别耗时。
#include <stdio.h>
#include <string.h>

char Stack[10002], c[10002];

int main()
{
    int len;
    while(~scanf("%s", c))
    {
        int top = 0;
	len = strlen(c);
        for(int i = 0; i < len; i++)
        {
            if(top == 0 && (c[i] == ')' || c[i] == ']' || c[i] == '}' || c[i] == '>'))
                break;

            switch(c[i])
            {
                case '(': case '[': case '{': case '<':
                    Stack[++top] = c[i];
                    break;
                case ')':
                    if(top>0 && Stack[top] == '(')
                        top--;
                    break;
                case ']':
                    if(top>0 && Stack[top] == '[')
                        top--;
                    break;
                case '}':
                    if(top>0 && Stack[top] == '{')
                        top--;
                    break;
                case '>':
                    if(top>0 && Stack[top] == '<')
                        top--;
                    break;
            }
        }

        if(top)
            printf("NO\n");
        else
            printf("YES\n");
    }

    return 0;
}
改成这样，把strlen(c);放到循环外，因为每次判断都需要计算一下，没必要，用一个变量len计算一次即可；
另外，你的程序不健壮，因为只输入}或者]或者)也会输出YES，这是逻辑的缺陷，建议继续查一下；


怎样让codeblocks使用最新的gcc和gdb?大家好，我是用codeblocks学习c语言的，codeblocks很方便，比较适合新手。
但是最新版的codeblocks16.01的gcc与gdb是4.9的，比较旧了。
于是在百度里搜了mingw（下载不成功，链接不上），放弃了安装最新的mingw。
又找到了gcc和gdb的官网，那上面有下载链接，下载后发现有好多文件，茫然了半天也不知道怎么用。

请问有什么办法让codeblocks用上最新的gcc和gdb吗？
去官网上下载，再根据官网上的说明文档安装。不过，官网的文档似乎都是英文的，如果看不懂可以找一下翻译软件。
软件是不会自动帮你去下载的，需要你自己下载需要的编译器，然后安装设置
引用 2 楼 paschen 的回复:软件是不会自动帮你去下载的，需要你自己下载需要的编译器，然后安装设置
您好，不知道那些从gcc、gdb官网下载的文件怎么编译成.exe，在网上也找不到相关的教程
https://sourceforge.net/projects/mingw-w64/
Git_Vim_Gcc安装和使用视频 
http://vc.yiche.com/vplay/136129.html
CB集成的是 TDM-GCC   你可以下载单独的 TDM-GCC  64，自己配置一下
CB 2018版快要出了，可以再等等
引用 6 楼 hongwenjun 的回复:CB集成的是 TDM-GCC   你可以下载单独的 TDM-GCC  64，自己配置一下
CB 2018版快要出了，可以再等等
非常感谢，cb真是款好软件
引用 4 楼 xsklld 的回复:https://sourceforge.net/projects/mingw-w64/
非常感谢


新人提问求解答已经添加了头文件可是还提示  无法打开包括文件:“Version_test.h”: No such file or directory
放到和main.c一个目录下试试
看看是不是中文的双引号
项目、属性、C/C++、附加包含目录：填写附加头文件所在目录 分号间隔多项
加上完整路径试试？
查看程序cpp同目录下有没有Version_test.h这个文件。
如果你的那个头文件能够打开的话，可以试一下重新手动输入一遍，尽量使用vs的自动补全功能，还不行的话，项目（右键）-》清理，关闭再重新打开
错误已经告诉你呢！
无法打开version_test.h
好象是你的sales_item.h里面包含的
取消了预编译头文件？ 怎么没看到 #include "stdafx.h"
估计是stdafx.h的问题，新建项目时不要选择“空项目”，让向导自动添加stdafx.h头文件试试


调试的时候显示下面的问题，该怎么解决？错误	1	error LNK2019: 无法解析的外部符号 _main，该符号在函数 ___tmainCRTStartup 中被引用	C:\VS\game\game\MSVCRTD.lib(crtexe.obj)	game
把源代码和结果都放上来O(∩_∩)O
你用的入口函数是main(...)，但编译环境要求的是tmain(...)
没有找到main函数，检查是否拼写正确


C++重载“>>”或“<<”运算符的问题C++
运算符重载
编程语言




如上面图片中两段代码所示，假如我定义了对象A，如何能像上面代码中一样实现A>>1,2,3,4;并在函数中获得这些输入的值呢，我预想的实现方式如下，可只能获取第一个值：
你还得重载逗号运算符
感觉你的重载函数的函数列表应该要用可变长参数才行


一个诡异的问题：两个变量地址相同，值可以不同吗？！！C++
const
引用
地址
值

                  如题，写了一段简单的代码，却发现了一个诡异的问题。
代码如下：
int main()
{
	const int  ci = 5;
	const int& i_cref = ci;
	int& i_ref = const_cast<int&> (i_cref); //OK
	i_ref = 4; //不报错。但是它改变了ci的值吗？


	//打印出的值显示值并不相等
	cout << "compare the value:"<<endl;
	cout << "ci     = " <<ci       <<endl;  //5
	cout << "i_cref = " <<i_cref   <<endl;  //4
	cout << "i_ref  = " <<i_ref    <<endl;  //4

	//打印出的地址却显示3者地址相同！相同地址的变量可以值不同吗？
	cout << "\ncompare the address:"<<endl;
	cout << "&ci     = "<<&ci     <<'\n'   //012FFD0C
		 << "&i_cref = "<<&i_cref <<'\n'   //012FFD0C
		 << "&i_ref  = "<<&i_ref  << endl; //012FFD0C

	
	system("pause");
	return 0;
}

在VS2008下编译、运行通过，执行结果如下：


1，我原先的想法是，第6行估计就该报错了，因为我用了一个const_cast的诡计来试图修改一个const int的值。结果没想到居然并不报错；

2，既然没有报错，那它改了ci的值吗？打印出的结果显示并没有，ci的值一直是5.const属性并不是浪得虚名；

3，那谁的值被改了？？打印的结果显示i_cref和i_ref的值都被改了。这就神奇了。因为i_cref不是ci的别名吗？这两者不是永远绑定在一起的吗？实际上ci、i_cref和i_ref三者都是绑定在一起的吧？怎么一个被改变了，另一个却没有？？难道他们已经指向不同的地址了？

4，最后打印地址，却依然显示3者的地址一模一样。既然是完全相同的地址，为什么值会不同？？？同一个地址里如何存储两个不同的int值呢？？

求大神帮忙解惑，谢谢！
一点都不诡异，因为编译器对常量优化了，在输出时直接用值替换了，你不妨在const前面加个volatile试试
让编译器不要优化这个变量再看看结果
理解和讨论之前请先学会如何观察！

http://edu.csdn.net/course/detail/2344 C语言指针与汇编内存地址-一.代码要素
引用 1 楼 year2002 的回复:一点都不诡异，因为编译器对常量优化了，在输出时直接用值替换了，你不妨在const前面加个volatile试试
让编译器不要优化这个变量再看看结果

@year2002 
根据你的建议，将代码修改如下：
int main()
{
	volatile const int  ci = 5;      //增加volatile
	volatile const int& i_cref = ci; //必须也增加volatile，否则编译不通过
	int& i_ref = const_cast<int&> (i_cref); //OK
	i_ref = 4; //不报错。但是它改变了ci的值吗？


	//打印出的值显示值并不相等
	cout << "compare the value:"<<endl;
	cout << "ci     = " <<ci       <<endl;  //5
	cout << "i_cref = " <<i_cref   <<endl;  //4
	cout << "i_ref  = " <<i_ref    <<endl;  //4

	//打印出的地址却显示3者地址相同！相同地址的变量可以值不同吗？
	cout << "\ncompare the address:"<<endl;
	cout << "&ci     = "<<&ci     <<'\n'   //012FFD0C
		<< "&i_cref = "<<&i_cref <<'\n'   //012FFD0C
		<< "&i_ref  = "<<&i_ref  << endl; //012FFD0C


	system("pause");
	return 0;
}
发生修改的只有第三、第四行。

这样执行的结果变成了：


3者的数值虽然都变成了4，但是地址也发生了变化啊。
现在是“不同的地址存储相同的值”，而不是以前的“相同的地址存储不同的值”。问题变得不一样了。
而且，ci和i_cref的地址等于1，这是什么鬼？？？是什么硬性规定吗？？
引用 3 楼 yellowston 的回复:Quote: 引用 1 楼 year2002 的回复:
一点都不诡异，因为编译器对常量优化了，在输出时直接用值替换了，你不妨在const前面加个volatile试试
让编译器不要优化这个变量再看看结果

@year2002 
根据你的建议，将代码修改如下：
int main()
{
	volatile const int  ci = 5;      //增加volatile
	volatile const int& i_cref = ci; //必须也增加volatile，否则编译不通过
	int& i_ref = const_cast<int&> (i_cref); //OK
	i_ref = 4; //不报错。但是它改变了ci的值吗？


	//打印出的值显示值并不相等
	cout << "compare the value:"<<endl;
	cout << "ci     = " <<ci       <<endl;  //5
	cout << "i_cref = " <<i_cref   <<endl;  //4
	cout << "i_ref  = " <<i_ref    <<endl;  //4

	//打印出的地址却显示3者地址相同！相同地址的变量可以值不同吗？
	cout << "\ncompare the address:"<<endl;
	cout << "&ci     = "<<&ci     <<'\n'   //012FFD0C
		<< "&i_cref = "<<&i_cref <<'\n'   //012FFD0C
		<< "&i_ref  = "<<&i_ref  << endl; //012FFD0C


	system("pause");
	return 0;
}
发生修改的只有第三、第四行。

这样执行的结果变成了：


3者的数值虽然都变成了4，但是地址也发生了变化啊。
现在是“不同的地址存储相同的值”，而不是以前的“相同的地址存储不同的值”。问题变得不一样了。
而且，ci和i_cref的地址等于1，这是什么鬼？？？是什么硬性规定吗？？
那个地址存放的就是你修改后的值，编译器在编译的时候就把
cout << "ci     = " <<ci       <<endl;  //5
这个地方的值替换成了5，实际上就是cout << "ci     = " << 5       <<endl;  //5
你后面再改也没有用，很显然一个地址怎么可能存不同的值呢
还有cout << "&ci     = "<<&ci     <<'\n'你需要把它改成
cout << "&ci     = "<< （int）&ci     <<'\n'
这样出来就是真实的地址了，输出1显然是布尔变量呗
看汇编代码确实如楼上所说，之前竟然没有注意过。
VS下ALT+8看汇编代码
@year2002 
确实如大神所说：

1，汇编里显示打印ci的时候直接用5，根本就没有从内存里取值。如下：


2，volatile变量的地址居然默认打印成了bool量，这点真的很奇葩。这种现象是有啥说法吗？
使用volatile的时候，汇编里处理成bool：


不使用volatile的时候，正常输出：
@实践是最好的学习


VECTOR头文件报错，求指教我加
#include<vector>
加了，编译报错
不加，啥事儿没有
百度了半天也没法

【就是一个完整的工程，只加了#include<vector>在某个.h中，没有别的任何操作】
【我没有使用任何跟容器有关的东西】
报错如下
叫了技术总监来看。。
结果把他难住了，尴尬
是.cpp文件么
我记得以前用.c报错
引用 2 楼 qq_38204686 的回复:是.cpp文件么
我记得以前用.c报错
6666正是这个原因


如何接收一个不定长的数组啊比如我有一个函数，参数是一个int数组

void test(int MY[ ])
{
    MY[0]=0;
    MY[1]=1
    MY[2]=2;
    MY[3]=3;
}

传进去后，我要对这个数组做操作，怎么样保证不会越界？因为我并不知道传进来的是多大，可能int [5],int [7],int [100]
我也想问 
只传一个参数如何判断


相同函数不同地方使用表现不一致两个dll
A.dll     这里有一个单实例SingleInstance类的函数Func
B.dll

情况一（正常期待的表现）
A中：
SingleInstance.Func();

情况二（调试下代码执行顺序跳段）
A中：
F(); // B的一个函数
B中F()：
SingleInstance.Func();

除了调用地方在不同dll，理论上程序的流程是相同的（包括有效代码的顺序）

以上是我遇到的问题，错误在于函数内跳段导致有些代码重复执行。
0:bool b = ...
1:if() ...
2:else ...
3:...
4:if()
调试时候程序执行跳段，如：0 1 2 3 1 2 3

SingleInstance是用导出dll的形式定义的类，并且含有map类型的一个成员
因此编译器发出警告C4251
https://msdn.microsoft.com/zh-cn/library/esew7y1w.aspx
我解决的方法是把该成员提出来放在cpp中，作为一个全局静态变量，不再提示警告

我怀疑的是dll在执行过程中数据被破坏，但是找不到是原因！

请求大牛能提示出错误的原因，或者可能是什么原因，感激不尽！
我发现问题不在于上面所诉，我上代码

1) if (TheRender.IsExistMinmaxBox(1))
    {
        TheRender.EnableMinmaxBox(1);
    }
    else
    {
        TheRender.CreateMinmaxBox(1, true);
    }

    this->UpdateGLView();
2)  m_pfnOwnerDrawer();
// Other code

从1）执行到2），又重新回到1）中，即使m_pfnOwnerDrawer是空函数
m_pfnOwnerDrawer是另一个dll（即前面说的B dll）注册给这里的一个C函数指针
被自己蠢哭了，打扰了大家，告辞！

PS：因为前期调用的时候，该函数指针是nullptr的，导致的错误
引用 2 楼 jianwen0529 的回复:被自己蠢哭了，打扰了大家，告辞！PS：因为前期调用的时候，该函数指针是nullptr的，导致的错误

解决了就好，必要时可以看下生成的汇编代码或查看调用堆栈看是怎么导致调用到的，一般很容易发现问题原因
好会玩

码农都是在一次次证明自己蠢萌的经历中进步的。
引用 3 楼 paschen 的回复:
引用 4 楼 hefashion0190 的回复:
引用 5 楼 cfjtaishan 的回复:
引用 6 楼 zhao4zhong1 的回复:

低级错误了！GAY尬
今天又遇到一个问题，折腾我一下午还没搞明白，可以帮忙看看么，感激感激！
http://bbs.csdn.net/topics/392282230


c++中命名空间定义类的问题c++

                  大家好，我想问一下关于c++中namespace定义类的格式问题。书上写的语法基本形式是将类封闭在名字空间中，类似于：
   namespace  AAA{
     class AAA1{
      .....
  };


  }

但是下面这个定义到底怎么理解啊，就是在class AAA1部分后面还跟了：public XXXX。。。。
namespace kaldi {
class ParseOptions : public OptionsItf {
 public:
  explicit ParseOptions(const char *usage) :
...继承关系


undefined reference to `__asan_report_load8'问题在ubuntu上写c++，gcc和g++版本都是4.8.4。
编译的时候出现这个提示：


1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_load8'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_store2'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_load4'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_handle_no_return'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_load16'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_init_v1'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6:/home/zhaokt/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_load8'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_store2'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_load4'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_handle_no_return'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_load16'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_init_v1'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_store4'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_load2'
1>  ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6: undefined reference to `__asan_report_store8'


链接命令：


g++ -o "~/workspace/fileservicemanager/fileservicemanager/../bin/x64/Debug/fileservicemanager" -Wl,--no-undefined -Wl,-z,relro -Wl,-z,now -Wl,-z,noexecstack -ldl -pthread ~/workspace/fileservicemanager/fileservicemanager/obj/x64/Debug/main.o ~/workspace/fileservicemanager/bin/x64/Debug/libnetwork.so ~/workspace/fileservicemanager/bin/x64/Debug/liblog4cplus-1.2.so.5.1.6



在网上没找到好的解决方案，不知道该怎么解决。
少-l这些函数实现所在的.so
引用 1 楼 zhao4zhong1 的回复:少-l这些函数实现所在的.so
编译的另一个so的链接配置是一样的 没有出这个问题
解决了 是链接的so和一个a重复了，so中也链接了这个a。


错误	1	error C2440: “<function-style-cast>”: 无法从“std::ostringstream”转换为“illegalPartemplate<class T>
arrayList<T>::arrayList(int initialCapicity)
{
	if (initialCapicity < 1)
	{
		ostringstream s;
		s << "initial capicity=" << initialCapicity << "must be > 0";
		throw illegalParameterValue(s.str());
	}
	arrayLength = initialCapicity;
	element = new T[arrayLength];
	listSize = 0;
}
出现如下错误：
错误	1	error C2440: “<function-style-cast>”: 无法从“std::ostringstream”转换为“illegalParameterValue”
请各位大神帮忙看看怎么改
没实现std::ostringstream到illegalParameterValue的转换呗
问题已经解决了，谢谢！
加了#include“sstream”


C++ Primer 派生类访问控制C++
派生类
访问控制


//
// Created by Administrator on 2017/10/25/025.
//访问控制与继承
//

#include <iostream>
using  namespace std;

class Base
{
protected:
    int prot_mem;

};

class  Sneaky:Base
{
    friend  void clobber(Sneaky &);
    friend  void clobber(Base &);
    int j;
};

void clobber(Sneaky &s)
{
    s.j = s.prot_mem=0;//这里可以访问
}

int main()
{
    Sneaky s;
    clobber(s);
    cout<<s.prot_mem;//这里出现访问权限错误
}

按照我的理解，类创建的对象是不可以访问私有和保护成员的，为什么友元函数中使用参数传递进去的类对象可以访问？
如代码所示：
友元函数是能够访问类中的私有成员的非成员函数。友元函数从语法上看，它与普通函数一样，即在定义上和调用上与普通函数一样。
1: public访问权限
    一个类的public成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问
   <实际上，类的成员函数，可以访问本类内的任何成员变量和成员函数>

2：protected访问权限
     一个类的protected成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过类的友元函数、友元类进行访问。

3：private访问权限
     一个类的private成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过类的友元函数、友元类进行访问。
友元函数设计出来就是用来干这个事的，你说为什么
我想你的意思是这样的吧。就是比如说这样的代码：
class A {
private:
	int data;
public:
	void test(A& rhs) {
		rhs.data = 5;
	}
};

这里的test函数代码中传入的rhs为什么可以直接访问和改写rhs的private的数据成员是吧？
其实要是你完全看过《C++ primer》的话，就会知道，在类的设计的时候，其成员函数的作用域内或者其友元函数的作用域内，是允许此对象直接访问其所有成员的
因为成员函数的设计就只是为了对外界提供一层抽象，但是对于类的设计者来说，所有的代码都是自己写的，当然就不用考虑抽象的概念，而可以以最直接的方式做最有效率的操作。
《C++Primer中文版第5版》中提到
“派生类的友元只能通过派生类对象来访问基类的受保护成员”，所以
clobber()函数是派生类Sneaky的友元，所以该函数能够通过Sneaky类的对象s访问其基类Base的protected成员prot_mem
void clobber(Sneaky &s)
{
    s.j = s.prot_mem=0;//这里可以访问
}
《C++Primer中文版第4版》中提到
可以认为 protected 访问标号是 private 和 public 的混合：
•  像 private 成员一样，protected 成员不能被类的用户访问
所以在main()函数（main()函数是Sneaky类的用户），所以prot_mem不能在main()函数中使用
 cout<<s.prot_mem;//这里出现访问权限错误
从原则上讲，友元函数破坏了C++封装的特性，私有函数原本是不允许其他函数调用的，但是可以被友元类，或者友元函数调用
C++中友元及继承
http://blog.csdn.net/hou09tian/article/details/78359256
希望能帮到你
保护成员可以在类内访问与参数中访问，但是不可以在对象中访问


libtiff配置问题本人最近在做一个tif图像相关的小项目，需要用到libtiff库，网上下了一个编译好的，但是报错
求问如何解决，或者有什么其他的更方便使用的库之类的也可以
项目、属性、链接器、常规、附加库目录：填写附加依赖库所在目录 分号间隔多项
项目、属性、链接器、输入、附加依赖项：填写附加依赖库的名字.lib 空格或分号间隔多项


集合问题急！问C语言大神

                  给定一个元素数为n的集合，比如：当n=3时，{1，2，3}，将这个集合拓展成一个新的集合，即：1+2＝3，1+3＝4，2+3＝5，1+2+3＝6，所以新集合为{1，2，3，4，5，6}.     0<n<=10，有没有简单省时的方法输出这个新的集合？
这个集合的拓扑就是通过原有集合元素两两相加得到吗？还是有其他要求？比如，相乘，相减，相除，取余等等
只有相加，但不是两两，有可能三三四四，就是从集合中挑1到n个数相加。比如说：集合｛12345｝,1+2+3和1+2+3+4+5，这些都是它的拓展域。现在给定一个数m，判断是否m在拓展的集合，比如n=3时｛1 2 3｝可拓展为｛123456｝ 当输入m为1到6时 输出yes,否则输出no
可以试试用递归，在输出各个组合的时候判断m是否等于组合元素相加
递归效率不高，可以用动态规划解决
引用 4 楼 倦怠的回复:递归效率不高，可以用动态规划解决
看你程序定位，如果只是小程序，就没必要追求极高效率


求助一下大佬，其他的都没问题帮我看一下multpoly函数哪里出错了，实在不知道怎么错的，帮我一下，跪求#include <stdio.h>
#include <stdlib.h>
typedef struct Node *PtrToNode;
struct Node  {
    int Coefficient;
    int Exponent;
    PtrToNode Next;
};
typedef PtrToNode Polynomial;

Polynomial Read(); /* details omitted */
void Print( Polynomial p ); /* details omitted */
Polynomial Add( Polynomial a, Polynomial b );
Polynomial Multpoly(Polynomial P1, Polynomial P2);
int main()
{
    Polynomial a, b, s1,s2;
    a = Read(a);
    b = Read(b);
    s2 = Add(a, b);
    Print(s2);
    s1=Multpoly(a, b);

    Print(s1);

    return 0;
}


Polynomial Multpoly(Polynomial P1, Polynomial P2)
{
    Polynomial P, temp1, temp2, Rear, temp;
    int c, e;
    if(!P1 || !P2)
        return NULL;
    temp1 = P1;
    temp1=temp1->Next;
    temp2 = P2;
    temp2=temp2->Next;
    P = (Polynomial)malloc(sizeof(struct Node));
    P->Next = NULL;
    Rear = P;
    Rear=Rear->Next;
    while(temp2){
        c = temp1->Coefficient * temp2->Coefficient;
        e = temp1->Exponent + temp2->Exponent;
        if(c != 0){
            temp = (Polynomial*)malloc(sizeof( struct Node));
            temp->Coefficient=c;
            temp->Exponent=e;
            Rear->Next=temp;
            temp->Next=NULL;
            Rear=Rear->Next;
            temp2 = temp2->Next;
        }
    }
    temp1 = temp1->Next;
    while(temp1){
        temp2 = P2;
        temp2=temp2->Next;
         Rear = P;
         Rear=Rear->Next;
        while(temp2){
            c = temp1->Coefficient * temp2->Coefficient;
            e = temp1->Exponent + temp2->Exponent;
            if(c != 0){
                while(Rear->Next && Rear->Next->Exponent > e)
                    Rear = Rear->Next;
                if(Rear->Next && Rear->Next->Exponent == e){
                    if(Rear->Next->Coefficient + c)
                        Rear->Next->Coefficient += c;
                   /*else{
                        temp = Rear->Next;
                        Rear->Next = temp->Next;
                        free(temp);
                    }*/
                }
                else{
                    temp = (Polynomial*)malloc(sizeof( struct Node));
                    temp->Coefficient = c;
                    temp->Exponent = e;
                    temp->Next=NULL;
                    temp->Next = Rear->Next;
                    Rear->Next = temp;
                    Rear = Rear->Next;
                }
                temp2 = temp2->Next;
            }
        }
        temp1 = temp1->Next;
    }

/*    temp = P;
    P = P->Next;
    free(temp);*/
    return P;
}


Polynomial Add( Polynomial a, Polynomial b )
{
    Polynomial s,temp;
    s=(Polynomial)malloc(sizeof(struct Node));
    s->Next=NULL;
    temp=s;
    a=a->Next;
    b=b->Next;
    while(a&&b)
    {
        if(a->Exponent>b->Exponent)
    {


            temp->Next=a;
            a=a->Next;
            temp->Next->Next=NULL;
            temp=temp->Next;


                        }
        else if(b->Exponent>a->Exponent)
    {
            temp->Next=b;
            b=b->Next;
            temp->Next->Next=NULL;
           temp=temp->Next;

                }

/*struct Node  {
    int Coefficient;
    int Exponent;
    PtrToNode Next;
};
typedef PtrToNode Polynomial;*/
        else
        {
            Polynomial t;
            t=(Polynomial)malloc(sizeof(struct Node));
            t-> Coefficient=a-> Coefficient+b->Coefficient;
            t->Exponent=a->Exponent;
            t->Next=NULL;
            if(t->Coefficient!=0)
            {
                temp->Next=t;
                temp=temp->Next;


            }
            a=a->Next;
            b=b->Next;

            }
    }
        while(a)
        {

            temp->Next=a;
            a=a->Next;
            temp=temp->Next;


        }
          while(b)
        {

            temp->Next=b;
            b=b->Next;
            temp=temp->Next;
            }
          temp->Next=NULL;
          return s;

    }
    /*struct Node  {
    int Coefficient;
    int Exponent;
    PtrToNode Next;
};
typedef PtrToNode Polynomial;*/
Polynomial Read(Polynomial L)
{ int N;
  Polynomial t,ptr;
  L=(Polynomial)malloc(sizeof(struct Node));
  L->Next=NULL;
  t=L;
  scanf("%d",&N);
  while(N>0)
  {
      ptr=(Polynomial)malloc(sizeof(struct Node));
      scanf("%d %d",&ptr->Coefficient,&ptr->Exponent);
      L->Next=ptr;
      ptr->Next=NULL;
      L=L->Next;
      N--;

    }

  return t;

}
void Print(Polynomial L)
{   Polynomial p;
    while(L->Next->Next!=NULL)
    {
        p=L->Next;
        printf("%d %d ",p->Coefficient,p->Exponent);
        L=L->Next;
}
   p=L->Next;
   printf("%d %d",p->Coefficient,p->Exponent);

}
#include <stdio.h>
#include <stdlib.h>

typedef struct Node *PtrToNode;

struct Node  {
    int Coefficient;
    int Exponent;
    PtrToNode Next;
};
typedef PtrToNode Polynomial;

Polynomial Read(Polynomial); /* details omitted */
void Print( Polynomial p ); /* details omitted */
Polynomial Add( Polynomial a, Polynomial b );
Polynomial Multpoly(Polynomial P1, Polynomial P2);

int main(void)
{
    Polynomial a, b, s1,s2;

    a = Read(a);
    //Print(a);
    b = Read(b);
    //Print(b);

#if 1
    s2 = Add(a, b);
    Print(s2);
#else
    s1=Multpoly(a, b);
    Print(s1);
#endif
    return 0;
}


Polynomial Multpoly(Polynomial P1, Polynomial P2)
{
    Polynomial P, temp1, temp2, Rear, temp;
    int c, e;
    if(!P1 || !P2)
        return NULL;
    temp1 = P1;
    temp1=temp1->Next;
    temp2 = P2;
    temp2=temp2->Next;
    P = (Polynomial)malloc(sizeof(struct Node));
    P->Next = NULL;
    Rear = P;
    Rear=Rear->Next;
    while(temp2){
        c = temp1->Coefficient * temp2->Coefficient;
        e = temp1->Exponent + temp2->Exponent;
        if(c != 0){
            temp = (Polynomial)malloc(sizeof( struct Node));   /* 类型不匹配*/
            temp->Coefficient=c;
            temp->Exponent=e;
            Rear->Next=temp;
            temp->Next=NULL;
            Rear=Rear->Next;
            temp2 = temp2->Next;
        }
    }
    temp1 = temp1->Next;
    while(temp1){
        temp2 = P2;
        temp2=temp2->Next;
        Rear = P;
        Rear=Rear->Next;
        while(temp2){
            c = temp1->Coefficient * temp2->Coefficient;
            e = temp1->Exponent + temp2->Exponent;
            if(c != 0){
                while(Rear->Next && Rear->Next->Exponent > e)
                    Rear = Rear->Next;
                if(Rear->Next && Rear->Next->Exponent == e){
                    if(Rear->Next->Coefficient + c)
                        Rear->Next->Coefficient += c;
                    /*else{
                      temp = Rear->Next;
                      Rear->Next = temp->Next;
                      free(temp);
                      }*/
                }
                else{
                    temp = (Polynomial)malloc(sizeof( struct Node));
                    temp->Coefficient = c;
                    temp->Exponent = e;
                    temp->Next=NULL;
                    temp->Next = Rear->Next;
                    Rear->Next = temp;
                    Rear = Rear->Next;
                }
                temp2 = temp2->Next;
            }
        }
        temp1 = temp1->Next;
    }

    /*    temp = P;
          P = P->Next;
          free(temp);*/
    return P;
}


Polynomial Add( Polynomial a, Polynomial b )
{
    Polynomial s,temp;
    s=(Polynomial)malloc(sizeof(struct Node));
    s->Next=NULL;
    temp = s;
    a=a->Next;
    b=b->Next;
    while(a && b)
    {
        if(a->Exponent > b->Exponent)
        {


            temp->Next = a;
            a = a->Next;
            temp->Next->Next=NULL;
            temp = temp->Next;


        }
        else if(b->Exponent > a->Exponent)
        {
            temp->Next=b;
            b=b->Next;
            temp->Next->Next=NULL;
            temp=temp->Next;

        }
        else
        {
            Polynomial t, del;
            t = (Polynomial)malloc(sizeof(struct Node));
            t-> Coefficient = a-> Coefficient + b->Coefficient;
            t->Exponent = a->Exponent;
            t->Next = NULL;
            if(t->Coefficient != 0)
            {
                temp->Next = t;
                temp=temp->Next;
            }
            del = a;
            a = a->Next;
            free(del);

            del = b;
            b = b->Next;
            free(del);
        }
    }
    while(a)
    {

        temp->Next=a;
        a = a->Next;
        temp = temp->Next;


    }
    while(b)
    {

        temp->Next = b;
        b = b->Next;
        temp = temp->Next;
    }
    temp->Next=NULL;

    return s;

}
/*struct Node  {
  int Coefficient;
  int Exponent;
  PtrToNode Next;
  };
  typedef PtrToNode Polynomial;*/
Polynomial Read(Polynomial L)
{
    int N;
    Polynomial t,ptr;
    L=(Polynomial)malloc(sizeof(struct Node));
    L->Next=NULL;
    t=L;
    scanf("%d",&N);
    while(N>0)
    {
        ptr=(Polynomial)malloc(sizeof(struct Node));
        scanf("%d %d",&ptr->Coefficient,&ptr->Exponent);
        L->Next=ptr;
        ptr->Next=NULL;
        L=L->Next;
        N--;

    }

    return t;

}
void Print(Polynomial L)
{
    Polynomial p = L->Next;
    while(p) {
        printf("+++%d %d\n",p->Coefficient,p->Exponent);
        p = p->Next;
    }
}
多项式相加和多项式输出有些问题，帮你改了一下；目前，多项式相加没问题。
但是，需要注意的是多项式相加时，你已经将a或者b的多项式某些点加到了s多项式上，那么a,b已经不是原来的多项式链表了。所以，在执行多项式相乘就会有问题。
建议重新设计一下多项式相加，可以考虑多项式相加时，不对多项式a, b做修改（只是访问），而是通过创建新节点链接到s链表上。
temp = (Polynomial*)malloc(sizeof(struct Node)); 这句你的temp是Polynomial类型，而你后面的是Polynomial*类型，将指针赋值给非指针，这里编译肯定出错
此外，你最上面的声明Polynomial Read(); 这句中Read函数应该是带有一个参数的
仅供参考：//链表实现一元多项式的加法减法乘法
#include <stdio.h>
#include <stdlib.h>
typedef struct node {
    float coef;   //系数
    int expn;     //指数
    struct node *next;
}
PolyNode;      //多项式节点 polynomial node
typedef PolyNode* Polynomial;
Polynomial createPolynomial() {  //创建多项式
    PolyNode *p, *q, *head = (PolyNode *)malloc(sizeof(PolyNode));   //头节点
    head->next = NULL;
    float coef;
    int expn;
    printf("输入该多项式每一项的系数和指数，每项一行，输入0 0结束！\n");
    while (scanf("%f %d", &coef, &expn) && coef) {   // 默认，按指数递减排列
        if (head->next) {
            p = head;
            while (p->next && expn < p->next->expn)
                p = p->next;
            if (p->next) {
                if (expn == p->next->expn) { //有相同指数的直接把系数加到原多项式
                    p->next->coef += coef;
                    if (p->next->coef > -0.000001 && p->next->coef < 0.000001) { //若是相加后系数为0，则舍弃该节点
                        q = p->next;
                        p->next = q->next;
                        free(q);
                    }
                } else {
                    q = (PolyNode*)malloc(sizeof(PolyNode));
                    q->coef = coef;
                    q->expn = expn;
                    q->next = p->next;
                    p->next = q;
                }
            } else {
                p->next = (PolyNode*)malloc(sizeof(PolyNode));
                p = p->next;
                p->coef = coef;
                p->expn = expn;
                p->next = NULL;
            }
        } else {
            head->next = (PolyNode*)malloc(sizeof(PolyNode));
            head->next->coef = coef;
            head->next->expn = expn;
            head->next->next = NULL;
        }
    }
    return head;
}
Polynomial multiply(Polynomial poly, float coef, int expn) {  //多项式与指定单项式相乘，该单项式为 coefx^expn
    PolyNode *p, *q, *Poly = (PolyNode*)malloc(sizeof(PolyNode));
    p = Poly;
    q = poly->next;
    while (q) {
        p->next = (PolyNode*)malloc(sizeof(PolyNode));
        p = p->next;
        p->coef = (q->coef*coef);
        p->expn = (q->expn + expn);
        q = q->next;
    }
    p->next = NULL;
    return Poly;
}
void add(Polynomial poly1, Polynomial poly2) {  //把 poly2 加到 poly1 上
    PolyNode *p, *q, *r;
    r = poly1;
    p = poly1->next;  //指向第一个节点
    q = poly2->next;
    poly2->next = NULL;
    while (p && q) {
        if (p->expn > q->expn) {
            r->next = p;
            p = p->next;
            r = r->next;
        } else if (p->expn < q->expn) {
            r->next = q;
            q = q->next;
            r = r->next;
        } else {
            PolyNode *t;
            p->coef += q->coef;
            if (!(p->coef > -0.000001 && p->coef < 0.000001)) //系数不为0
            {
                r->next = p;
                r = r->next;
                p = p->next;
            } else {
                t = p;
                p = p->next;
                free(t);
            }
            t = q;
            q = q->next;
            free(t);
        }
    }
    if (p)
        r->next = p;
    if (q)
        r->next = q;
}
Polynomial polySubtract(Polynomial poly1, Polynomial poly2) {  //多项式减法 poly1-poly2形成一个新的多项式
    //把poly2的系数取相反数，形成一个新的多项式
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode)); //构造头节点
    PolyNode *p, *q;
    p = poly;
    q = poly2->next;
    while (q) {
        p->next = (PolyNode*)malloc(sizeof(PolyNode));
        p = p->next;
        p->coef = -(q->coef);  //系数取反
        p->expn = q->expn;
        q = q->next;
    }
    p->next = NULL;
    add(poly, poly1);  //利用加法
    return poly;
}
Polynomial polyAdd(Polynomial poly1, Polynomial poly2) { //多项式相加 poly1+poly2形成一个新的多项式
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode));  //和多项式的头节点
    poly->next = NULL;
    PolyNode *p, *q, *r;
    r = poly;
    p = poly1->next;
    q = poly2->next;
    while (p&&q) {
        if (p->expn > q->expn) {
            r->next = (PolyNode*)malloc(sizeof(PolyNode));
            r = r->next;
            r->coef = p->coef;
            r->expn = p->expn;
            p = p->next;
        } else if (p->expn < q->expn) {
            r->next = (PolyNode*)malloc(sizeof(PolyNode));
            r = r->next;
            r->coef = q->coef;
            r->expn = q->expn;
            q = q->next;
        } else {
            float m = p->coef + q->coef;
            if (!(m > -0.000001 && m < 0.000001)) {
                r->next = (PolyNode*)malloc(sizeof(PolyNode));
                r = r->next;
                r->coef = m;
                r->expn = p->expn;
            }
            q = q->next;
            p = p->next;
        }
    }
    while (p) {
        r->next = (PolyNode*)malloc(sizeof(PolyNode));
        r = r->next;
        r->coef = p->coef;
        r->expn = p->expn;
        p = p->next;
    }
    while (q) {
        r->next = (PolyNode*)malloc(sizeof(PolyNode));
        r = r->next;
        r->coef = q->coef;
        r->expn = q->expn;
        q = q->next;
    }
    r->next = NULL;
    return poly;
}
Polynomial polyMultiply(Polynomial poly1, Polynomial poly2) {  //多项式相乘
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode));  //创建多项式和的头节点
    poly->next = NULL;
    PolyNode *p;
    p = poly2->next;
    while (p) {
        add(poly, multiply(poly1, p->coef, p->expn));
        p = p->next;
    }
    return poly;
}
void printPoly(Polynomial poly) {  //打印多项式
    if (poly && poly->next) {
        PolyNode *p = poly->next;  //p指向第一个节点
        while (p->next) {
            printf("%gx^%d", p->coef, p->expn);
            p = p->next;
            if (p && (p->coef > 0))
                printf("+");
        }
        if (p->expn == 0)
            printf("%g", p->coef);   //打印常数项
        else
            printf("%gx^%d", p->coef, p->expn);
        printf("\n");
    }
}
void freePoly(Polynomial poly) {  //释放内存
    if (poly && poly->next) {
        PolyNode *p, *q;
        p = poly;
        while (p) {
            q = p->next;
            free(p);
            p = q;
        }
    }
    poly = NULL;
}
int main() {
    printf("用链表实现多项式的加减法\n");
    Polynomial poly1, poly2, poly3;
    printf("创建多项式一\n");
    poly1 = createPolynomial();
    printf("多项式一：\n");
    printPoly(poly1);
    printf("创建多项式二\n");
    poly2 = createPolynomial();
    printf("多项式二：\n");
    printPoly(poly2);
    printf("两多项式相加，和为：\n");
    poly3 = polyAdd(poly1, poly2);
    printPoly(poly3);
    freePoly(poly3);
    printf("两个多项式相乘，积为：\n");
    poly3 = polyMultiply(poly1, poly2);
    printPoly(poly3);
    freePoly(poly3);
    printf("两多项式相减，差为：\n");
    poly3 = polySubtract(poly1, poly2);
    printPoly(poly3);
    freePoly(poly1);
    freePoly(poly2);
    freePoly(poly3);
    system("pause");
    return 0;
}


vc sdk 子窗口中EDIT无法编辑，没有光标，但是在主窗口创建的edit控件没问题如题，我使用动态创建的子窗口。


关于指向常量的指针和指针常量的问题请教各位！C++
指针
指向对象的常量指针


本人看的是Visual C 2010入门经典，图上的三个变量定义我都测试了一下，代码如下：


#include <iostream>

using std::cout;
using std::endl;

int main()
{
	char* const pstr2("Some text too");
	*pstr2='v';
	return 0;
}



在运行时程序会出错，请问是代码写得不对吗？
pstr2指向的是常量字符串，后面一句更改常量区的内容，所以出错。
应该是这样：    char pstr1[] = "Some text too";
	char* const pstr2 = pstr1;
    *pstr2='v';
因为"Some text too"是在常量区的字符串，不能修改，修改将会导致出错

之所以可以赋值给非const char*的指针是历史遗留原因
以下这种写法就不会报错了：

int main()
{
	char ch[100] = "Some text too";
	char* const pstr2(ch);
	*pstr2 = 'v';
	return 0;
}
对只读数据进行修改，系统是不允许的。
"Some text too"是字符串常量，存放在只读数据段，只读所以不能修改；而*pstr2='v'操作其实就是对字符串常量修改了。
char pstr1[] = "Some text too";
    char* const pstr2 = pstr1;
    *pstr2='v';
这样可以修改的原因是，"Some text too"是只读字符串，但是pstr1是数组，数组在栈上申请的（若在函数内定义），就可读可写。
char pstr1[] = "Some text too";这句赋值有一个隐含的操作，就是将只读字符串拷贝一份至栈上的数组空间里。
不要纠结各种常量了，这个世界上唯一不变的就是变化。用API WriteProcessMemory还能修改正运行的其它进程的内存里面的所谓常量呢！
#pragma comment(linker,"/SECTION:.rdata,RW")
//加这句可以让常量区可写，后果自负！


opencv高斯滤波GaussianBlur() 支持处理16位图像吗？不支持的如何才能支持？若降8位会丢失信息的。opencv

                  opencv高斯滤波GaussianBlur() 支持处理16位图像吗？不支持的如何才能支持？若降8位会丢失信息的，怎么转8位丢失最少的信息？谢谢大家
你说的16位是图片深度吗？如果是的话，是可以的。高斯滤波支持CV_8U, CV_16U, CV_16S, CV_32F, CV_64F图片深度
引用 1 楼 kuangbao9 的回复:你说的16位是图片深度吗？如果是的话，是可以的。高斯滤波支持CV_8U, CV_16U, CV_16S, CV_32F, CV_64F图片深度数据类型是16位的，提示如下图：
引用 1 楼 kuangbao9 的回复:你说的16位是图片深度吗？如果是的话，是可以的。高斯滤波支持CV_8U, CV_16U, CV_16S, CV_32F, CV_64F图片深度请问：Mat lowConstrastMask = abs(img - blurred)< threshold;
abs函数是什么作用，< threshold又是执行什么操作？请指教，就是这句出错误
Mat lowConstrastMask = abs(img - blurred)得到的是Mat矩阵数据类型，而你的threshold应该是个int或者double吧？两个数据类型都不一样，怎么比较呀？这个就是为什么提示
Unsurport or Unrecongize type的原因吧
VS IDE中，在不明白的符号上点鼠标右键，选转到定义。
引用 5 楼 zhao4zhong1 的回复:VS IDE中，在不明白的符号上点鼠标右键，选转到定义。赵老师，请教一个问题：VS2010 调试时，黄色箭头对应的一行，即将要执行的语句已经执行了，也就是执行总是快一步。已经试着删除所有临时文件，清理，重新编译也不行。谢谢
引用 6 楼 C_Bright 的回复:Quote: 引用 5 楼 zhao4zhong1 的回复:
VS IDE中，在不明白的符号上点鼠标右键，选转到定义。赵老师，请教一个问题：VS2010 调试时，黄色箭头对应的一行，即将要执行的语句已经执行了，也就是执行总是快一步。已经试着删除所有临时文件，清理，重新编译也不行。谢谢
百度搜相关关键字。


来来来~有没有用vs2017开发mac程序的小伙伴windows 下vs2017调试mac程序的方法求指教
刚拿到不知道怎么下手。。。当然是c++语言
大晚上的该精神精神啦！！！
http://www.jb51.net/article/98537.htm
目前运用的方法如下：windows下的vs2017运行X代理，代理ip地址是本机的mac虚拟机地址，通过虚拟机mac结合实现调试，感觉这样很尴尬呀~
是挺不错，但没开发过  http://www.iteye.com/news/32409
C++代码如果有兼容平台 可以直接windows下编译运行。


问个很简单问题，似乎是codeblocks问题//下面代码中全局变量 i,j 在cb中运行结果为0，我在网页在线编译器可以显示正常数据为10 有人知道这是bug吗


#include <iostream
using namespace std;
int i=0,j=0;
int whatisthis(int [],int);
int whatis(int [],int);int main(void)
{
int maxsize=10;
int ac[maxsize]={1,2,3,4,5,6,7,8,9,10}; 
cout<<"whatisthis="<<whatisthis(ac,maxsize)<<" "<<i<<endl;
cout<<"whatis="<<whatis(ac,maxsize-1)<<" "<<j<<endl;
return 0;
}
int whatisthis(int a[],int maxsize)
{ if(maxsize==1)
{
i++;
return a[0];
} 
else
{
i++;
return a[maxsize-1]+whatisthis(a,maxsize-1);
}
}
int whatis(int a[],int maxsize)
{ if(maxsize==0)
{
j++;
return a[0];
} 
else
{
j++;
return a[maxsize]+whatis(a,maxsize-1);
}
}
单文件申明全局数组是不是这样写法，和用法啊
#include <iostream>

using namespace std;

int i=0,j=0;
int whatisthis(int [],int);
int whatis(int [],int);

#define MAXSIZE 10

int main(void)
{
    int ac[MAXSIZE]={1,2,3,4,5,6,7,8,9,10};
    cout<<"i = "<<i<<" "<<"whatisthis="<<whatisthis(ac, MAXSIZE)<<" "<<i<<endl;
    cout<<"j = "<<j<<" "<<"whatis="<<whatis(ac, MAXSIZE-1)<<" "<<j<<endl;
    return 0;
}

int whatisthis(int a[],int maxsize)
{
    if(maxsize == 1)
    {
        i++;
        return a[0];
    }
    else
    {
        i++;
        return a[maxsize-1] + whatisthis(a, maxsize-1);
    }
}

int whatis(int a[],int maxsize)
{
    if(maxsize==0)
    {
        j++;
        return a[0];
    }
    else
    {
        j++;
        return a[maxsize] + whatis(a,maxsize-1);
    }
}
i, j都执行了，最后结果都是10；
比如如下输出：
    cout<<"i = "<<i<<" "<<"whatisthis="<<whatisthis(ac, MAXSIZE)<<" "<<i<<endl;
    cout<<"j = "<<j<<" "<<"whatis="<<whatis(ac, MAXSIZE-1)<<" "<<j<<endl;
但是为什么后面的i, j都是0呢；
根据参数(cout的)入栈的顺序，（类似printf)是从左向右压栈，那么出栈就是从右向左了（即先进后出），那么先输出i, j，此时没调用这两个函数，那么i, j确实都是0；
所以，你得到的结果是0，但是这两个函数执行之后，i, j就是10;
还有另一种方法，即将这两个函数的返回值存到一个变量里，比如int m, n；先调用函数将返回值放入m,n变量里。然后再输出m,n和i, j。此时你会发现i, j就是0；

总的问题就是参数压栈和出栈的问题。
哦，多谢哈


有什么方法可以让本地用C++写的服务器上传到云端然后支持其他客户端的连接c++
云端
服务器

                  我在本地用C++写了个简单的服务器，用Linux的socket的那种，怎样才能让各地的客户端都可以连接我的服务器？是放到云端吗，哪个云端支持C++代码呢？
在云端申请一个服务器就好了（一般都是付费的），其实就是要一个公网的IP；
如果要测试一下，不用云端服务器也行。在局域网里也是可以测试的。找两台电脑，一个电脑上运行服务器程序，另一个电脑运行客户端程序，然后先启动服务器，客户端去连服务器。
引用 1 楼 cfjtaishan 的回复:在云端申请一个服务器就好了（一般都是付费的），其实就是要一个公网的IP；
如果要测试一下，不用云端服务器也行。在局域网里也是可以测试的。找两台电脑，一个电脑上运行服务器程序，另一个电脑运行客户端程序，然后先启动服务器，客户端去连服务器。
恩，测试是可以的。主要是学校的项目，客户端是安卓app。我用C++写的服务器，想部署到云端，以前没弄过云端不太清楚，是申请云服务器后把编译好的程序上传到云端就可以了吗？
引用 2 楼 sinat_35261315 的回复:Quote: 引用 1 楼 cfjtaishan 的回复:
在云端申请一个服务器就好了（一般都是付费的），其实就是要一个公网的IP；
如果要测试一下，不用云端服务器也行。在局域网里也是可以测试的。找两台电脑，一个电脑上运行服务器程序，另一个电脑运行客户端程序，然后先启动服务器，客户端去连服务器。
恩，测试是可以的。主要是学校的项目，客户端是安卓app。我用C++写的服务器，想部署到云端，以前没弄过云端不太清楚，是申请云服务器后把编译好的程序上传到云端就可以了吗？
对，可以去阿里云上申请一个服务器，记住要用Linux系统，系统项直接选Ubuntu系统就可以，Ubuntu支持C/C++的编译器；其他的配置，根据你的数据量和服务器复杂度来定。
阿里云需要付费的，可以先申请一个月用于测试；
引用 2 楼 sinat_35261315 的回复:Quote: 引用 1 楼 cfjtaishan 的回复:
在云端申请一个服务器就好了（一般都是付费的），其实就是要一个公网的IP；
如果要测试一下，不用云端服务器也行。在局域网里也是可以测试的。找两台电脑，一个电脑上运行服务器程序，另一个电脑运行客户端程序，然后先启动服务器，客户端去连服务器。
恩，测试是可以的。主要是学校的项目，客户端是安卓app。我用C++写的服务器，想部署到云端，以前没弄过云端不太清楚，是申请云服务器后把编译好的程序上传到云端就可以了吗？
把源码通过scp放到云端，然后在云端上编译，最后运行。
引用 4 楼 cfjtaishan 的回复:Quote: 引用 2 楼 sinat_35261315 的回复:
Quote: 引用 1 楼 cfjtaishan 的回复:
在云端申请一个服务器就好了（一般都是付费的），其实就是要一个公网的IP；
如果要测试一下，不用云端服务器也行。在局域网里也是可以测试的。找两台电脑，一个电脑上运行服务器程序，另一个电脑运行客户端程序，然后先启动服务器，客户端去连服务器。
恩，测试是可以的。主要是学校的项目，客户端是安卓app。我用C++写的服务器，想部署到云端，以前没弄过云端不太清楚，是申请云服务器后把编译好的程序上传到云端就可以了吗？
把源码通过scp放到云端，然后在云端上编译，最后运行。
我上阿里云看了，是要买个叫ECS的云服务器吧，选择ubuntu 系统，按时收费，买完之后再通过scp传文件呗?
引用 5 楼 sinat_35261315 的回复:Quote: 引用 4 楼 cfjtaishan 的回复:
Quote: 引用 2 楼 sinat_35261315 的回复:
Quote: 引用 1 楼 cfjtaishan 的回复:
在云端申请一个服务器就好了（一般都是付费的），其实就是要一个公网的IP；
如果要测试一下，不用云端服务器也行。在局域网里也是可以测试的。找两台电脑，一个电脑上运行服务器程序，另一个电脑运行客户端程序，然后先启动服务器，客户端去连服务器。
恩，测试是可以的。主要是学校的项目，客户端是安卓app。我用C++写的服务器，想部署到云端，以前没弄过云端不太清楚，是申请云服务器后把编译好的程序上传到云端就可以了吗？
把源码通过scp放到云端，然后在云端上编译，最后运行。
我上阿里云看了，是要买个叫ECS的云服务器吧，选择ubuntu 系统，按时收费，买完之后再通过scp传文件呗?
建议你先了解一下，根据自己的需求，尤其对带宽，内存等方面是否有要求；
至于是不是ECS的，建议你多看看，了解一下
引用 6 楼 自信男孩的回复:Quote: 引用 5 楼 sinat_35261315 的回复:
Quote: 引用 4 楼 cfjtaishan 的回复:
Quote: 引用 2 楼 sinat_35261315 的回复:
Quote: 引用 1 楼 cfjtaishan 的回复:
在云端申请一个服务器就好了（一般都是付费的），其实就是要一个公网的IP；
如果要测试一下，不用云端服务器也行。在局域网里也是可以测试的。找两台电脑，一个电脑上运行服务器程序，另一个电脑运行客户端程序，然后先启动服务器，客户端去连服务器。
恩，测试是可以的。主要是学校的项目，客户端是安卓app。我用C++写的服务器，想部署到云端，以前没弄过云端不太清楚，是申请云服务器后把编译好的程序上传到云端就可以了吗？
把源码通过scp放到云端，然后在云端上编译，最后运行。
我上阿里云看了，是要买个叫ECS的云服务器吧，选择ubuntu 系统，按时收费，买完之后再通过scp传文件呗?
建议你先了解一下，根据自己的需求，尤其对带宽，内存等方面是否有要求；
至于是不是ECS的，建议你多看看，了解一下
好的，非常感谢！！！


新手请教一个socket问题socket

                  问题：客户端发送一次数据后，第二次服务端接收不了啦，只能接收一次是为什么





服务端代码：
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>


int main()
{
	int sfd, cfd;
	struct sockaddr_in server_addr;
	char buff[10];

	//创建套接字
	if( (sfd=socket(AF_INET, SOCK_STREAM, 0))<0 ){
		perror("create socket error!");
		exit(0);
	}
	
	memset(&server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(8888);
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);		//通配符地址

	//防止服务器关闭后需要等待TIME_WAIT状态才能才继续使用address
	int on=1;
	if ( setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))<0 ){
		perror("set socket opt fail!\n");
		exit(0);
	}
	//绑定套接字
	if( bind(sfd, (struct sockaddr *)&server_addr, sizeof(server_addr))==-1 ){
		perror("bind has error!\n");
		exit(0);
	}
	
	//监听套接字
	if( listen(sfd, 10)==-1 ) {
		perror("listen has error!\n");
		exit(0);
	}
	
	//接收客户端
	while(1){
		puts("waitting for client on 888");
		if( (cfd = accept(sfd,  (struct sockaddr *)NULL, NULL)) > -1 ) {
			printf("new socket fd:%d\n", cfd);
		}
		
		int n;
		if( (n = recv(cfd, buff, strlen(buff), 0)) < 0 ) {
			puts("recv data fail\n");
			exit(0);
		}
	    buff[n] = '\0';
    	printf("recv msg from client: %s\n", buff);
		puts(buff);
		close(cfd);
	}
	
	//关闭close();
	close(sfd);
	
	return 0;
}

客户端代码：
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>

int main()
{
	int cfd;
	struct sockaddr_in server_addr;
	char buff[10];
	
	//创建socket
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(8888);
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
	
	cfd = socket(AF_INET, SOCK_STREAM, 0);
	if( cfd<0 ) {
		perror("create socket error\n!");
		exit(0);
	}
	
	//连接
	if( connect(cfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) ==-1 ){
		perror("connect has error!\n");
		exit(1);
	}
	printf("connect with destination host...\n");  
	
	while(1){
		memset(buff, 0, strlen(buff));
		scanf("%s", buff);
		send(cfd, buff, strlen(buff), 0);
	}
	
	
	//关闭close();
	close(cfd);
}
问题已经解决了：　原来recv还需要循环接收

引用 楼主 Schengshuo 的回复:问题：客户端发送一次数据后，第二次服务端接收不了啦，只能接收一次是为什么





服务端代码：
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>


int main()
{
	int sfd, cfd;
	struct sockaddr_in server_addr;
	char buff[10];

	//创建套接字
	if( (sfd=socket(AF_INET, SOCK_STREAM, 0))<0 ){
		perror("create socket error!");
		exit(0);
	}
	
	memset(&server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(8888);
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);		//通配符地址

	//防止服务器关闭后需要等待TIME_WAIT状态才能才继续使用address
	int on=1;
	if ( setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))<0 ){
		perror("set socket opt fail!\n");
		exit(0);
	}
	//绑定套接字
	if( bind(sfd, (struct sockaddr *)&server_addr, sizeof(server_addr))==-1 ){
		perror("bind has error!\n");
		exit(0);
	}
	
	//监听套接字
	if( listen(sfd, 10)==-1 ) {
		perror("listen has error!\n");
		exit(0);
	}
	
	//接收客户端
	while(1){
		puts("waitting for client on 888");
		if( (cfd = accept(sfd,  (struct sockaddr *)NULL, NULL)) > -1 ) {
			printf("new socket fd:%d\n", cfd);
		}
		
		int n;
		if( (n = recv(cfd, buff, strlen(buff), 0)) < 0 ) {
			puts("recv data fail\n");
			exit(0);
		}
	    buff[n] = '\0';
    	printf("recv msg from client: %s\n", buff);
		puts(buff);
		close(cfd);
	}
	
	//关闭close();
	close(sfd);
	
	return 0;
}

客户端代码：
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>

int main()
{
	int cfd;
	struct sockaddr_in server_addr;
	char buff[10];
	
	//创建socket
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(8888);
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
	
	cfd = socket(AF_INET, SOCK_STREAM, 0);
	if( cfd<0 ) {
		perror("create socket error\n!");
		exit(0);
	}
	
	//连接
	if( connect(cfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) ==-1 ){
		perror("connect has error!\n");
		exit(1);
	}
	printf("connect with destination host...\n");  
	
	while(1){
		memset(buff, 0, strlen(buff));
		scanf("%s", buff);
		send(cfd, buff, strlen(buff), 0);
	}
	
	
	//关闭close();
	close(cfd);
}


C++ 继承中 构造函数声明写法本帖最后由 yujialiao2224 于 2017-11-01 03:09:47 编辑


                  MyFtpService(AfTcpSocket client)
	:TcpServiceTask(client)
{
	m_homeDir = "E:/CProjects"; // ftp根目录
	m_path = "/"; // 起始目录
}

直接在头文件写。就通过。但是不知道怎么分开在 h文件声明 在CPP文件定义
在头文件写

MyFtpService(AfTcpSocket client)
	:TcpServiceTask(client);

这样子编译不通过
有人吗
.h
MyFtpService(AfTcpSocket client);

.cpp
MyFtpService::MyFtpService(AfTcpSocket client) :TcpServiceTask(client)
{
    //其他初始化内容
};
楼上正解；子类继承父类时，父类带有参数的构造函数时，子类的构造函数必须显式调用父类构造函数。
在cpp文件中初始化基类的含参构造
引用 2 楼 ananluowei 的回复:.h
MyFtpService(AfTcpSocket client);

.cpp
MyFtpService::MyFtpService(AfTcpSocket client) :TcpServiceTask(client)
{
    //其他初始化内容
};

这个正确


QTcpSocket中readyread信号只能触发一次QT
QTcpSocket
readyread

                  首先，服务端是用node.js写的，客户端使用QT写的。
下面是客户端代码：

QEventLoop loop;
connect(textTcpSocket,SIGNAL(readyRead()),this,SLOT(receiveNews()));
loop.exec();
void MainWindow::receiveNews(){
        QByteArray s = textTcpSocket->readAll();
        ui->textEdit_rec->append(s);
        loop.exit();
}


服务端就是写了三个socket.write向socket中分三次写入数据。客户端使用事件循环也是无奈之举，因为如果我不在connect后面暂停程序的话，连一次数据都无法接收到，程序会跳过connect继续往下执行。而connect也就再也无法触发了。但是加上loop.exec()暂停程序后，虽然能接收到服务端发送过来的数据，但只能接收到服务端第一个write过来的数据，后面的两次无法接收。看了很多程序都直接connect就一直可以监听readyRead信号，我也不知道为什么我的程序问题出在哪，求大神指教
已解决~~~~~~~~~~~~~~~~~~
楼主怎么解决的，我也是服务器分两次发送，但是客户端只出发了一次readyread();怎么回事呢？求教


新手遇到点小问题，求大神解答同样的printf语句，中间什么也没做，最后输出结果大不一样。代码如下


#include<stdio.h>

int* decimaltobinary(int x);
//int hammingDistance(int x, int y);

int main(void)
{
    int *a,x,i;
    scanf("%d", &x);
    a=decimaltobinary(x);


    printf("%d %d %d %d %d", a[4], a[4], a[4], a[4], a[4]);
    puts("\n");
    printf("%d %d %d %d %d", a[4], a[4], a[4], a[4], a[4]);
    return 0;
}

int* decimaltobinary(int x)
{
    int i,arr[32]={0};
    int * p;
    for(i=0;i<32;i++)
    {
        //printf("%d ",x%2);
        arr[i]=x%2;
        if(x==1)
            break;
        x/=2;
    }
    p=arr;
    return p;
}

输出结果如下：


第二次printf的值每次运行都是不一样的。
求解答，感激不尽
程序运行到puts时，数组a的内存生命周期结束了，内部内存被释放，指针乱指
你定义的函数返回了一个局部变量arr[]的地址，会在函数返回后销毁，值就是随机的了
还是不要返回指针了，直接在参数里传入指针不是更好？
返回局部变量是未定义行为，建议将数组arr定义成static变量，改变数组的生命周期；

int* decimaltobinary(int x)
{
    int i;
    static int arr[32]={0};
    int * p;

    for(i=0;i<32;i++)
    {
        //printf("%d ",x%2);
        arr[i]=x%2;
        if(x==1)
            break;
        x/=2;
    }
    p=arr;
    return p;
}
栈中的变量通常包括函数参数和函数里声明的临时变量。
栈中的基本变量退出其作用域时，没有谁执行一段代码去释放/销毁/析构它所占用的内存，仅仅是没人再去理会的留在当前栈顶上方的若干遗留下来可被后续压栈操作覆盖的无用数据而已。
而栈中的类变量退出其作用域时，会自动执行其析构函数，……
引用 1 楼 qq_21193563 的回复:程序运行到puts时，数组a的内存生命周期结束了，内部内存被释放，指针乱指
指针没有乱指哦，只是指向的那部分内存区域不能使用了（被释放了），若被其他函数栈占用，就会把arr的数组覆盖掉；


c++超强控制台打字机,模仿进入另一个空间.#include <iostream>
#include<string>

using namespace std;

int main()
{
         string a;
         while(getline(cin,a))
         {
    
         }
}


输出应为4.18……但是我的却输出5.18……是哪里错了？c语言

                  #include "stdio.h"
#include "math.h"
int main()
{
	double i,sum=0,b;
	for (i=1;i<=100;i++)
	{
		sum=sum+(1/i);
	}
	printf ("sum=%lf\n",sum);
	return 0;
}


c++ 如何在soap接口调用的http header中增加字段C++
GSOAP
webservice
http头

                  别人提供了一个webservice接口，我用gsoap生成出了相应的代码，然后调用里面的Send方法，结果返回SOAP_FAIL，询问后得知，还要在该接口的http头中增加一个字段。刚接触gsoap不久，请教各位大虾，gsoap如何在http头中添加字段？
百度搜相关关键字。
好吧！自己搞定了！


计算机术语中master和worker是什么计算机术语中master和worker是什么
master一般指主动发起请求的一方，worker顾名思义工作者或任务对象。
Master-Worker模式是常用的并行设计模式。核心思想是，系统由两个角色组成，Master和Worker，Master负责接收和分配任务，Worker负责处理子任务。任务处理过程中，Master还负责监督任务进展和Worker的健康状态；Master将接收Client提交的任务，并将任务的进展汇总反馈给Client。
引用 2楼小灸舞 的回复:Master-Worker模式是常用的并行设计模式。核心思想是，系统由两个角色组成，Master和Worker，Master负责接收和分配任务，Worker负责处理子任务。任务处理过程中，Master还负责监督任务进展和Worker的健康状态；Master将接收Client提交的任务，并将任务的进展汇总反馈给Client。是的，我就是在并行计算中遇到的，但是怎么翻译呢
车间主任和工人
引用 4楼赵4老师 的回复:车间主任和工人不会吧？！就这样翻译？
一般来说manager比master较常用吧
车间主任，真形象~


vc6.0不知道怎么iostream.h与string形式无法使用，用iostream却可以#include<iostream>
#include<string>
using namespace std; 
class A
{private:string r;
public:A(string a)
       {r=a;}
       void print()
       {cout<<r<<endl;}
};
int main(){
A ob("1");
ob.print();
return 0;}可以
但是改头文件
#include<iostream.h>
#include<string>
class A
{private:string r;
public:A(string a)
       {r=a;}
       void print()
       {cout<<r<<endl;}
};
int main(){
A ob("1");
ob.print();
return 0;}
发生错误d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(4) : error C2146: syntax error : missing ';' before identifier 'r'
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(4) : error C2501: 'string' : missing storage-class or type specifiers
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(4) : error C2501: 'r' : missing storage-class or type specifiers
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(5) : error C2629: unexpected 'class A ('
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(5) : error C2334: unexpected token(s) preceding '{'; skipping apparent function body
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(11) : error C2440: 'initializing' : cannot convert from 'char [2]' to 'class A'
        No constructor could take the source type, or constructor overload resolution was ambiguous
标准c++的头文件就是 iostream，没有.h
iostream.h 是旧的C++标准，已经废弃，所以找不到这个头文件。iostream是新的C++标准。
string.h 和 cstring是C标准的东西，string是C++标准的东西。用不带.h的头文件中的函数，是在std名称空间。如：<iostream>、<string>、<cstring>、<cstdio>
用带.h的头文件中的函数，是在全局空间，不用加using namespace std; 如<string.h>、<stdio.h>


数字常量真就没办法取地址吗？不通过变量定义，就不能对数字取地址吗？有啥方法可以获取呢？
咋个取地址啊  把整数当地址用? 那就把整数强制转换成指针  然后指向指针的指针  大概是这样 比如说st标准库里对寄存器地址的访问都是这么定义的
楼主的直接定义指针好吧-
数字是一个临时变量，生命周期未知，假如你取到了它的地址，下一时刻地址里边的值可能就改变了。
const常量可以取地址
const int i = 6;
int* pi = &i;
立即数本身可能就没地址，已经直接被编入了指令中
http://edu.csdn.net/course/detail/2344 C语言指针与汇编内存地址-一.代码要素
电脑内存或文件内容或传输内容只是一个一维二进制字节数组及其对应的二进制地址；
人脑才将电脑内存或文件内容或传输内容中的这个一维二进制字节数组及其对应的二进制地址的某些部分看成是整数、有符号数/无符号数、浮点数、复数、英文字母、阿拉伯数字、中文/韩文/法文……字符/字符串、汇编指令、函数、函数参数、堆、栈、数组、指针、数组指针、指针数组、数组的数组、指针的指针、二维数组、字符点阵、字符笔画的坐标、黑白二值图片、灰度图片、彩色图片、录音、视频、指纹信息、身份证信息……
获得一个数字常量的地址的目的是什么？
如果是为了限制代码的膨胀，你直接写成const int变量形式就行了
如果是为了单纯的看看地址，我认为编译器是直接在编译过程中将常量数字写进了汇编代码里，而没有用符号解析，所以，没有意义
常量有可能直接使用，不需要占用内存（比如立即数），因此取地址没意义；
字符串常量，字符串本身就是地址，因此也无需再取地址。


c快排求助请看代码最后void quicksort(int array[], int maxlen, int begin, int end)  
{  
    int i, j;  
  
    if(begin < end)  
    {  
        i = begin + 1;  // 将array[begin]作为基准数，因此从array[begin+1]开始与基准数比较！  
        j = end;        // array[end]是数组的最后一位  
            
        while(i < j)  
        {  
            if(array[i] > array[begin])  // 如果比较的数组元素大于基准数，则交换位置。  
            {  
                swap(&array[i], &array[j]);  // 交换两个数  
                j--;  
            }  
            else  
            {  
                i++;  // 将数组向后移一位，继续与基准数比较。  
            }  
        }  
  
        if(array[i] >= array[begin])    
        {  
            i--;  
        }  
  
        swap(&array[begin], &array[i]);    
          
        quicksort(array, maxlen, begin, i);     //这里为什么下界和上界都是固定begin和end呢
        quicksort(array, maxlen, j, end);        //递归到数组中间段的时候不应该都会变化吗？
    }  
}
递归的时候，参数传递过程中，begin和end的值不断变化的
自己做个简单的模拟就了解了。
1、quicksort(array, maxlen, begin, i);  //这时候begin不变，但是end的值是i了，变化了
2、quicksort(array, maxlen, j, end);   //同理，begin的值是j，变了
不断递归下去，只有最左边的一个组，begin永远不变，最右边的组，end永远不变，中间的组，begin和end都变了。
会变化，因为递归传进去的虽然是begin，end，但是这两个值是变化的（i, 和j 分别取代了end和start，i,j是变化的变量）。建议详细了解一下递归的原理。


请问基于librdkafka库写的源代码怎么编译librdkafka
kafka
编译

我已经在自己的机子上编译了librdkafka库，并且能正确运行例子。
但自己用c++仿照例子写的源代码却不知怎么编译......
具体点讲如下：



运行下面这一行指令是可以正确发消息的
$ ./rdkafka_example -P -b localhost:9092 -t test 
而我想知道rdkafka_example.c是怎样编译成rdkafka_example的

希望有大佬能够指点下我这个刚入门的小白菜
木遁 造人の术
g++指令不可以么？
引用 2 楼 iloveyou418 的回复:g++指令不可以么？
不可以呢，rdkafka.h没有那个文件或目录
自顶
加上“-lrdkafka -lz -lpthread -lrt”还是没用


vc6.0不知道怎么iostream.h与string形式无法使用，用iostream却可以c++
新人

                  比如
#include<iostream>
#include<string>
using namespace std; 
class A
{private:string r;
public:A(string a)
       {r=a;}
       void print()
       {cout<<r<<endl;}
};
int main(){
A ob("1");
ob.print();
return 0;}可以
但是改头文件
#include<iostream.h>
#include<string>
class A
{private:string r;
public:A(string a)
       {r=a;}
       void print()
       {cout<<r<<endl;}
};
int main(){
A ob("1");
ob.print();
return 0;}
发生错误d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(4) : error C2146: syntax error : missing ';' before identifier 'r'
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(4) : error C2501: 'string' : missing storage-class or type specifiers
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(4) : error C2501: 'r' : missing storage-class or type specifiers
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(5) : error C2629: unexpected 'class A ('
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(5) : error C2334: unexpected token(s) preceding '{'; skipping apparent function body
d:\program files (x86)\microsoft visual studio\myprojects\wqd\wq.cpp(11) : error C2440: 'initializing' : cannot convert from 'char [2]' to 'class A'
        No constructor could take the source type, or constructor overload resolution was ambiguous
百度 加或不加.h 两者的区别
加.h是老式的写法


初学菜鸟，求教，我的递归哪儿出错了，总是没显示不出结果菜鸟
递归
数组

                  #include<iostream>
#include<string>
using namespace std;
int check(int x)
{
	if (x > 6)
	{
		cout << "input wrong num";
		cout << "plz re-input the num:" << endl;
		cin >> x;
		check(x);
		return x;
	}
	return x;
}

void main()
{
	int n;
	char xqj[7][20] = { "monday","tuesday","wednsday","thursday","friday","satday","sunday" };
	cout << "plz input which day you want to choose:" << endl;
	cin >> n;
	check(n);
	cout << xqj[n + 1][20] << endl;
}
Visual Studio 2015社区版正常编译，可以运行。。

仅供参考
cout << xqj[n+1] << endl;
“给定一个小点的输入，完整单步跟踪(同时按Alt+7键查看Call Stack里面从上到下列出的对应从里层到外层的函数调用历史)一遍。”是理解递归函数工作原理的不二法门！
递归函数关注以下几个因素
·退出条件
·参数有哪些
·返回值是什么
·局部变量有哪些
·全局变量有哪些
·何时输出
·会不会导致堆栈溢出
输出这块儿有问题。不能这么写cout << xqj[n + 1][20] << endl;
另外，不太明白你这个check的返回值有啥意义？

#include<iostream>
#include<string>
using namespace std;
int check(int x)
{
if (x > 6 || x < 0)
{
cout << "input wrong num";
cout << "plz re-input the num:" << endl;
cin >> x;
check(x);
return x;
}
return x;
}

void main()
{
int n;
char xqj[7][20] = { "monday","tuesday","wednsday","thursday","friday","satday","sunday" };
cout << "plz input which day you want to choose:" << endl;
cin >> n;
int ret = check(n);
cout << xqj[ret] << endl;
}
汗，写错了。不能编辑。

#include<iostream>
#include<string>
using namespace std;
int check(int x)
{
if (x > 6 || x < 0)
{
cout << "input wrong num";
cout << "plz re-input the num:" << endl;
cin >> x;
return check(x);
}
return x;
}
 
void main()
{
int n;
char xqj[7][20] = { "monday","tuesday","wednsday","thursday","friday","satday","sunday" };
cout << "plz input which day you want to choose:" << endl;
cin >> n;
int ret = check(n);
cout << xqj[ret] << endl;
}
我想说。就算你的递归程序对，你在主函数不输出这是什么鬼。更何况不对。
新手菜鸟，所以会犯一些很基础的错，请谅解，现在自己琢磨出来了，谢谢各位不吝赐教。


大神们好,我写了一棵小苹果!源码公布如下:

#include <iostream>

using namespace std;

void swap1(int *p1, int *p2);

int main()
{
     int a = 1, b = 2;
     swap1(&a, &b);
    cout << a << b << endl;
 }

void swap1(int *p1, int *p2)
{
        p1 = p2;
}
大佬，惹不起惹不起
结帖率：0%
#include <iostream>

using namespace std;

void swap1(int *p1, int *p2);

int main()
{
    int a = 1, b = 2;
    swap1(&a, &b);
    cout << a << b << endl;
}

void swap1(int *p1, int *p2)
{
    int tmp = *p1;
    *p1 = *p2;
    *p2 = tmp;
}
建议去苹果公司写“小苹果”；
apple欢迎你


想问一下这个代码为什么不正确，关于两个一元多项式链表相乘的问题，还有一个问题就是下面还有一个关于两个交集的问题我的代码应该怎么修改Polynomial Multiply( Polynomial a, Polynomial b )
{
    Polynomial s,ptr,p,c;
    s=(Polynomial)malloc(sizeof(struct Node*));
    s->Next=NULL;
    p=b;
    c=s;
    a=a->Next;
    b=b->Next;
    while(a!=NULL)
    {
        while(b!=NULL)
        {
           ptr=(Polynomial)malloc(sizeof(struct Node*));
           ptr->Exponent=a->Exponent+b->Exponent;
           ptr->Coefficient=a->Coefficient*b->Coefficient;
           if(s->Next==NULL)
           {
               s->Next=ptr;
               ptr->Next=NULL;
           }
           if(s->Next->Exponent>ptr->Exponent)
           {
               s=s->Next;
           }
           else if(s->Next->Exponent==ptr->Exponent)
           {
               s->Next->Exponent=s->Next->Coefficient+ptr->Coefficient;

            }
            else
            {
                ptr->Next=s->Next;
                s->Next=ptr;
                }
             b=b->Next;
             s=c;

            }
        a=a->Next;
        b=p;


    }


    return c;



}


List AddList(List L1,List L2)
{
    List p,c,temp;
    p=(List)malloc(sizeof(struct Node));
   // p->Next=NULL;
   // c=p;

    p->Next=NULL;
    c=p;
    temp=L2;
    L1=L1->Next;
    L2=L2->Next;
    while(L1||L2)
    {
        if(L1->Data==L2->Data)
        {   
            p->Next=L1;
            L1=L1->Next;
            p->Next->Next=NULL;
            p=p->Next;
            L2=temp;
            L2=L2->Next;

                }


     else
     {
        L2=L2->Next;

     }
    if(L2==NULL)
     {

        L1=L1->Next;
        L2=temp;
        L2=L2->Next;
     }
      }


        return c;


    }
*/
仅供参考：//链表实现一元多项式的加法减法乘法
#include <stdio.h>
#include <stdlib.h>
typedef struct node {
    float coef;   //系数
    int expn;     //指数
    struct node *next;
}
PolyNode;      //多项式节点 polynomial node
typedef PolyNode* Polynomial;
Polynomial createPolynomial() {  //创建多项式
    PolyNode *p, *q, *head = (PolyNode *)malloc(sizeof(PolyNode));   //头节点
    head->next = NULL;
    float coef;
    int expn;
    printf("输入该多项式每一项的系数和指数，每项一行，输入0 0结束！\n");
    while (scanf("%f %d", &coef, &expn) && coef) {   // 默认，按指数递减排列
        if (head->next) {
            p = head;
            while (p->next && expn < p->next->expn)
                p = p->next;
            if (p->next) {
                if (expn == p->next->expn) { //有相同指数的直接把系数加到原多项式
                    p->next->coef += coef;
                    if (p->next->coef > -0.000001 && p->next->coef < 0.000001) { //若是相加后系数为0，则舍弃该节点
                        q = p->next;
                        p->next = q->next;
                        free(q);
                    }
                } else {
                    q = (PolyNode*)malloc(sizeof(PolyNode));
                    q->coef = coef;
                    q->expn = expn;
                    q->next = p->next;
                    p->next = q;
                }
            } else {
                p->next = (PolyNode*)malloc(sizeof(PolyNode));
                p = p->next;
                p->coef = coef;
                p->expn = expn;
                p->next = NULL;
            }
        } else {
            head->next = (PolyNode*)malloc(sizeof(PolyNode));
            head->next->coef = coef;
            head->next->expn = expn;
            head->next->next = NULL;
        }
    }
    return head;
}
Polynomial multiply(Polynomial poly, float coef, int expn) {  //多项式与指定单项式相乘，该单项式为 coefx^expn
    PolyNode *p, *q, *Poly = (PolyNode*)malloc(sizeof(PolyNode));
    p = Poly;
    q = poly->next;
    while (q) {
        p->next = (PolyNode*)malloc(sizeof(PolyNode));
        p = p->next;
        p->coef = (q->coef*coef);
        p->expn = (q->expn + expn);
        q = q->next;
    }
    p->next = NULL;
    return Poly;
}
void add(Polynomial poly1, Polynomial poly2) {  //把 poly2 加到 poly1 上
    PolyNode *p, *q, *r;
    r = poly1;
    p = poly1->next;  //指向第一个节点
    q = poly2->next;
    poly2->next = NULL;
    while (p && q) {
        if (p->expn > q->expn) {
            r->next = p;
            p = p->next;
            r = r->next;
        } else if (p->expn < q->expn) {
            r->next = q;
            q = q->next;
            r = r->next;
        } else {
            PolyNode *t;
            p->coef += q->coef;
            if (!(p->coef > -0.000001 && p->coef < 0.000001)) //系数不为0
            {
                r->next = p;
                r = r->next;
                p = p->next;
            } else {
                t = p;
                p = p->next;
                free(t);
            }
            t = q;
            q = q->next;
            free(t);
        }
    }
    if (p)
        r->next = p;
    if (q)
        r->next = q;
}
Polynomial polySubtract(Polynomial poly1, Polynomial poly2) {  //多项式减法 poly1-poly2形成一个新的多项式
    //把poly2的系数取相反数，形成一个新的多项式
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode)); //构造头节点
    PolyNode *p, *q;
    p = poly;
    q = poly2->next;
    while (q) {
        p->next = (PolyNode*)malloc(sizeof(PolyNode));
        p = p->next;
        p->coef = -(q->coef);  //系数取反
        p->expn = q->expn;
        q = q->next;
    }
    p->next = NULL;
    add(poly, poly1);  //利用加法
    return poly;
}
Polynomial polyAdd(Polynomial poly1, Polynomial poly2) { //多项式相加 poly1+poly2形成一个新的多项式
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode));  //和多项式的头节点
    poly->next = NULL;
    PolyNode *p, *q, *r;
    r = poly;
    p = poly1->next;
    q = poly2->next;
    while (p&&q) {
        if (p->expn > q->expn) {
            r->next = (PolyNode*)malloc(sizeof(PolyNode));
            r = r->next;
            r->coef = p->coef;
            r->expn = p->expn;
            p = p->next;
        } else if (p->expn < q->expn) {
            r->next = (PolyNode*)malloc(sizeof(PolyNode));
            r = r->next;
            r->coef = q->coef;
            r->expn = q->expn;
            q = q->next;
        } else {
            float m = p->coef + q->coef;
            if (!(m > -0.000001 && m < 0.000001)) {
                r->next = (PolyNode*)malloc(sizeof(PolyNode));
                r = r->next;
                r->coef = m;
                r->expn = p->expn;
            }
            q = q->next;
            p = p->next;
        }
    }
    while (p) {
        r->next = (PolyNode*)malloc(sizeof(PolyNode));
        r = r->next;
        r->coef = p->coef;
        r->expn = p->expn;
        p = p->next;
    }
    while (q) {
        r->next = (PolyNode*)malloc(sizeof(PolyNode));
        r = r->next;
        r->coef = q->coef;
        r->expn = q->expn;
        q = q->next;
    }
    r->next = NULL;
    return poly;
}
Polynomial polyMultiply(Polynomial poly1, Polynomial poly2) {  //多项式相乘
    Polynomial poly = (PolyNode*)malloc(sizeof(PolyNode));  //创建多项式和的头节点
    poly->next = NULL;
    PolyNode *p;
    p = poly2->next;
    while (p) {
        add(poly, multiply(poly1, p->coef, p->expn));
        p = p->next;
    }
    return poly;
}
void printPoly(Polynomial poly) {  //打印多项式
    if (poly && poly->next) {
        PolyNode *p = poly->next;  //p指向第一个节点
        while (p->next) {
            printf("%gx^%d", p->coef, p->expn);
            p = p->next;
            if (p && (p->coef > 0))
                printf("+");
        }
        if (p->expn == 0)
            printf("%g", p->coef);   //打印常数项
        else
            printf("%gx^%d", p->coef, p->expn);
        printf("\n");
    }
}
void freePoly(Polynomial poly) {  //释放内存
    if (poly && poly->next) {
        PolyNode *p, *q;
        p = poly;
        while (p) {
            q = p->next;
            free(p);
            p = q;
        }
    }
    poly = NULL;
}
int main() {
    printf("用链表实现多项式的加减法\n");
    Polynomial poly1, poly2, poly3;
    printf("创建多项式一\n");
    poly1 = createPolynomial();
    printf("多项式一：\n");
    printPoly(poly1);
    printf("创建多项式二\n");
    poly2 = createPolynomial();
    printf("多项式二：\n");
    printPoly(poly2);
    printf("两多项式相加，和为：\n");
    poly3 = polyAdd(poly1, poly2);
    printPoly(poly3);
    freePoly(poly3);
    printf("两个多项式相乘，积为：\n");
    poly3 = polyMultiply(poly1, poly2);
    printPoly(poly3);
    freePoly(poly3);
    printf("两多项式相减，差为：\n");
    poly3 = polySubtract(poly1, poly2);
    printPoly(poly3);
    freePoly(poly1);
    freePoly(poly2);
    freePoly(poly3);
    system("pause");
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK      1
#define ERROR   0
#define TRUE    1
#define FALSE   0

typedef int Status;
typedef int Elemtype;

typedef struct Node{
    Elemtype cof;
    Elemtype inx;
    struct Node *next;
}Node, *LinkList;

Status visit(Elemtype a, Elemtype b)
{
    printf("%d %d", a, b);

    return OK;
}

Status InitList(LinkList *L)
{
    (*L) = (LinkList)malloc(sizeof(Node));
    if (!(*L))
        return ERROR;

    (*L)->next = NULL;

    return OK;
}

/* count the length */
int ListLength(LinkList L)
{
    int i = 0;
    LinkList p;

    p = L->next;
    while (p) {
        i++;
        p = p->next;
    }

    return i;
}


/* get the data of no. i nodes, i start from 1 */
Status GetElem(LinkList L, int i, Elemtype *cof, Elemtype *inx)
{
    LinkList p;
    int j;

    p = L;
    j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    if (!p)
        return ERROR;

    *cof=p->next->cof;
    *inx=p->next->inx;

    return OK;
}

Status ListInsert(LinkList *L, int i, Elemtype cof, Elemtype inx)
{
    if(i < 1 || i > ListLength(*L) + 1)
        return ERROR;

    int j;
    LinkList p, q;


    p = *L;
    j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    if (!p || j > i)
        return ERROR;

    q = (LinkList)malloc(sizeof(Node));
    if (!q) {
        fprintf(stderr, "malloc error!\n");
        return ERROR;
    }
    q->cof = cof;
    q->inx = inx;

    q->next = p->next;
    p->next = q;

    return OK;
}


/*打印L中系数非零的项*/
Status ListTraverse(LinkList L)
{
    LinkList p;

    p = L->next;
    while (p) {
        if (p->cof != 0) {
            visit(p->cof, p->inx);
            printf(" ");
        }
        p = p->next;
    }
    printf("\n");

    return OK;
}

Status PlusList(LinkList *L3,LinkList L1,LinkList L2)
{
    int i, j, k;
    Elemtype cof1, inx1;
    Elemtype cof2, inx2;

    k = i = j = 1;
    while ((i <= ListLength(L1)) && (j <= ListLength(L2))) {
        GetElem(L1, i, &cof1, &inx1);
        GetElem(L2, j, &cof2, &inx2);
        if (inx1 == inx2) {
            ListInsert(L3, k++, cof1 + cof2, inx1);
            i++;
            j++;
        } else if (inx1 > inx2) {
            ListInsert(L3, k++, cof1, inx1);
            i++;
        } else {
            ListInsert(L3, k++, cof2, inx2);
            j++;
        }
    }

    return OK;
}
int main()
{
    LinkList L1, L2, L3;
    int cofn, inxn;
    int i;

    InitList(&L1);
    InitList(&L2);
    InitList(&L3);

    i = 1;
    while(scanf("%d%d", &cofn, &inxn) == 2 && inxn != -1){
        ListInsert(&L1, i++, cofn, inxn);
    }
    i = 1;
    while(scanf("%d%d", &cofn, &inxn) == 2 && cofn != -1){
        ListInsert(&L2, i++, cofn, inxn);
    }
    PlusList(&L3, L1, L2);
    ListTraverse(L3);

    return 0;
}

多项式加法，作为一个参考吧
谢谢你们的回答，本以为不会有人回复，原来这里有这么多热心的人 谢谢    谢 谢


热烈庆祝本人受关注人数即将突破12000大关！散分！！祝C/C++er们2017 Hold住*.* ！
#define _WIN32_WINNT 0x0500
#include <windows.h>
#include <stdio.h>
HANDLE gDoneEvent;
VOID CALLBACK TimerRoutine(PVOID lpParam, BOOLEAN TimerOrWaitFired) {
    if (lpParam == NULL) {
        printf("TimerRoutine lpParam is NULL\n");
    } else {
        // lpParam points to the argument; in this case it is an int
        printf("Timer routine called. Parameter is %d.\n", *(int*)lpParam);
    }
    SetEvent(gDoneEvent);
}
int main() {
    HANDLE hTimer = NULL;
    HANDLE hTimerQueue = NULL;
    int arg = 123;

    // Use an event object to track the TimerRoutine execution
    gDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == gDoneEvent) {
        printf("CreateEvent failed (%d)\n", GetLastError());
        return 1;
    }

    // Create the timer queue.
    hTimerQueue = CreateTimerQueue();
    if (NULL == hTimerQueue) {
        printf("CreateTimerQueue failed (%d)\n", GetLastError());
        return 2;
    }

    // Set a timer to call the timer routine in 10 seconds.
    if (!CreateTimerQueueTimer( &hTimer, hTimerQueue, (WAITORTIMERCALLBACK)TimerRoutine, &arg , 10000, 0, 0)) {
        printf("CreateTimerQueueTimer failed (%d)\n", GetLastError());
        return 3;
    }

    // TODO: Do other useful work here
    printf("Call timer routine in 10 seconds...\n");

    // Wait for the timer-queue thread to complete using an event
    // object. The thread will signal the event at that time.

    if (WaitForSingleObject(gDoneEvent, INFINITE) != WAIT_OBJECT_0)
        printf("WaitForSingleObject failed (%d)\n", GetLastError());

    CloseHandle(gDoneEvent);

    // Delete all timers in the timer queue.
    if (!DeleteTimerQueue(hTimerQueue))
        printf("DeleteTimerQueue failed (%d)\n", GetLastError());

    return 0;
}
//Call timer routine in 10 seconds...
//Timer routine called. Parameter is 123.
//



哈哈  抢了次前排
我也来试试手气
新人紧随其后。。。。默默关注各位

还算前排吧，恭喜赵老师
新手抢个前排
呱唧呱唧

大神!


贺电。。。。
恭喜！


定时接分
膜拜大神。...

膜拜大神

赶着来膜拜大神！
新手抢个座



http://bbs.csdn.net/topics/392084340
刚学C 会要提很多问题，请高人赐分
3Q
用CreateThreadpoolTimer写的：

#define _WIN32_WINNT 0x0500
#include <windows.h>
#include <stdio.h>
HANDLE gDoneEvent;
VOID CALLBACK TimerRoutine(
	_Inout_     PTP_CALLBACK_INSTANCE Instance,
	_Inout_opt_ PVOID                 Context,
	_Inout_     PTP_TIMER             Timer) 
{
	if (Context == NULL) {
		printf("TimerRoutine Context is NULL\n");
	} else {
		// Context points to the argument; in this case it is an int
		printf("Timer routine called. Parameter is %d.\n", *(int*)Context);
	}
	SetEvent(gDoneEvent);
}
int main() {
	HANDLE hTimer = NULL;
	PTP_TIMER lpTimer = NULL;
	int arg = 123;

	// Use an event object to track the TimerRoutine execution
	gDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (NULL == gDoneEvent) {
		printf("CreateEvent failed (%d)\n", GetLastError());
		return 1;
	}

	// CreateThreadpoolTimer
	lpTimer = CreateThreadpoolTimer(TimerRoutine, &arg, NULL);
	if (NULL == lpTimer) {
		printf("CreateThreadpoolTimer failed (%d)\n", GetLastError());
		return 2;
	}

	// Set a timer to call the timer routine in 10 seconds
	FILETIME ft;
	ft.dwHighDateTime = 0xFFFFFFFF;
	ft.dwLowDateTime = -100000000;
	SetThreadpoolTimer(lpTimer, &ft, 0, 0);

	// TODO: Do other useful work here
	printf("Call timer routine in 10 seconds...\n");

	// Wait for the timer-queue thread to complete using an event
	// object. The thread will signal the event at that time.

	if (WaitForSingleObject(gDoneEvent, INFINITE) != WAIT_OBJECT_0)
		printf("WaitForSingleObject failed (%d)\n", GetLastError());

	CloseHandle(gDoneEvent);

	// CloseThreadpoolTimer;
	CloseThreadpoolTimer(lpTimer);

	return 0;
}
//Call timer routine in 10 seconds...
//Timer routine called. Parameter is 123.
//
cool凑个热闹～
赚点分
沙发沙发沙发，哈哈
测试能不能发言聚聚
恭喜恭喜....
，赵老师是一个高尚的人，一个纯粹的人，一个有道德的人，一个脱离了低级趣味的人，一个有益于人民的人。
实力派大神,请受在下一拜
听说给我分的人都很帅。。


膜拜大神



666666666666666

！大牛啊！！
引用 31 楼 paschen 的回复:用CreateThreadpoolTimer写的：

#define _WIN32_WINNT 0x0500
#include <windows.h>
#include <stdio.h>
HANDLE gDoneEvent;
VOID CALLBACK TimerRoutine(
	_Inout_     PTP_CALLBACK_INSTANCE Instance,
	_Inout_opt_ PVOID                 Context,
	_Inout_     PTP_TIMER             Timer) 
{
	if (Context == NULL) {
		printf("TimerRoutine Context is NULL\n");
	} else {
		// Context points to the argument; in this case it is an int
		printf("Timer routine called. Parameter is %d.\n", *(int*)Context);
	}
	SetEvent(gDoneEvent);
}
int main() {
	HANDLE hTimer = NULL;
	PTP_TIMER lpTimer = NULL;
	int arg = 123;

	// Use an event object to track the TimerRoutine execution
	gDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (NULL == gDoneEvent) {
		printf("CreateEvent failed (%d)\n", GetLastError());
		return 1;
	}

	// CreateThreadpoolTimer
	lpTimer = CreateThreadpoolTimer(TimerRoutine, &arg, NULL);
	if (NULL == lpTimer) {
		printf("CreateThreadpoolTimer failed (%d)\n", GetLastError());
		return 2;
	}

	// Set a timer to call the timer routine in 10 seconds
	FILETIME ft;
	ft.dwHighDateTime = 0xFFFFFFFF;
	ft.dwLowDateTime = -100000000;
	SetThreadpoolTimer(lpTimer, &ft, 0, 0);

	// TODO: Do other useful work here
	printf("Call timer routine in 10 seconds...\n");

	// Wait for the timer-queue thread to complete using an event
	// object. The thread will signal the event at that time.

	if (WaitForSingleObject(gDoneEvent, INFINITE) != WAIT_OBJECT_0)
		printf("WaitForSingleObject failed (%d)\n", GetLastError());

	CloseHandle(gDoneEvent);

	// CloseThreadpoolTimer;
	CloseThreadpoolTimer(lpTimer);

	return 0;
}
//Call timer routine in 10 seconds...
//Timer routine called. Parameter is 123.
//
Requirements
Client
 Requires Windows Vista.
Server
 Requires Windows Server 2008.
我的Windows Server 2003不支持啊！
赵老师大牛啊
来自CPP的贺电


恭喜恭喜


与天下所有程序员共勉：
扎克伯格：真正决定人生高度的是你做事的速度
http://economy.enorth.com.cn/system/2017/02/09/031550692.shtml

引用 49 楼 zhao4zhong1 的回复:Quote: 引用 31 楼 paschen 的回复:
用CreateThreadpoolTimer写的：

#define _WIN32_WINNT 0x0500
#include <windows.h>
#include <stdio.h>
HANDLE gDoneEvent;
VOID CALLBACK TimerRoutine(
	_Inout_     PTP_CALLBACK_INSTANCE Instance,
	_Inout_opt_ PVOID                 Context,
	_Inout_     PTP_TIMER             Timer) 
{
	if (Context == NULL) {
		printf("TimerRoutine Context is NULL\n");
	} else {
		// Context points to the argument; in this case it is an int
		printf("Timer routine called. Parameter is %d.\n", *(int*)Context);
	}
	SetEvent(gDoneEvent);
}
int main() {
	HANDLE hTimer = NULL;
	PTP_TIMER lpTimer = NULL;
	int arg = 123;

	// Use an event object to track the TimerRoutine execution
	gDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (NULL == gDoneEvent) {
		printf("CreateEvent failed (%d)\n", GetLastError());
		return 1;
	}

	// CreateThreadpoolTimer
	lpTimer = CreateThreadpoolTimer(TimerRoutine, &arg, NULL);
	if (NULL == lpTimer) {
		printf("CreateThreadpoolTimer failed (%d)\n", GetLastError());
		return 2;
	}

	// Set a timer to call the timer routine in 10 seconds
	FILETIME ft;
	ft.dwHighDateTime = 0xFFFFFFFF;
	ft.dwLowDateTime = -100000000;
	SetThreadpoolTimer(lpTimer, &ft, 0, 0);

	// TODO: Do other useful work here
	printf("Call timer routine in 10 seconds...\n");

	// Wait for the timer-queue thread to complete using an event
	// object. The thread will signal the event at that time.

	if (WaitForSingleObject(gDoneEvent, INFINITE) != WAIT_OBJECT_0)
		printf("WaitForSingleObject failed (%d)\n", GetLastError());

	CloseHandle(gDoneEvent);

	// CloseThreadpoolTimer;
	CloseThreadpoolTimer(lpTimer);

	return 0;
}
//Call timer routine in 10 seconds...
//Timer routine called. Parameter is 123.
//
Requirements
Client
 Requires Windows Vista.
Server
 Requires Windows Server 2008.
我的Windows Server 2003不支持啊！ 


是啊，vista及windows server 2008才有的，不能做到向下兼容
好棒
新手抢个前排
祝贺祝贺祝贺祝贺
膜拜膜拜
恭喜，祝贺~~~~~

66666666666666666666666666666666666666666666666
牛XXXXXXXX
膜拜大神
恭喜恭喜

没有下载分了，来接一点
来膜拜一

666666666666666666666666666666666666666
水一贴
老师我是一名C初学者，我用vector写了一个DLL，其中遇到下标错误！出错大概再这个位置，我不知道自己写的DLL插件在别人的程序里运行怎样调试，希望老师能解惑！
l = dzsData.size();l--;//dzsit = dzsData.end();  dzsit--;
					if (l >= 0)
					{
						if (dData[i].high > dzsData[l].gg) dData[i].dbs = -1;
						if (dData[i].high <= dzsData[l].gg) dData[i].dbs = -2;
						if (dData[i].high < dzsData[l].zd)
						{
							dData[i].dbs = -3; findZSNew = true;    dirnext = DIR_DN;
							i = hhv; llv = hhv + 1;  //dzsData[l].duanno = dData[hhv].noh;  dzsData[l].jsno = dData[hhv].nol;
							for (fz = l;fz >= 0;fz--)
							{
								//cdzhongshu & ddnum = dzsData.at(fz);
								if (dzsData[fz].jsno > dData[hhv].nol) // ddnum.jsno > dData[hhv].nol
								{
									dzsData[fz].jsno = dData[hhv].nol;//;  ddnum.jsno = dData[hhv].nol
									if (dzsData[fz].jsno <= dzsData[fz].ksno) { dzsData.pop_back(); }//{ dzsData.pop_back(); }//if (dzsData[fz].jsno <= dzsData[fz].ksno)  (ddnum.jsno <= ddnum.ksno) 
									 
								}
								else { break; }
							
							}  //end for (fz = l;fz >= 0;fz--)
						 }
					  }  //end if (l >= 0)
其中dzsData为vector链表，如果释放
cdzhongshu & ddnum = dzsData.at(fz);
这一句，运行起来会有点小问题，但不会崩溃，不知道怎么处理这种情况，当然能够有方法进行调试，看到具体执行到哪里出错了更好！
用的编译器是VS2015!

看着赵老师的各种勋章，我已眼花缭乱。

恭喜，我还是刚入CSDN的小白。请多多关照。

恭喜恭喜！！
大神级。。膜拜。。。
恭喜恭喜
恭喜赵老师
贺电
牛B得不要不要滴 淫才呀
老师好！
很强势的了。
，就考课目看的是你不会懂我的世界你

好文共赏：
上帝的程序http://codebay.cn/post/2968.html
--------------------Configuration: Cpp1 - Win32 Debug--------------------
Compiling...
Cpp1.cpp
c:\program files\microsoft visual studio\common\msdev98\bin\cpp1.cpp(27) : error C2065: 'CreateTimerQueue' : undeclared identifier
c:\program files\microsoft visual studio\common\msdev98\bin\cpp1.cpp(27) : error C2440: '=' : cannot convert from 'int' to 'void *'
        Conversion from integral type to pointer type requires reinterpret_cast, C-style cast or function-style cast
c:\program files\microsoft visual studio\common\msdev98\bin\cpp1.cpp(34) : error C2065: 'CreateTimerQueueTimer' : undeclared identifier
c:\program files\microsoft visual studio\common\msdev98\bin\cpp1.cpp(34) : error C2065: 'WAITORTIMERCALLBACK' : undeclared identifier
c:\program files\microsoft visual studio\common\msdev98\bin\cpp1.cpp(34) : error C2146: syntax error : missing ')' before identifier 'TimerRoutine'
c:\program files\microsoft visual studio\common\msdev98\bin\cpp1.cpp(34) : error C2059: syntax error : ')'
c:\program files\microsoft visual studio\common\msdev98\bin\cpp1.cpp(34) : error C2143: syntax error : missing ';' before '{'
c:\program files\microsoft visual studio\common\msdev98\bin\cpp1.cpp(51) : error C2065: 'DeleteTimerQueue' : undeclared identifier
执行 cl.exe 时出错.

Cpp1.obj - 1 error(s), 0 warning(s)
什么意思？
我是菜鸟不懂
我顶，我的关注着还少着呢

新手来看大神 求分

还有没有分！！！
秋分求分秋风秋分

jj好像很厉害的样子
大神！前来围观


产品外观检测系统各位大佬，小弟毕业设计是产品外观检测系统。
但之前一直没有接触过这方面的知识。一下子接触这方面有点茫然和不知所措，不知道该学从何学起，如何入手。
下图是毕业设计的基本要求，有大佬能给小弟一点建议吗，十分感谢。


给整形变量地址加1，为什么不是偏移了1个字节？偏移
内存
指针
c
c++



字符数组  首地址+1 每次 都是偏移1字节

我试着用 int类型的 地址加1 可每次竟然偏移了4字节

如果不用 字符型指针 指向这个整形变量的地址，有什么办法能每次偏移一个字节吗？
就是 直接用&b 怎么写？
+1是指+1个变量类型的长度
注意&b是值整个类型的地址，&b+1就是偏移sizeof(int)个字节；

比如int *p = &b; p++//即p = p+1，那么就是偏移sizeof int个字节
还有


char a[2];
a++;    /*偏移一个字节*/
&a++;    /*偏移sizeof(char) * 2个字节，即偏移一个数组长度*/
指针的加减操作，和指针的类型相关的，想一次+1偏移一个字节，只能把指针强行转换成char*
3楼正解，
强制转到char* 再+1就是对字节的操作
Pointer Arithmetic
Additive operations involving a pointer and an integer give meaningful results only if the pointer operand addresses an array member and the integer value produces an offset within the bounds of the same array. When the integer value is converted to an address offset, the compiler assumes that only memory positions of the same size lie between the original address and the address plus the offset.

This assumption is valid for array members. By definition, an array is a series of values of the same type; its elements reside in contiguous memory locations. However, storage for any types except array elements is not guaranteed to be filled by the same type of identifiers. That is, blanks can appear between memory positions, even positions of the same type. Therefore, the results of adding to or subtracting from the addresses of any values but array elements are undefined.

Similarly, when two pointer values are subtracted, the conversion assumes that only values of the same type, with no blanks, lie between the addresses given by the operands.
指针变量的+1, 是增加指针所指向的类型的字节数.
int *p;   p+1则是增加4字节 
short *p; p+1则是增加2字节
以此类推.
你这里是给一个指针(int*)进行加法运算，指针的加法运算是这样：指针+N 相当于移动 N*sizeof(T)，T是指针指向的对象类型
变量地址加一，是指sizeof    (变量类型) 个字节，  建议你想的话可以用位段试试，用位段可以指定一个变量占几个字符
因为在你当前的环境下，int类型系统会默认为4个字节的内存大小，即long int类型；当int *p;p＝0;p＋＋;后所指向的地址偏移实际上加了4个字节，刚刚好是一个int的内存大小
地址加1,就是当前类型的地址加一，如果想偏移1个字节，可以转换成char *


vs2010配置问题c/c++

                  本来想着用vs的c++编辑器测试一个malloc的问题，但是引入了stdlib.h头文件，却显示malloc未定义标识符。
如图：
我的图呢？
我的可以vs2008
你就用下面那个头文件吧
引用 2 楼 qq_38204686 的回复:我的可以vs2008
你就用下面那个头文件吧

应该是配置的问题吧，我一直用的linux，换到vs不会用，也不会配置。
<stdlib.h> and <malloc.h>
malloc
Allocates memory blocks.

void *malloc( size_t size );

Routine Required Header Compatibility 
malloc <stdlib.h> and <malloc.h> ANSI, Win 95, Win NT 


For additional compatibility information, see Compatibility in the Introduction.

Libraries

LIBC.LIB Single thread static library, retail version 
LIBCMT.LIB Multithread static library, retail version 
MSVCRT.LIB Import library for MSVCRT.DLL, retail version 


Return Value

malloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. To return a pointer to a type other than void, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, malloc allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from malloc, even if the amount of memory requested is small.

Parameter

size

Bytes to allocate

Remarks

The malloc function allocates a memory block of at least size bytes. The block may be larger than size bytes because of space required for alignment and maintenance information.

The startup code uses malloc to allocate storage for the _environ, envp, and argv variables. The following functions and their wide-character counterparts also call malloc:

calloc fscanf _getw setvbuf 
_exec functions fseek _popen _spawn functions 
fgetc fsetpos printf _strdup 
_fgetchar _fullpath putc system 
fgets fwrite putchar _tempnam 
fprintf getc _putenv ungetc 
fputc getchar puts vfprintf 
_fputchar _getcwd _putw vprintf 
fputs _getdcwd scanf   
fread gets _searchenv   


The C++ _set_new_mode function sets the new handler mode for malloc. The new handler mode indicates whether, on failure, malloc is to call the new handler routine as set by _set_new_handler. By default, malloc does not call the new handler routine on failure to allocate memory. You can override this default behavior so that, when malloc fails to allocate memory, malloc calls the new handler routine in the same way that the new operator does when it fails for the same reason. To override the default, call 

_set_new_mode(1)

early in your program, or link with NEWMODE.OBJ.

When the application is linked with a debug version of the C run-time libraries, malloc resolves to _malloc_dbg. For more information about how the heap is managed during the debugging process, see Using C Run-Time Library Debugging Support.

Example

/* MALLOC.C: This program allocates memory with
 * malloc, then frees the memory with free.
 */

#include <stdlib.h>         /* For _MAX_PATH definition */
#include <stdio.h>
#include <malloc.h>

void main( void )
{
   char *string;

   /* Allocate space for a path name */
   string = malloc( _MAX_PATH );
   if( string == NULL )
      printf( "Insufficient memory available\n" );
   else
   {
      printf( "Memory space allocated for path name\n" );
      free( string );
      printf( "Memory freed\n" );
   }
}


Output

Memory space allocated for path name
Memory freed


Memory Allocation Routines

See Also   calloc, free, realloc
应该是放在<malloc.h>，Windows下malloc声明的头文件和Linux下有些不同。Linux引入<stdlib.h>即可，但是Windows下要引入<malloc.h>
详细的可以从网上搜一下<malloc.h>都有那些函数或变量声明


Linux开启两个线程监听两个端口，线程阻塞监听后另一个线程不执行线程
C++
Linux

                  RT


窝这样写对吗，创建了socket后两个线程监听两个端口，难道线程不是同时执行的吗，下面开启线程的代码不执行是什么原因？
有时不将“调用函数名字＋各参数值，进入函数后各参数值，中间变量值，退出函数前准备返回的值，返回函数到调用处后函数名字＋各参数值＋返回值”这些信息写日志到文件中是无论如何也发现不了问题在哪里的，包括捕获各种异常、写日志到屏幕、单步或设断点或生成core或dmp文件、……这些方法都不行！ 写日志到文件参考下面：
//循环向a函数每次发送200个字节长度（这个是固定的）的buffer,
//a函数中需要将循环传进来的buffer，组成240字节（也是固定的）的新buffer进行处理，
//在处理的时候每次从新buffer中取两个字节打印
#ifdef _MSC_VER
    #pragma warning(disable:4996)
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef _MSC_VER
    #include <windows.h>
    #include <process.h>
    #include <io.h>
    #define  MYVOID             void
    #define  vsnprintf          _vsnprintf
#else
    #include <unistd.h>
    #include <sys/time.h>
    #include <pthread.h>
    #define  CRITICAL_SECTION   pthread_mutex_t
    #define  MYVOID             void *
#endif
//Log{
#define MAXLOGSIZE 20000000
#define MAXLINSIZE 16000
#include <time.h>
#include <sys/timeb.h>
#include <stdarg.h>
char logfilename1[]="MyLog1.log";
char logfilename2[]="MyLog2.log";
static char logstr[MAXLINSIZE+1];
char datestr[16];
char timestr[16];
char mss[4];
CRITICAL_SECTION cs_log;
FILE *flog;
#ifdef _MSC_VER
void Lock(CRITICAL_SECTION *l) {
    EnterCriticalSection(l);
}
void Unlock(CRITICAL_SECTION *l) {
    LeaveCriticalSection(l);
}
void sleep_ms(int ms) {
    Sleep(ms);
}
#else
void Lock(CRITICAL_SECTION *l) {
    pthread_mutex_lock(l);
}
void Unlock(CRITICAL_SECTION *l) {
    pthread_mutex_unlock(l);
}
void sleep_ms(int ms) {
    usleep(ms*1000);
}
#endif
void LogV(const char *pszFmt,va_list argp) {
    struct tm *now;
    struct timeb tb;

    if (NULL==pszFmt||0==pszFmt[0]) return;
    vsnprintf(logstr,MAXLINSIZE,pszFmt,argp);
    ftime(&tb);
    now=localtime(&tb.time);
    sprintf(datestr,"%04d-%02d-%02d",now->tm_year+1900,now->tm_mon+1,now->tm_mday);
    sprintf(timestr,"%02d:%02d:%02d",now->tm_hour     ,now->tm_min  ,now->tm_sec );
    sprintf(mss,"%03d",tb.millitm);
    printf("%s %s.%s %s",datestr,timestr,mss,logstr);
    flog=fopen(logfilename1,"a");
    if (NULL!=flog) {
        fprintf(flog,"%s %s.%s %s",datestr,timestr,mss,logstr);
        if (ftell(flog)>MAXLOGSIZE) {
            fclose(flog);
            if (rename(logfilename1,logfilename2)) {
                remove(logfilename2);
                rename(logfilename1,logfilename2);
            }
        } else {
            fclose(flog);
        }
    }
}
void Log(const char *pszFmt,...) {
    va_list argp;

    Lock(&cs_log);
    va_start(argp,pszFmt);
    LogV(pszFmt,argp);
    va_end(argp);
    Unlock(&cs_log);
}
//Log}
#define ASIZE    200
#define BSIZE    240
#define CSIZE      2
char Abuf[ASIZE];
char Cbuf[CSIZE];
CRITICAL_SECTION cs_HEX;
CRITICAL_SECTION cs_BBB;
struct FIFO_BUFFER {
    int  head;
    int  tail;
    int  size;
    char data[BSIZE];
} BBB;
int No_Loop=0;
void HexDump(int cn,char *buf,int len) {
    int i,j,k;
    char binstr[80];

    Lock(&cs_HEX);
    for (i=0;i<len;i++) {
        if (0==(i%16)) {
            sprintf(binstr,"%03d %04x -",cn,i);
            sprintf(binstr,"%s %02x",binstr,(unsigned char)buf[i]);
        } else if (15==(i%16)) {
            sprintf(binstr,"%s %02x",binstr,(unsigned char)buf[i]);
            sprintf(binstr,"%s  ",binstr);
            for (j=i-15;j<=i;j++) {
                sprintf(binstr,"%s%c",binstr,('!'<buf[j]&&buf[j]<='~')?buf[j]:'.');
            }
            Log("%s\n",binstr);
        } else {
            sprintf(binstr,"%s %02x",binstr,(unsigned char)buf[i]);
        }
    }
    if (0!=(i%16)) {
        k=16-(i%16);
        for (j=0;j<k;j++) {
            sprintf(binstr,"%s   ",binstr);
        }
        sprintf(binstr,"%s  ",binstr);
        k=16-k;
        for (j=i-k;j<i;j++) {
            sprintf(binstr,"%s%c",binstr,('!'<buf[j]&&buf[j]<='~')?buf[j]:'.');
        }
        Log("%s\n",binstr);
    }
    Unlock(&cs_HEX);
}
int GetFromRBuf(int cn,CRITICAL_SECTION *cs,struct FIFO_BUFFER *fbuf,char *buf,int len) {
    int lent,len1,len2;

    lent=0;
    Lock(cs);
    if (fbuf->size>=len) {
        lent=len;
        if (fbuf->head+lent>BSIZE) {
            len1=BSIZE-fbuf->head;
            memcpy(buf     ,fbuf->data+fbuf->head,len1);
            len2=lent-len1;
            memcpy(buf+len1,fbuf->data           ,len2);
            fbuf->head=len2;
        } else {
            memcpy(buf     ,fbuf->data+fbuf->head,lent);
            fbuf->head+=lent;
        }
        fbuf->size-=lent;
    }
    Unlock(cs);
    return lent;
}
MYVOID thdB(void *pcn) {
    char        *recv_buf;
    int          recv_nbytes;
    int          cn;
    int          wc;
    int          pb;

    cn=(int)pcn;
    Log("%03d thdB              thread begin...\n",cn);
    while (1) {
        sleep_ms(10);
        recv_buf=(char *)Cbuf;
        recv_nbytes=CSIZE;
        wc=0;
        while (1) {
            pb=GetFromRBuf(cn,&cs_BBB,&BBB,recv_buf,recv_nbytes);
            if (pb) {
                Log("%03d recv %d bytes\n",cn,pb);
                HexDump(cn,recv_buf,pb);
                sleep_ms(1);
            } else {
                sleep_ms(1000);
            }
            if (No_Loop) break;//
            wc++;
            if (wc>3600) Log("%03d %d==wc>3600!\n",cn,wc);
        }
        if (No_Loop) break;//
    }
#ifndef _MSC_VER
    pthread_exit(NULL);
#endif
}
int PutToRBuf(int cn,CRITICAL_SECTION *cs,struct FIFO_BUFFER *fbuf,char *buf,int len) {
    int lent,len1,len2;

    Lock(cs);
    lent=len;
    if (fbuf->size+lent>BSIZE) {
        lent=BSIZE-fbuf->size;
    }
    if (fbuf->tail+lent>BSIZE) {
        len1=BSIZE-fbuf->tail;
        memcpy(fbuf->data+fbuf->tail,buf     ,len1);
        len2=lent-len1;
        memcpy(fbuf->data           ,buf+len1,len2);
        fbuf->tail=len2;
    } else {
        memcpy(fbuf->data+fbuf->tail,buf     ,lent);
        fbuf->tail+=lent;
    }
    fbuf->size+=lent;
    Unlock(cs);
    return lent;
}
MYVOID thdA(void *pcn) {
    char        *send_buf;
    int          send_nbytes;
    int          cn;
    int          wc;
    int           a;
    int          pa;

    cn=(int)pcn;
    Log("%03d thdA              thread begin...\n",cn);
    a=0;
    while (1) {
        sleep_ms(100);
        memset(Abuf,a,ASIZE);
        a=(a+1)%256;
        if (16==a) {No_Loop=1;break;}//去掉这句可以让程序一直循环直到按Ctrl+C或Ctrl+Break或当前目录下存在文件No_Loop
        send_buf=(char *)Abuf;
        send_nbytes=ASIZE;
        Log("%03d sending %d bytes\n",cn,send_nbytes);
        HexDump(cn,send_buf,send_nbytes);
        wc=0;
        while (1) {
            pa=PutToRBuf(cn,&cs_BBB,&BBB,send_buf,send_nbytes);
            Log("%03d sent %d bytes\n",cn,pa);
            HexDump(cn,send_buf,pa);
            send_buf+=pa;
            send_nbytes-=pa;
            if (send_nbytes<=0) break;//
            sleep_ms(1000);
            if (No_Loop) break;//
            wc++;
            if (wc>3600) Log("%03d %d==wc>3600!\n",cn,wc);
        }
        if (No_Loop) break;//
    }
#ifndef _MSC_VER
    pthread_exit(NULL);
#endif
}
int main() {
#ifdef _MSC_VER
    InitializeCriticalSection(&cs_log);
    InitializeCriticalSection(&cs_HEX);
    InitializeCriticalSection(&cs_BBB);
#else
    pthread_t threads[2];
    int threadsN;
    int rc;
    pthread_mutex_init(&cs_log,NULL);
    pthread_mutex_init(&cs_HEX,NULL);
    pthread_mutex_init(&cs_BBB,NULL);
#endif
    Log("Start===========================================================\n");

    BBB.head=0;
    BBB.tail=0;
    BBB.size=0;

#ifdef _MSC_VER
    _beginthread((void(__cdecl *)(void *))thdA,0,(void *)1);
    _beginthread((void(__cdecl *)(void *))thdB,0,(void *)2);
#else
    threadsN=0;
    rc=pthread_create(&(threads[threadsN++]),NULL,thdA,(void *)1);if (rc) Log("%d=pthread_create %d error!\n",rc,threadsN-1);
    rc=pthread_create(&(threads[threadsN++]),NULL,thdB,(void *)2);if (rc) Log("%d=pthread_create %d error!\n",rc,threadsN-1);
#endif

    if (!access("No_Loop",0)) {
        remove("No_Loop");
        if (!access("No_Loop",0)) {
            No_Loop=1;
        }
    }
    while (1) {
        sleep_ms(1000);
        if (No_Loop) break;//
        if (!access("No_Loop",0)) {
            No_Loop=1;
        }
    }
    sleep_ms(3000);
    Log("End=============================================================\n");
#ifdef _MSC_VER
    DeleteCriticalSection(&cs_BBB);
    DeleteCriticalSection(&cs_HEX);
    DeleteCriticalSection(&cs_log);
#else
    pthread_mutex_destroy(&cs_BBB);
    pthread_mutex_destroy(&cs_HEX);
    pthread_mutex_destroy(&cs_log);
#endif
    return 0;
}
顶下
没有人回答我就结帖了
帮顶


qt引用gdal库出现问题c++
qt
gdal

                  引入第三方库，按网上的流程，照理说可以引用成功。我是想把一个c++程序用qt编一个界面，需要引用gdal-1.4.2，但是会出现上百个 LNK2019:无法解析的外部符号 .如图。求助！

引入gdal如下图
项目、属性、链接器、常规、附加库目录：填写附加依赖库所在目录 分号间隔多项
项目、属性、链接器、输入、附加依赖项：填写附加依赖库的名字.lib 空格或分号间隔多项
我是在Qt Creator 中引用gdal，不是vs，您给的方法应该是vs中的方法
引用 2 楼 lyandgh 的回复:我是在Qt Creator 中引用gdal，不是vs，您给的方法应该是vs中的方法
百度搜相关关键字。


VS2010新建IT++工程时报错，求指教IT++
VS2010
修复或重装VS2010
没用，2013也试过了，还是这个问题
vs很恶心，不会配置，就用起来太不爽了。我也是大大小小的问题。慢慢解决吧，百度。
已经解决了。问了个学习javascript的，把ie浏览器升级到了IE10，就没问题了。


怎么找到一个数组前面的不重复的最小值!/* 找最小的前3个不重复的数字*/
#include<iostream>
using namespace std;
int a[6] = { 6,3,2,5,4,1 };
int main()
{
	int min = 100, aa[6] = {0},MIN[3], i;   //aa[6]是一个标记数组，分配好了就让其自增为1
		for (int i = 0;i < 6;i++)
			if (a[i] < min)
			{
				min = a[i];
				aa[i]++;
			}

	return 0;
	
}
冒泡排序找到最小的的三个数就且不重复就停止
如果数组容量大，排序就很占用时间。不通过排序，找到几个其中不重复的最小值，
前三个先放到临时变量
然后遍历  有更小的就替换掉
/* 找最小的前3个不重复的数字*/
#include<iostream>
using namespace std;
int a[6] = { 6,3,2,5,4,1 };
int main()
{
	int min = 100, aa[6] = { 0 }, MIN[3] = {0}, i;   //aa[6]是一个标记数组，分配好了就让其自增为1
	for (int j=0;j<3;j++)
	{ 
		for (int i = 0;i < 6;i++)
		
			if (a[i] < min)
			{
				min = a[i];
				MIN[j] = a[i];
				aa[i]++;
			}
		
	}
	for (int j = 0;j < 3;j++)
		cout << MIN[j] << endl;
	return 0;
	
}


怎么还是没有找到三个最小的值。
引用 2楼我是你的主体 的回复:如果数组容量大，排序就很占用时间。不通过排序，找到几个其中不重复的最小值，排序找到最小的三个就结束-所以不会太耽误时间-个三个临时复制一样的思路
排序就很简单，问题是现在不排序
/* 找最小的前3个不重复的数字*/
#include<stdio.h>
#include<iostream>
using namespace std;
int a[6] = { 6,3,2,5,4,1 };
int main()
{
	int i=0,j,middle ,min = 100, aa[6] = { 0 }, MIN[3];   //aa[6]是一个标记数组，分配好了就让其自增为1			
	for (j = 0;j < 3;j++)
	{
		for (i = 0;i < 6;i++)
		if (aa[i]==0)
				if (a[i] < min)
				{
					min = a[i];
					middle = i;
				}
		MIN[j] = middle;
		aa[middle] = 1;
	}

}

这个为什么选出来的是都是几个重复的数字
#include<iostream>
#include <cmath>
using namespace std;

int a[6] = { 6,3,2,5,4,1 };

int get_min(int *arr, int len);

int main(void)
{
    int min = 100, tmp, MIN[3];
    int i, j;

    MIN[0] = get_min(a, 6);
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 6; j++) {
            tmp = a[j] - MIN[i];
            if (tmp > 0 && tmp < min) {
                min = tmp;
                MIN[i+1] = a[j];
            }
        }
        min = 100;
    }

    for (i = 0; i < 3; i++)
        cout<<MIN[i]<<endl;
    return 0;

}


int get_min(int *arr, int len)
{
    int i, min;

    min = arr[0];
    for (i = 1; i < len; i++)
        if (arr[i] < min)
            min = arr[i];

    return min;
}
如果要的是最小三个不重复的数，那楼上的就已经解决了你的问题。


怎么通过数组标记找到前几个不重复的最小值？/* 找最小的前3个不重复的数字*/
#include<iostream>
using namespace std;
int a[6] = { 6,3,2,5,4,1 };
int main()
{
	int min = 100, aa[6] = {0},MIN[3], i;   //aa[6]是一个标记数组，分配好了就让其自增为1
		for (int i = 0;i < 6;i++)
			if (a[i] < min)
			{
				min = a[i];
				aa[i]++;
			}
	return 0;
/* 找最小的前3个不重复的数字*/
#include<stdio.h>
#include<iostream>
using namespace std;
int a[6] = { 6,3,2,5,4,1 };
int main()
{
    int i=0,j,middle ,min = 100, aa[6] = { 0 }, MIN[3];   //aa[6]是一个标记数组，分配好了就让其自增为1           
    for (j = 0;j < 3;j++)
    {
        for (i = 0;i < 6;i++)
        if (aa[i]==0)
                if (a[i] < min)
                {
                    min = a[i];
                    middle = i;
                }
        MIN[j] = middle;
        aa[middle] = 1;
    }
 
}

这个为什么选出来的是都是几个重复的数字
是因为变量min在第一次循环中就是最小的了，而你却没有清楚标记，造成了三次循环找到的都是一个数。
int i=0,j,middle ,min = 100, aa[6] = { 0 }, MIN[3];   //aa[6]是一个标记数组，分配好了就让其自增为1           
    for (j = 0;j < 3;j++)
    {
	min=100;
        for (i = 0;i < 6;i++)
        if (aa[i]==0)
                if (a[i] < min)
                {
                    min = a[i];
                    middle = i;
                }
        MIN[j] = middle;
        aa[middle] = 1;
    }

增加一句min=100，就OK了，位置如代码所示。
#include<iostream>
#include <cmath>
using namespace std;

int a[6] = { 6,3,2,5,4,1 };

int get_min(int *arr, int len);

int main(void)
{
    int min = 100, tmp, MIN[3];
    int i, j;

    MIN[0] = get_min(a, 6);
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 6; j++) {
            tmp = a[j] - MIN[i];
            if (tmp > 0 && tmp < min) {
                min = tmp;
                MIN[i+1] = a[j];
            }
        }
        min = 100;
    }

    for (i = 0; i < 3; i++)
        cout<<MIN[i]<<endl;
    return 0;

}


int get_min(int *arr, int len)
{
    int i, min;

    min = arr[0];
    for (i = 1; i < len; i++)
        if (arr[i] < min)
            min = arr[i];

    return min;
}


调用realloc函数后除了第一个其他全部变为野指针C++

#include <iostream>
#define QUEUE_INIT_SIZE 4
#define QUEUE_ADD 10
typedef struct {
	int *rear;
	int *front;
	int queuesize;
}SqQueue;
void InitQueue(SqQueue &s) {
	s.front = (int *)malloc(sizeof(int));
	if (!s.rear) exit(0);
	s.rear = s.front;
	s.queuesize = QUEUE_INIT_SIZE;
}
void EnQueue(SqQueue &s, int e) {
	if (s.rear - s.front >= s.queuesize)
	{
		int *ptr = (int *)realloc(s.front, (s.queuesize + QUEUE_ADD) * (sizeof(int)));
		if (!ptr) exit(0);
		s.front = ptr;
		/*printf("%d\n", *(s.front ));
		printf("%d\n", *(s.front+1));
		printf("%d\n", *(s.front + 1+1));*/
		s.rear = s.front + s.queuesize;
		s.queuesize += QUEUE_ADD;
		printf("申请空间成功\n");
	}
	*s.rear = e;
	s.rear++;
	printf("元素%d已入队列\n", e);
}
void DeQueue(SqQueue &s) {
	if (s.front == s.rear)
	{
		printf("队列为空\n");
		exit(0);
	}
	int e = *(s.front);
	s.front++;
	printf("元素%d已出队列\n", e);
}
int main() {
	SqQueue s;
	InitQueue(s);
	EnQueue(s, 1);
	EnQueue(s, 2);
	EnQueue(s, 3);
	EnQueue(s, 4);
	EnQueue(s, 5);
	DeQueue(s);
	DeQueue(s);
	DeQueue(s);
	return 0;
}


在使用realloc之后除了第一个s.front，其他的都变成了野指针
求解，谢谢。
realloc
Reallocate memory blocks.

void *realloc( void *memblock, size_t size );

Routine Required Header Compatibility 
realloc <stdlib.h> and <malloc.h> ANSI, Win 95, Win NT 


For additional compatibility information, see Compatibility in the Introduction.

Libraries

LIBC.LIB Single thread static library, retail version 
LIBCMT.LIB Multithread static library, retail version 
MSVCRT.LIB Import library for MSVCRT.DLL, retail version 


Return Value

realloc returns a void pointer to the reallocated (and possibly moved) memory block. The return value is NULL if the size is zero and the buffer argument is not NULL, or if there is not enough available memory to expand the block to the given size. In the first case, the original block is freed. In the second, the original block is unchanged. The return value points to a storage space that is guaranteed to be suitably aligned for storage of any type of object. To get a pointer to a type other than void, use a type cast on the return value.

Parameters

memblock

Pointer to previously allocated memory block

size

New size in bytes

Remarks

The realloc function changes the size of an allocated memory block. The memblock argument points to the beginning of the memory block. If memblock is NULL, realloc behaves the same way as malloc and allocates a new block of size bytes. If memblock is not NULL, it should be a pointer returned by a previous call to calloc, malloc, or realloc.

The size argument gives the new size of the block, in bytes. The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block can be in a different location. Because the new block can be in a new memory location, the pointer returned by realloc is not guaranteed to be the pointer passed through the memblock argument.

realloc calls malloc in order to use the C++ _set_new_mode function to set the new handler mode. The new handler mode indicates whether, on failure, malloc is to call the new handler routine as set by _set_new_handler. By default, malloc does not call the new handler routine on failure to allocate memory. You can override this default behavior so that, when realloc fails to allocate memory, malloc calls the new handler routine in the same way that the new operator does when it fails for the same reason. To override the default, call 

_set_new_mode(1)

early in your program, or link with NEWMODE.OBJ.

When the application is linked with a debug version of the C run-time libraries, realloc resolves to _realloc_dbg. For more information about how the heap is managed during the debugging process, see Using C Run-Time Library Debugging Support.

Example

/* REALLOC.C: This program allocates a block of memory for
 * buffer and then uses _msize to display the size of that
 * block. Next, it uses realloc to expand the amount of
 * memory used by buffer and then calls _msize again to
 * display the new amount of memory allocated to buffer.
 */

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

void main( void )
{
   long *buffer;
   size_t size;

   if( (buffer = (long *)malloc( 1000 * sizeof( long ) )) == NULL )
      exit( 1 );

   size = _msize( buffer );
   printf( "Size of block after malloc of 1000 longs: %u\n", size );

   /* Reallocate and show new size: */
   if( (buffer = realloc( buffer, size + (1000 * sizeof( long )) )) 
        ==  NULL )
      exit( 1 );
   size = _msize( buffer );
   printf( "Size of block after realloc of 1000 more longs: %u\n", 
            size );

   free( buffer );
   exit( 0 );
}


Output

Size of block after malloc of 1000 longs: 4000
Size of block after realloc of 1000 more longs: 8000


Memory Allocation Routines

See Also   calloc, free, malloc
#include <iostream>
#include <cstdio>
#include <cstdlib>

#define QUEUE_INIT_SIZE 4
#define QUEUE_ADD 10

typedef struct {
    int *rear;
    int *front;
    int queuesize;
}SqQueue;

void InitQueue(SqQueue &s)
{
    s.front = (int *)malloc(sizeof(int));
    if (!s.rear)
        exit(0);
    s.rear = s.front;
    s.queuesize = QUEUE_INIT_SIZE;
}
void EnQueue(SqQueue &s, int e)
{
    if (s.rear - s.front >= s.queuesize) {
        int *ptr = (int *)realloc(s.front, (s.queuesize + QUEUE_ADD) * (sizeof(int)));
        if (!ptr)
            exit(0);
        s.front = ptr;
#if 0
        printf("%d\n", *(s.front ));
          printf("%d\n", *(s.front+1));
          printf("%d\n", *(s.front + 1+1));
#endif
        //s.rear = s.front + s.queuesize;    /*不需要修改s.rear的位置*/
        s.queuesize += QUEUE_ADD;
        printf("申请空间成功\n");
    }
    *s.rear = e;
    s.rear++;
    printf("元素%d已入队列\n", e);
}
void DeQueue(SqQueue &s) {
    if (s.front == s.rear)
    {
        printf("队列为空\n");
        exit(0);
    }
    int e = *(s.front);
    s.front++;
    printf("元素%d已出队列\n", e);
}
int main() {
    SqQueue s;
    InitQueue(s);
    EnQueue(s, 1);
    EnQueue(s, 2);
    EnQueue(s, 3);
    EnQueue(s, 4);
    EnQueue(s, 5);
    DeQueue(s);
    DeQueue(s);
    DeQueue(s);
    return 0;
}
当队列满时，不需要修改s.rear的位置，因为s.rear的位置只会在入队的时候修改；
realloc后不会出现野指针的问题。
realloc后修改s.rear的位置，反而会导致再次入队时缓存越界
引用 2 楼 cfjtaishan 的回复:#include <iostream>
#include <cstdio>
#include <cstdlib>

#define QUEUE_INIT_SIZE 4
#define QUEUE_ADD 10

typedef struct {
    int *rear;
    int *front;
    int queuesize;
}SqQueue;

void InitQueue(SqQueue &s)
{
    s.front = (int *)malloc(sizeof(int));
    if (!s.rear)
        exit(0);
    s.rear = s.front;
    s.queuesize = QUEUE_INIT_SIZE;
}
void EnQueue(SqQueue &s, int e)
{
    if (s.rear - s.front >= s.queuesize) {
        int *ptr = (int *)realloc(s.front, (s.queuesize + QUEUE_ADD) * (sizeof(int)));
        if (!ptr)
            exit(0);
        s.front = ptr;
#if 0
        printf("%d\n", *(s.front ));
          printf("%d\n", *(s.front+1));
          printf("%d\n", *(s.front + 1+1));
#endif
        //s.rear = s.front + s.queuesize;    /*不需要修改s.rear的位置*/
        s.queuesize += QUEUE_ADD;
        printf("申请空间成功\n");
    }
    *s.rear = e;
    s.rear++;
    printf("元素%d已入队列\n", e);
}
void DeQueue(SqQueue &s) {
    if (s.front == s.rear)
    {
        printf("队列为空\n");
        exit(0);
    }
    int e = *(s.front);
    s.front++;
    printf("元素%d已出队列\n", e);
}
int main() {
    SqQueue s;
    InitQueue(s);
    EnQueue(s, 1);
    EnQueue(s, 2);
    EnQueue(s, 3);
    EnQueue(s, 4);
    EnQueue(s, 5);
    DeQueue(s);
    DeQueue(s);
    DeQueue(s);
    return 0;
}
当队列满时，不需要修改s.rear的位置，因为s.rear的位置只会在入队的时候修改；
realloc后不会出现野指针的问题。

这是您修改后代码的运行截图，还是会出现野指针问题，还有就是我觉得应该需要修改s.rear的地址，因为s.front已经指向了新地址，如果s.rear不修改的话，新入队的元素就无法通过s.front++来出队。
如有不正确的地方，请您指正。
引用 1 楼 zhao4zhong1 的回复:realloc
Reallocate memory blocks.

void *realloc( void *memblock, size_t size );

Routine Required Header Compatibility 
realloc <stdlib.h> and <malloc.h> ANSI, Win 95, Win NT 


For additional compatibility information, see Compatibility in the Introduction.

Libraries

LIBC.LIB Single thread static library, retail version 
LIBCMT.LIB Multithread static library, retail version 
MSVCRT.LIB Import library for MSVCRT.DLL, retail version 


Return Value

realloc returns a void pointer to the reallocated (and possibly moved) memory block. The return value is NULL if the size is zero and the buffer argument is not NULL, or if there is not enough available memory to expand the block to the given size. In the first case, the original block is freed. In the second, the original block is unchanged. The return value points to a storage space that is guaranteed to be suitably aligned for storage of any type of object. To get a pointer to a type other than void, use a type cast on the return value.

Parameters

memblock

Pointer to previously allocated memory block

size

New size in bytes

Remarks

The realloc function changes the size of an allocated memory block. The memblock argument points to the beginning of the memory block. If memblock is NULL, realloc behaves the same way as malloc and allocates a new block of size bytes. If memblock is not NULL, it should be a pointer returned by a previous call to calloc, malloc, or realloc.

The size argument gives the new size of the block, in bytes. The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block can be in a different location. Because the new block can be in a new memory location, the pointer returned by realloc is not guaranteed to be the pointer passed through the memblock argument.

realloc calls malloc in order to use the C++ _set_new_mode function to set the new handler mode. The new handler mode indicates whether, on failure, malloc is to call the new handler routine as set by _set_new_handler. By default, malloc does not call the new handler routine on failure to allocate memory. You can override this default behavior so that, when realloc fails to allocate memory, malloc calls the new handler routine in the same way that the new operator does when it fails for the same reason. To override the default, call 

_set_new_mode(1)

early in your program, or link with NEWMODE.OBJ.

When the application is linked with a debug version of the C run-time libraries, realloc resolves to _realloc_dbg. For more information about how the heap is managed during the debugging process, see Using C Run-Time Library Debugging Support.

Example

/* REALLOC.C: This program allocates a block of memory for
 * buffer and then uses _msize to display the size of that
 * block. Next, it uses realloc to expand the amount of
 * memory used by buffer and then calls _msize again to
 * display the new amount of memory allocated to buffer.
 */

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

void main( void )
{
   long *buffer;
   size_t size;

   if( (buffer = (long *)malloc( 1000 * sizeof( long ) )) == NULL )
      exit( 1 );

   size = _msize( buffer );
   printf( "Size of block after malloc of 1000 longs: %u\n", size );

   /* Reallocate and show new size: */
   if( (buffer = realloc( buffer, size + (1000 * sizeof( long )) )) 
        ==  NULL )
      exit( 1 );
   size = _msize( buffer );
   printf( "Size of block after realloc of 1000 more longs: %u\n", 
            size );

   free( buffer );
   exit( 0 );
}


Output

Size of block after malloc of 1000 longs: 4000
Size of block after realloc of 1000 more longs: 8000


Memory Allocation Routines

See Also   calloc, free, malloc
感谢您的回答，但是我看realloc的说明上会引起数据丢失的只有新申请的空间比原来小的情况，不太明白为什么我的代码还是会造成数据丢失。
引用 4 楼 to__be 的回复:Quote: 引用 2 楼 cfjtaishan 的回复:
#include <iostream>
#include <cstdio>
#include <cstdlib>

#define QUEUE_INIT_SIZE 4
#define QUEUE_ADD 10

typedef struct {
    int *rear;
    int *front;
    int queuesize;
}SqQueue;

void InitQueue(SqQueue &s)
{
    s.front = (int *)malloc(sizeof(int));
    if (!s.rear)
        exit(0);
    s.rear = s.front;
    s.queuesize = QUEUE_INIT_SIZE;
}
void EnQueue(SqQueue &s, int e)
{
    if (s.rear - s.front >= s.queuesize) {
        int *ptr = (int *)realloc(s.front, (s.queuesize + QUEUE_ADD) * (sizeof(int)));
        if (!ptr)
            exit(0);
        s.front = ptr;
#if 0
        printf("%d\n", *(s.front ));
          printf("%d\n", *(s.front+1));
          printf("%d\n", *(s.front + 1+1));
#endif
        //s.rear = s.front + s.queuesize;    /*不需要修改s.rear的位置*/
        s.queuesize += QUEUE_ADD;
        printf("申请空间成功\n");
    }
    *s.rear = e;
    s.rear++;
    printf("元素%d已入队列\n", e);
}
void DeQueue(SqQueue &s) {
    if (s.front == s.rear)
    {
        printf("队列为空\n");
        exit(0);
    }
    int e = *(s.front);
    s.front++;
    printf("元素%d已出队列\n", e);
}
int main() {
    SqQueue s;
    InitQueue(s);
    EnQueue(s, 1);
    EnQueue(s, 2);
    EnQueue(s, 3);
    EnQueue(s, 4);
    EnQueue(s, 5);
    DeQueue(s);
    DeQueue(s);
    DeQueue(s);
    return 0;
}
当队列满时，不需要修改s.rear的位置，因为s.rear的位置只会在入队的时候修改；
realloc后不会出现野指针的问题。

这是您修改后代码的运行截图，还是会出现野指针问题，还有就是我觉得应该需要修改s.rear的地址，因为s.front已经指向了新地址，如果s.rear不修改的话，新入队的元素就无法通过s.front++来出队。
如有不正确的地方，请您指正。
没看出有啥问题，在我的PC上测试都是正常的。
#include <iostream>
#include <cstdio>
#include <cstdlib>

#define QUEUE_INIT_SIZE 4
#define QUEUE_ADD 10

typedef struct {
    int *rear;
    int *front;
    int *orig;
    int queuesize;
}SqQueue;

void InitQueue(SqQueue &s)
{
    s.orig = (int *)malloc(QUEUE_INIT_SIZE * sizeof(int));
    if (!s.orig)
        exit(0);
    s.rear = s.front = s.orig;
    s.queuesize = QUEUE_INIT_SIZE;
}
void EnQueue(SqQueue &s, int e)
{
    if (s.rear - s.orig >= s.queuesize) {
        int *ptr = (int *)realloc(s.orig, (s.queuesize + QUEUE_ADD) * (sizeof(int)));
        if (!ptr)
            exit(0);
        s.orig = ptr;
        s.queuesize += QUEUE_ADD;
        printf("申请空间成功\n");
    }
    *s.rear = e;
    s.rear++;
    printf("元素%d已入队列\n", e);
}
void DeQueue(SqQueue &s) {
    if (s.front == s.rear)
    {
        printf("队列为空\n");
        return;
    }
    int e = *(s.front);
    s.front++;
    printf("元素%d已出队列\n", e);
}
int main() {
    SqQueue s;
    InitQueue(s);
    EnQueue(s, 1);
    EnQueue(s, 2);
    EnQueue(s, 3);
    EnQueue(s, 4);
    EnQueue(s, 5);
    DeQueue(s);
    DeQueue(s);
    DeQueue(s);
    free(s.orig);
    return 0;
}
//元素1已入队列
//元素2已入队列
//元素3已入队列
//元素4已入队列
//申请空间成功
//元素5已入队列
//元素1已出队列
//元素2已出队列
//元素3已出队列
//
引用 5 楼 to__be 的回复:Quote: 引用 1 楼 zhao4zhong1 的回复:
realloc
Reallocate memory blocks.

void *realloc( void *memblock, size_t size );

Routine Required Header Compatibility 
realloc <stdlib.h> and <malloc.h> ANSI, Win 95, Win NT 


For additional compatibility information, see Compatibility in the Introduction.

Libraries

LIBC.LIB Single thread static library, retail version 
LIBCMT.LIB Multithread static library, retail version 
MSVCRT.LIB Import library for MSVCRT.DLL, retail version 


Return Value

realloc returns a void pointer to the reallocated (and possibly moved) memory block. The return value is NULL if the size is zero and the buffer argument is not NULL, or if there is not enough available memory to expand the block to the given size. In the first case, the original block is freed. In the second, the original block is unchanged. The return value points to a storage space that is guaranteed to be suitably aligned for storage of any type of object. To get a pointer to a type other than void, use a type cast on the return value.

Parameters

memblock

Pointer to previously allocated memory block

size

New size in bytes

Remarks

The realloc function changes the size of an allocated memory block. The memblock argument points to the beginning of the memory block. If memblock is NULL, realloc behaves the same way as malloc and allocates a new block of size bytes. If memblock is not NULL, it should be a pointer returned by a previous call to calloc, malloc, or realloc.

The size argument gives the new size of the block, in bytes. The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block can be in a different location. Because the new block can be in a new memory location, the pointer returned by realloc is not guaranteed to be the pointer passed through the memblock argument.

realloc calls malloc in order to use the C++ _set_new_mode function to set the new handler mode. The new handler mode indicates whether, on failure, malloc is to call the new handler routine as set by _set_new_handler. By default, malloc does not call the new handler routine on failure to allocate memory. You can override this default behavior so that, when realloc fails to allocate memory, malloc calls the new handler routine in the same way that the new operator does when it fails for the same reason. To override the default, call 

_set_new_mode(1)

early in your program, or link with NEWMODE.OBJ.

When the application is linked with a debug version of the C run-time libraries, realloc resolves to _realloc_dbg. For more information about how the heap is managed during the debugging process, see Using C Run-Time Library Debugging Support.

Example

/* REALLOC.C: This program allocates a block of memory for
 * buffer and then uses _msize to display the size of that
 * block. Next, it uses realloc to expand the amount of
 * memory used by buffer and then calls _msize again to
 * display the new amount of memory allocated to buffer.
 */

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

void main( void )
{
   long *buffer;
   size_t size;

   if( (buffer = (long *)malloc( 1000 * sizeof( long ) )) == NULL )
      exit( 1 );

   size = _msize( buffer );
   printf( "Size of block after malloc of 1000 longs: %u\n", size );

   /* Reallocate and show new size: */
   if( (buffer = realloc( buffer, size + (1000 * sizeof( long )) )) 
        ==  NULL )
      exit( 1 );
   size = _msize( buffer );
   printf( "Size of block after realloc of 1000 more longs: %u\n", 
            size );

   free( buffer );
   exit( 0 );
}


Output

Size of block after malloc of 1000 longs: 4000
Size of block after realloc of 1000 more longs: 8000


Memory Allocation Routines

See Also   calloc, free, malloc
感谢您的回答，但是我看realloc的说明上会引起数据丢失的只有新申请的空间比原来小的情况，不太明白为什么我的代码还是会造成数据丢失。
你的init函数 里 s.front = (int *)malloc(sizeof(int));只分配了1个int长度，但是后面你却对4个int长度的内存有操作，你破坏了堆结构，再realloc,则出错
建议init里面malloc(sizeof(int)*4);
如果当前内存不够分配，realloc会重新寻找其他位置内存，并将数据移动过去，导致原来的一些指针失效
http://en.cppreference.com/w/c/memory/realloc
谢谢大家..问题基本解决


往byte数组拷贝二进制图像数据之后，数据出现问题，大神帮忙看一看拷贝


运行到拷贝数据这段时


这是读到的图像代码





大神帮忙分析分析  瞅瞅~

学会使用数据断点：#include <time.h>
#include <stdlib.h>
#include <windows.h>
int main() {
    int a,b[11];//本来是b[10]，为判断哪句越界，故意声明为b[11]

    srand((unsigned int)time(NULL));//按两次F11，等黄色右箭头指向本行时，调试、新建断点、新建数据断点，地址：&b[10]，字节计数：4，确定。
    while (1) {//按F5，会停在下面某句，此时a的值为10，b[10]已经被修改为对应0..4之一。
        b[(a=rand()%11)]=0;
        Sleep(100);
        b[(a=rand()%11)]=1;
        Sleep(100);
        b[(a=rand()%11)]=2;
        Sleep(100);
        b[(a=rand()%11)]=3;
        Sleep(100);
        b[(a=rand()%11)]=4;
        Sleep(100);
    }
    return 0;
}
发现问题了 其实已经拷贝出来了  但是我在编译器上无法看到
后来起了一个server   的确收到这么多字节数据


warning LNK4075: 忽略“/EDITANDCONTINUE”(由于“/SAFESEH”规范)的问题本人用的vs2012，编译调试是出现了这个问题，百度上的答案都不可行，有没有大神能帮忙解决下。
应该是项目配置的问题，但不知道怎么修改。配置如下
Visual C++ 概念：生成 C/C++ 程序 
链接器工具警告 LNK4075 
发送反馈意见 
 

错误消息
忽略“option1”(由于“option2”规范)


第二个选项重写第一个选项。

指定互斥的链接器选项。 请检查链接器选项。 指定链接器选项的位置取决于生成项目的方式。 

如果在开发环境中生成，则请查看项目的链接器属性页，并了解指定两个链接器选项的位置。 有关


求大神解答同样的printf语句，中间什么也没做，最后输出结果大不一样。代码如下
#include<stdio.h>
 
int* decimaltobinary(int x);
//int hammingDistance(int x, int y);
 
int main(void)
{
    int *a,x,i;
    scanf("%d", &x);
    a=decimaltobinary(x);
 
 
    printf("%d %d %d %d %d", a[4], a[4], a[4], a[4], a[4]);
    puts("\n");
    printf("%d %d %d %d %d", a[4], a[4], a[4], a[4], a[4]);
    return 0;
}
 
int* decimaltobinary(int x)
{
    int i,arr[32]={0};
    int * p;
    for(i=0;i<32;i++)
    {
        //printf("%d ",x%2);
        arr[i]=x%2;
        if(x==1)
            break;
        x/=2;
    }
    p=arr;
    return p;
}

输出结果如下：


第二次printf的值每次运行都是不一样的。
求解答，感激不尽
栈中的变量通常包括函数参数和函数里声明的临时变量。
栈中的基本变量退出其作用域时，没有谁执行一段代码去释放/销毁/析构它所占用的内存，仅仅是没人再去理会的留在当前栈顶上方的若干遗留下来可被后续压栈操作覆盖的无用数据而已。
而栈中的类变量退出其作用域时，会自动执行其析构函数，……

其实电脑开机后物理内存的每个字节中都有值且都是可读写的，从来不会因为所谓的new、delete或malloc、free而被创建、销毁。区别仅在于操作系统内存管理模块在你读写时是否能发现并是否采取相应动作而已。操作系统管理内存的粒度不是字节而是页，一页通常为4KB。


vs2015+CMake+mingw编译linphone配置出错，不知道这个XercesC库怎么搞，自己--- 已启动全部重新生成: 项目: EP_libxsd, 配置: Debug Win32 ------
38>  Building Custom Rule D:/linphone-desktop/submodules/cmake-builder/CMakeLists.txt
38>  CMake does not need to re-run because D:/linphone-desktop/WORK/desktop/cmake/CMakeFiles/generate.stamp is up-to-date.
38>  Creating directories for 'EP_libxsd'
38>  No download step for 'EP_libxsd'
38>  No update step for 'EP_libxsd'
38>  No patch step for 'EP_libxsd'
38>  Performing configure step for 'EP_libxsd'
38>  loading initial cache file D:/linphone-desktop/WORK/desktop//tmp/EP_libxsd/EP_libxsd-cache-Debug.cmake
38>  CMake Error at C:/Program Files/CMake/share/cmake-3.9/Modules/FindPackageHandleStandardArgs.cmake:137 (message):
38>    Failed to find XercesC (missing: XercesC_LIBRARY) (found version "3.1.4")
38>  Call Stack (most recent call first):
38>    C:/Program Files/CMake/share/cmake-3.9/Modules/FindPackageHandleStandardArgs.cmake:377 (_FPHSA_FAILURE_MESSAGE)
38>    C:/Program Files/CMake/share/cmake-3.9/Modules/FindXercesC.cmake:91 (FIND_PACKAGE_HANDLE_STANDARD_ARGS)
38>    CMakeLists.txt:30 (find_package)
该回复于2017-09-23 12:18:20被管理员删除
这个错误我也有，你装QT了吗？


结构体总的字节数的理解大家好，在自学结构体这一节时，书上有这样一个例子：

    struct Student
    {
        int num;
        char name[20];
        char sex;
        int age;
        float score;
        char addr[30];
    };
    struct Student student1;
    printf("%d\n",sizeof(student1));

我想试验一下这个结构体占多少字节，用codeblocks运行后，发现结果为68.这与谭四版的内容不一致。
我百度了一下（搜索关键词sizeof(student1)），按照别人回答的方法，计算了一下：
int num：字节从0-3
char name[20]：字节从4-23
char sex：字节25
int age：字节28-31
float score：字节32-35
char addr[30]：字节36-65
总字节数应该为65。
再参考了谭四版295页的注脚（计算机对内存的管理是以字为单位的），那么，由于65不是4的倍数，故student1占的总字节数为68。
是这样理解的吗？
实际上系统中总是以一定的内存对齐方式处理，比如一般是4字节对齐，那么结构体中间不足4字节倍数的，都会被补足到4字节，比如char sex就不是1字节，而是4字节了。
#include <stdio.h>

int main(void)
{
   struct Student
   {
      int   num;
      char  name[20];
      char  sex;
      int   age;
      float score;
      char  addr[30];
   };
   struct Student student1;
   printf("%d\n", sizeof(student1));

   printf("%p\n", &student1.num);
   printf("%p\n", student1.name);
   printf("%p\n", &student1.sex);
   printf("%p\n", &student1.age);
   printf("%p\n", &student1.score);
   printf("%p\n", &student1.addr);

   return 0;
}
你定义的结构体成员最大的为4个字节，所以成员排列按4字节对齐，不够的插入空余的字节以便对齐
int num：字节从0-3，占4个字节
char name[20]：字节从4-23，占20个字节
char sex：字节24-27，占4个字节，插入3个空余字节
int age：字节28-31，占4个字节
float score：字节32-35，占4个字节
char addr[30]：字节36-67，占32个字节，插入2个空余字节
总字节数应该为4+20+4+4+4+32=68
为什么要对齐呢，这是为了简化读写过程，提高读写速度，CPU在内存和缓存之间交换数据时，可以按块操作，经过对齐的数据可以用尽量少的指令就完成。
不要相信谭，特别是不要仔细看谭
看这篇文章，很清晰
http://www.cnblogs.com/yue-blog/p/5878268.html
看编译器，用sizeof（）查看，一般windows是4字节对齐的。


阿里大于 短信服务c++SDK使用阿里大于
c++
短信服务

                  pTopRequest pRequest = alloc_top_request();
pTopResponse pResponse = NULL;
pTaobaoClient pClient = alloc_taobao_client(url, appkey, appsecret);
set_api_name(pRequest, "alibaba.aliqin.fc.sms.num.send" );
add_param(pRequest, "extend" , "" );
add_param(pRequest, "sms_type" , "normal" );
add_param(pRequest, "sms_free_sign_name" , "签名" );
add_param(pRequest, "sms_param" , "{securityCode:'123456789'}" );
add_param(pRequest, "rec_num" , "自己的电话" );
add_param(pRequest, "sms_template_code" , "短信模板id" );
pResponse = top_execute(pClient,pRequest,NULL);
printf( "ret code:%d\n" ,pResponse - >code);
if (pResponse - >code = = 0 ){
     pTopResponseIterator ite = init_response_iterator(pResponse);
     pResultItem pResultItem = alloc_result_item();
     while (parseNext(ite, pResultItem) = = 0 ){
         printf( "%s:%s\n" ,pResultItem - >key,pResultItem - >value);
     }
     destroy_response_iterator(ite);
     destroy_result_item(pResultItem);
}
destroy_top_request(pRequest);
destroy_top_response(pResponse);
destroy_taobao_client(pClient);

上面红色代码部分，得到的错误代码一直是25，发不出短信。
还望大家不吝赐教。
为什么不直接问官方技术支持呢？
查看函数的官方说明，根据函数返回值判断是否成功，以及失败的原因
@赵4老师 官方技术支持说只管他们自己的代码，我们本地代码不归他们管
@paschen 我再看看，实在不行，再来向各位请教
引用 3 楼 wangyuanking 的回复:@赵4老师 官方技术支持说只管他们自己的代码，我们本地代码不归他们管
你把他们的回复直接抄送转发给马云一份！
阿里的傻逼工程师，啥子也不懂。我调试了一下代码，遇到的问题是他们的高级接口要求输入的字符串编码编码必须是utf-8的，而文档里一个字也不提，结果就是返回错误码25。接口文档，这么重要的文档，这么重要的技术细节。。。。。浪费用户的时间。
@audi2  谢谢您的回答
哥们，请问你这个C++的SDK在哪儿找到的，我怎么找不到呀！


有关windows缓冲模式的问题本帖最后由 niexuezhi2384 于 2017-10-21 22:38:33 编辑

C
C++

	
FILE *pf = fopen("E:\\2.txt", "w");
setvbuf(pf, NULL, _IONBF, 0);    //设置无缓冲模式, 即刻生效
fputs("1234567890", pf);	

	
FILE *pf = fopen("E:\\1.txt", "w"); 
fputs("1234567890", pf);  


上面第一段代码, 我设置为无缓冲模式, 在编译运行 *.exe 期间 打开E盘下的1.txt 文档， 里面被写入 字符串 1234567890.

但下面那段代码没有，程序编译运行期间 打开1.txt ，里面为空。 
（程序关闭后再打开1.txt 里面是有字符 1234567890 的）

想问下 如果上面设置是 无缓冲模式， 那下面是什么缓冲模式？ 无缓冲么？还是全缓冲模式？ 为什么？
http://en.cppreference.com/w/c/io/setvbuf
缓冲分为：无缓冲，行缓冲和全缓冲；文件写（若是默认状态）是全缓冲模式（当数据在缓存里达到一定数值则将缓存里的数值刷到文件里），缓存大小是可以配置，一般是是页的整数倍；
标准输入和输出一般是行缓冲；
对于缓存的分类，建议从网上详细查阅一下；
等你调用完colse，才有内容送到文件。
也就是全缓冲模式。
fflush
Flushes a stream.

int fflush( FILE *stream );

Function Required Header Compatibility 
fflush <stdio.h> ANSI, Win 95, Win NT 


For additional compatibility information, see Compatibility in the Introduction.

Libraries

LIBC.LIB Single thread static library, retail version 
LIBCMT.LIB Multithread static library, retail version 
MSVCRT.LIB Import library for MSVCRT.DLL, retail version 


Return Value

fflush returns 0 if the buffer was successfully flushed. The value 0 is also returned in cases in which the specified stream has no buffer or is open for reading only. A return value of EOF indicates an error.

Note   If fflush returns EOF, data may have been lost due to a write failure. When setting up a critical error handler, it is safest to turn buffering off with the setvbuf function or to use low-level I/O routines such as _open, _close, and _write instead of the stream I/O functions.

Parameter

stream

Pointer to FILE structure

Remarks

The fflush function flushes a stream. If the file associated with stream is open for output, fflush writes to that file the contents of the buffer associated with the stream. If the stream is open for input, fflush clears the contents of the buffer. fflush negates the effect of any prior call to ungetc against stream. Also, fflush(NULL) flushes all streams opened for output. The stream remains open after the call. fflush has no effect on an unbuffered stream.

Buffers are normally maintained by the operating system, which determines the optimal time to write the data automatically to disk: when a buffer is full, when a stream is closed, or when a program terminates normally without closing the stream. The commit-to-disk feature of the run-time library lets you ensure that critical data is written directly to disk rather than to the operating-system buffers. Without rewriting an existing program, you can enable this feature by linking the program’s object files with COMMODE.OBJ. In the resulting executable file, calls to _flushall write the contents of all buffers to disk. Only _flushall and fflush are affected by COMMODE.OBJ.

For information about controlling the commit-to-disk feature, see Stream I/O, fopen, and _fdopen.

Example

/* FFLUSH.C */

#include <stdio.h>
#include <conio.h>

void main( void )
{
   int integer;
   char string[81];

   /* Read each word as a string. */
   printf( "Enter a sentence of four words with scanf: " );
   for( integer = 0; integer < 4; integer++ )
   {
      scanf( "%s", string );
      printf( "%s\n", string );
   }

   /* You must flush the input buffer before using gets. */
   fflush( stdin );
   printf( "Enter the same sentence with gets: " );
   gets( string );
   printf( "%s\n", string );
}


Output

Enter a sentence of four words with scanf: This is a test
This
is
a
test
Enter the same sentence with gets: This is a test
This is a test


Stream I/O Routines

See Also   fclose, _flushall, setvbuf
windows系统默认无缓冲模式


麻烦帮看一下这些警告是什么意思c语言
入门

才学c语言，这是我的作业，输入3个字符，输出他们组成的三位数
直接用scanf就可以
建议百度scanf_s的具体用法
警告看不懂可以百度翻译 全是字面意思
在每个最后不带\n的printf后面加fflush(stdout);
在每个不想受接收缓冲区旧内容影响的scanf前面加rewind(stdin);
另外请检查scanf的返回值。
//请今后要用
char c;
scanf("%c",&c);
//时，都改为
char s[2];
char c;
scanf("%1s",s);
c=s[0];
//自动跳过一个或多个空格或Tab字符或回车换行，读取下一个字符。

#pragma warning(disable:4996)
建议了解一下scanf_s的用法，尤其是和scanf的区别，用法的不同；
试一下这种使用方法：
scanf_s("%c %c %c", &ch1, 1, &ch2, 1, &ch3, 1);
scanf_s没有用过，建议使用常用的函数比如好理解一些
scanf_s要求在每个字符或者字符串后面，要有1个表示缓冲区大小的参数
输入一个字符，除了要 &ch1，后面还要个长度参数，这里是1。scanf_s("%c %c %c", &ch1, 1, &ch2, 1, &ch3, 1);
回贴后才发现3楼已经有正解。
可以使用：scanf()函数，但是在文件的顶部加上一句：#define _CRT_SECURE_NO_WARNINGS来屏蔽报警O(∩_∩)O
最好用scanf函数想直接输入scanf("%c,%c,%c",&ch1,&ch2,&ch3);


为什么程序运行会崩溃？本帖最后由 Martin_J 于 2017-10-26 16:44:00 编辑

C语言
循环结构

                  我想求一个各位数之和为9且能被5整除的五位数，想用字符数组比较方便，为什么运行的时候会崩溃呢？
#include <stdio.h>
#include<math.h>

int main()
{
    char a[5]={0};
    int i=10000,j=0,sum=0,n=0;
    for (i;i<100000;i+=5)
    {
        sprintf(a,"%d",i);
        for (j;j<5;j++)
            sum+=a[i];
        if (sum=9) n++;
    }
    printf("%d",n);
    return 0;
}
数组下标越界
a[5]={0}；a是一个有5个元素的数组。sum+=a[i];你的i从10000开始，a[10000]a[100005]这些都是不存在的，所以数组下标越界，内存指针错误，直接报错终止程序
#include <stdio.h>
#include<math.h>
 
int main()
{
    char a[5]={0};
    int i=10000,j=0,sum=0,n=0;
    for (i;i<100000;i+=5)
    {
        sprintf(a,"%d",i);
        for (j = 0;j<5;j++)
            sum+=a[j];    // 越界访问
        if (sum=9) n++;
    }
    printf("%d",n);
    return 0;
}

越界访问是未定义行为；
把a[i]改成a[j]；同时j = 0;初始化加入for循环中；

代码写的时候也要多细心些
i改成j， 这就是传说中的低级错误
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
还有一个问题： if (sum=9) n++;是赋值符而==才是等于符，改正如下：
 if (sum==9) n++;O(∩_∩)O
if (sum=9) 改成： if (sum==9)
此外，sum+=a[i];应该是sum+=a[j];吧，用i已经越界了
谢谢大家的指正
然而我还是实现不了我想要的效果。是不是sprintf函数我用的不对？
我又帮你作了修改：
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<math.h>

int main()
{
	char a[5] = { 0 };
	int i = 10000, n = 0;
	for (i; i<100000; i += 5)
	{
		sprintf(a, "%d", i);
		int j = 0,sum=0;
		for (j; j<5; j++)
			sum += a[j];
		sum -= 240;//修正到数字正常的值
		if (sum ==9) n++;
	}
	printf("%d", n);
	return 0;
}仅供参考


关于派生类内名字查找的一点疑问#include<iostream>

using namespace std;

struct Base
{
	virtual void memfcn() { cout << "Base::memfcn()!" << endl; }
};

struct Derived : Base
{
	void memfcn(int) { cout << "Derived::memfcn()!" << endl; }
};

int main()
{
	Base b; 
	Derived d;
	Base* p = &d;
	d.memfcn(10);   //d.memfcn()会报错，参数不对
	p->memfcn();
	system("pause");
	return 0;
}
20行改为d.memfcn();会报错，原因是编译时解析，名字查找优先于类型检查，而派生类中memfc(int)函数隐藏了从基类继承来的memfuc()函数，但是21行调用，实际绑定的类型是Derived，虽然是在运行时解析，但是查找的过程不应该还是在派生类内进行吗？还是说因为是动态调用，这时只考虑virtual function，非虚函数直接不看了，所以不会造成隐藏？
希望得到解答！谢谢！
参考g++源代码相关片断？
名称查找是在编译时进行的，就是在Base里查找。
咋就那么多0粉贴呢


已知两条直线和鼠标所在点，求经过鼠标所在点并且与两线相切的圆Qt     
C++

                  计算公式是有的，但是不同与我们手动计算用的是常量，C++方式计算太多繁琐，求各位大神指点
不愿意动脑子想公式了，列出来公式看看。
引用 1 楼 zjq9931 的回复:不愿意动脑子想公式了，列出来公式看看。

1. 两直线交点 Intersect（简称I） 、鼠标所在点P、 要求的圆心O、 要求的圆的半径R、 交点I到圆心O的距离L、 两线夹角A
2. R = sqrt(  (Xp - Xo)² + （Yp - Yo）²  );
3. L = sqrt(  (Xi - Xo)² + （Yi - Yo）²  );
4. sinα = R / L;
5. y = kx + b
6. k、 b都可以通过角平分线所在直线line0 与 屏幕的左边线 line1(QPointF(0, 0), QPointF(0, 1080))相交得到的点带入求出
两条平行的直线没想过的哟
计算几何大牛:http://www.codeproject.com/KB/recipes/Wykobi.aspx
引用 5 楼 MyCout 的回复:两条平行的直线没想过的哟

平行线好算 这里不考虑
引用 6 楼 zhao4zhong1 的回复:计算几何大牛:http://www.codeproject.com/KB/recipes/Wykobi.aspx

链接出问题了   再有就是全英文 看得很糊涂
引用 楼主 Ilson_ 的回复:计算公式是有的，但是不同与我们手动计算用的是常量，C++方式计算太多繁琐，求各位大神指点
卡在了，将公式转成代码方面？
引用 9 楼 zjq9931 的回复:Quote: 引用 楼主 Ilson_ 的回复:
计算公式是有的，但是不同与我们手动计算用的是常量，C++方式计算太多繁琐，求各位大神指点
卡在了，将公式转成代码方面？
这个对我来说简单得很。
有偿提供帮助。QQ：511606848



如何有选择的对数组进行操作#include<stdio.h>

int a[3] = {1,2,3};
int b[3] = {2,3,4];
int c[3] = {4,5,6};

viod f() //进行如求数组和
{
}
int main()
{ 
   这有个用户输入，想要求和的数组
   f()      //将用户想要求的数组，放入函数

    return 0;
}
//想要实现这么一个功能，有大神指点吗？
//注意：用户相求的在a，b,c中选，（switch的想法除外），还有别的方法吗？
用二维数组？输入的话就可以是int了，返回一个新的一维数组。怎么样？
能具体写下思路吗？
根据你说的，我突然想到可以给每个数组再加一个（数字）标识，这样就可以解决
我问个比较笨的问题，数组a【3】最前面的是存放它的地址，可以用标识a得到其地址，然后传入函数进行运算，这样可以实现吗？
函数参数
求和的函数 void f(int* arr, int num);
根据用户输入，调用f的时候给不同的数组做参数
引用 2 楼 Wezty 的回复:能具体写下思路吗？
根据你说的，我突然想到可以给每个数组再加一个（数字）标识，这样就可以解决
我问个比较笨的问题，数组a【3】最前面的是存放它的地址，可以用标识a得到其地址，然后传入函数进行运算，这样可以实现吗？
#include <stdio.h>

int a[3] = {1,2,3};
int b[3] = {2,3,4};
int c[3] = {4,5,6};
int arr[3][3];

//addArr加的数组序号，addedArr被加的数组需要,用指针传递结果
void fun(int addArr, int addedArr,int *result)
{
    for(int i=0;i<3;++i)        //组成一个二维数组
    {
        arr[0][i] = a[i];
        arr[1][i] = b[i];
        arr[2][i] = c[i];
    }

    for(int i=0;i<3;++i)    //对应数组相加
    {
        result[i] = arr[addArr][i] + arr[addedArr][i];
    }

    return;
}

int main()
{
    unsigned int add1,add2;
    int ret[3];
    scanf("%d %d", &add1, &add2);
    if(add1<3 && add2<3)
    {
        fun(add1, add2, ret);

        for(int i=0;i<3;++i)
            printf("result[%d] = %d\n", i, ret[i]);
    }
    else
        printf("input error.\n");

    return 0;
}


一个循环中，键入一个p，就暂停循环，怎么实现？C
C++
循环
倒计时

头文件啥的我就省略了，以下是循环体： 
循环算法没问题，假设倒计时进行到一半，键入“p”让他暂停循环，可以实现吗？？
求大神指教
while(1)
			{
				Sleep(1000);
				Beep(1000,200);
				second=second-1;
				if(second==-1)
				{
					second=59;minute--;
			 		if(minute==-1)
					{
    					minute=59;hour--;
    					if(hour==-1)                            
    					{
    						hour=23;day--;
    						if(day==-1)
    						{
    					 	cout<<"time up!"<<endl;
						 	break;
    						}
    						
 						}
			 		}
			 		
			 	}
		 	system("cls");
			cout<<day<<"天"<<hour<<"时"<<minute<<"分"<<second<<"秒"<<endl;
		 	}
#include <conio.h>
int k;
//...
while(1) {
    Sleep(1000);
    Beep(1000,200);
    second=second-1;
    if(second==-1) {
        second=59;minute--;
		if(minute==-1) {
			minute=59;hour--;
			if(hour==-1) {
				hour=23;day--;
				if(day==-1)	{
					cout<<"time up!"<<endl;
					break;
				}

			}
		}
	}
	system("cls");
    cout<<day<<"天"<<hour<<"时"<<minute<<"分"<<second<<"秒"<<endl;
    if (_kbhit()) {
        k=getch();
        if (0==k||0xe0==k) k|=getch()<<8;//非字符键
        if (k=='p' || k=='P') {//暂停Pause
            while (1) {//清除缓冲的所有按键
                if (_kbhit()) {
                    k=getch();
                    if (0==k||0xe0==k) k|=getch()<<8;//非字符键
                } else break;
            }
            k=getch();//等待按任意键
            if (0==k||0xe0==k) k|=getch()<<8;//非字符键
        } else if (k=='s' || k=='S') {//停止Stop
            break;
        }
    }
}


C++服务器与安卓客户端通过http协议通讯c++
安卓
通讯

                  学校最近有个小项目要求组队写一个安卓app，需要连接数据库的那种。我负责写服务器，队友写客户端
我看网上都是java写客户端和服务器，通过HttpClient就可以实现通信，服务器好像也是调用Http*的API就可以解析http请求。
但是我比较偏向用C++，也在C++网络方面摸爬滚打两三个月了，所以想尝试用C++实现服务器和与数据库,然后和java写的安卓客户端通信，队友应该还是用Java写客户端。
通信方式是短连接，比较适合用Http协议，就是客户端发送请求，服务器从数据库取出数据发回去就完成的那种，不需要服务器主动发送数据给客户端
我的问题是
如果我用C++写服务器，是不是就需要我手动解析安卓发来的http请求，然后转成Json数据再发回去呢？
既然Http是短连接，我服务器用socket监听后进行一次连接-通信是不是就可以close掉连接了？
用C++写和用java写不会差别太多把？
socket都是一样的-协议什么的不会变-接口定好就行-服务器端端和客户端编程语言无所谓
1如果我用C++写服务器，是不是就需要我手动解析安卓发来的http请求，然后转成Json数据再发回去呢？
2既然Http是短连接，我服务器用socket监听后进行一次连接-通信是不是就可以close掉连接了？
3用C++写和用java写不会差别太多把？

1是的
2是的
3是的

你这问题不是自己都想好答案了吗。。
1，是，http作为超文本协议，头和体是有一定格式要求的，具体可通过抓包来分析。响应头和请求头是不太一样的，不能简单复制。
2，可以，不过其实http还有一个叫Keep-alive的连接模式，带这个头的请求更希望服务器不要在响应后立即断开连接。毕竟tcp每次连接都要三次握手。
3，业务逻辑不会差距很大吧，只是为特定服务开发的话，基本只是字符串解析而已。

关于这块其实可以参考一下别人的开源库，比如HPSocket之类的会好一点。
引用 2 楼 c464580613的回复:1如果我用C++写服务器，是不是就需要我手动解析安卓发来的http请求，然后转成Json数据再发回去呢？
2既然Http是短连接，我服务器用socket监听后进行一次连接-通信是不是就可以close掉连接了？
3用C++写和用java写不会差别太多把？

1是的
2是的
3是的

你这问题不是自己都想好答案了吗。。
因为头次接触java和c++交互，有点不确定
引用 3 楼 lei47yu的回复:1，是，http作为超文本协议，头和体是有一定格式要求的，具体可通过抓包来分析。响应头和请求头是不太一样的，不能简单复制。
2，可以，不过其实http还有一个叫Keep-alive的连接模式，带这个头的请求更希望服务器不要在响应后立即断开连接。毕竟tcp每次连接都要三次握手。
3，业务逻辑不会差距很大吧，只是为特定服务开发的话，基本只是字符串解析而已。

关于这块其实可以参考一下别人的开源库，比如HPSocket之类的会好一点。
理解了。非常感谢！！


转义的奇怪问题转义

                  tempStr[1]明明是0XAA，却不进函数体，不知道什么原因，急啊
void transferStr(char tempStr[29], int tempStrLen, char rawStr[29], int &rawDataLen){
	//EF转义为0XAA,0XBB,EE转义为0XCC,0XDD
	int j = 0;
	int tempLen = tempStrLen;
	memcpy(rawStr, tempStr, 29);
	rawDataLen = tempStrLen;
	for (int i = 0; i < tempLen - 2; i++){
		if ((tempStr[i + 1] ==0xaa)){
			rawStr[i] = 0xEF;
			for (j = i + 1; j < tempLen; j++){
				rawStr[j] = rawStr[j + 2];
			}
			rawDataLen -= 2;
		}
		if ((tempStr[i] == 0x22) && (tempStr[i + 1] == 0xcc) && (tempStr[i + 2] == 0xdd)){
			rawStr[i] = 0xEE;
			for (j = i + 1; j < tempLen; j++){
				rawStr[j] = rawStr[j + 2];
			}
			rawDataLen -= 2;
		}
	}
}

unsigned int main(unsigned int argc, unsigned char* argv[])
{
	//unsigned char unsigned input[1000];
	unsigned int data[1000];
	unsigned int plaintext[4][4], ciphertext[4][4], L[4][4];
	unsigned int i, j, n, num, p, q, len, temp1, temp2;
	//num =25;
	AESCMac macAes(key1);
	unsigned int type = 0;
	for (i = 0; i < 4; i++){
		for (j = 0; j < 4; j++)
		{
			ciphertext[i][j] = 0;
			L[i][j] = 0;
		}
	}
	string Base64Buf ="gHkXrweAAQACzu2ntYGs6/ByUoaTJ8mFAZoisDc=";
	//string Base64Buf = "YHkXrwcgigYCpD1r";

	unsigned char aesEncodeBuf[1024];
	int length = strlen(Base64Buf.c_str());
	macAes.DecodeBASE64((char*)aesEncodeBuf, (char*)Base64Buf.c_str(), strlen(Base64Buf.c_str()));
	//macAes.DecodeBASE64((char*)Base64Buf.c_str(), aesEncodeBuf, strlen(Base64Buf.c_str()));
	/*unsigned char input[29] = { 
		0x80, 0x79, 0x17, 0xaf, 0x07,
		0x00, 0x29, 0x00, 0x02, 0x1e,
		0xbb, 0x79, 0xf5, 0xc9, 0x91,
		0x57, 0xe8, 0x5d, 0x44, 0xa0,
		0xef, 0x9a, 0x71, 0x99, 0xcb,
		0x38, 0x15, 0x18, 0x00 };*/

	unsigned char input[29] = { 0x80, 0x79, 0x17, 0xaf, 0x07, 
		0x80, 0x01, 0x00, 0x02, 0xce, 0xed, 0xa7, 0xb5, 0x81, 
		0xac, 0xeb, 0xf0, 0x72, 0x52, 0x86, 0x93, 0x27, 0xc9, 
		0x85, 0x01, 0x9a, 0x22, 0xb0, 0x37
	};

	char input1[29] = { 0x22, 0xaa, 0xbb, 0xaf, 0x07,
		0x80, 0x01, 0x00, 0x02, 0x22, 0xaa, 0xbb, 0xb5, 0x81,
		0xac, 0x22, 0xaa, 0xbb, 0x52, 0x86, 0x93, 0x27, 0xc9,
		0x85, 0x01, 0x9a, 0x22, 0xb0, 0x37
	};

	char input2[29] = { 0x80, 0x79, 0x17, 0xaf, 0x07,
		0x80, 0x01, 0x00, 0x02, 0x22, 0xaa, 0xbb, 0xb5, 0x81,
		0xac, 0x22, 0xaa, 0xbb, 0x52, 0x86, 0x93, 0x27, 0xc9,
		0x85, 0x01, 0x9a, 0x22, 0xb0, 0x37
	};


	//unsigned char buf0[60];
	//len = 4;
	//n=num/16;
	//j=0;
	//for(i=0;i<num;i++)  //将输入的字符转化成8bits的数字
	//{
	//	data[i] = input[i];
	//}

	//LoadMacKey((unsigned char*)key);//加载MAC key  
	//GenerateMAC(19, (unsigned char*)input, MAC);// 



	//macAes.LoRaMacComputeMic(aesEncodeBuf, 29, key1, 0x07af1779, 1, 0, MAC);
	//macAes.LoRaMacPayloadEncrypt(input, 16, key, 0x55555555, 0, 1, buf0);
	//macAes.LoRaMacPayloadDecrypt(aesEncodeBuf+9, 16, key2, 0x07af1779, 1, 1, buf0);
	int length1 = 0;
	transferStr(input1, 29,input2,length1);
	return 0;
}
请那些喜欢将数组作为函数参数传来传去或作为函数返回值的码农思考一下为什么不把整个互联网内容当作函数参数传来传去或作为函数返回值呢？
一看这代码，毛估估就是数组越界了


链接时出现问题，大神帮忙看一下，一直没找到问题，谢谢！#include<stdio.h>
#include<iostream>
void main()
{
void exchange(int *q1,int *q2,int *q3); //使用该函数前必须声明
int a=9;
int b=0;
int c=10;
int *p1,*p2,*p3;
p1=&a;
p2=&b;
p3=&c;
exchange(p1,p2,p3);
printf("\n%d,%d,%d\n",a,b,c);
}

void exchange(int *q1,int *q2,int *q3)  //该函数用来交换q1,q2,q3的值，使得三者的值由大到小的顺序排序
{
void swap(int *pt1,int *pt2);
if(*q1<*q2) swap(q1,q2);
if(*q1<*q3) swap(q1,q3);
if(*q2<*q3) swap(q2,q3);
}

void swap(int *pt1,int *pt2)           //该函数用来交换pt1和pt2的值
{
int temp;
temp=*pt1;
*pt1=*pt2;
*pt2=temp;
}
前向声明不是写在函数里面，是写在外面的。
#include<stdio.h>
#include<iostream>

void exchange(int *q1, int *q2, int *q3); //使用该函数前必须声明
void swap(int *pt1, int *pt2);

void main()
{
	int a = 9;
	int b = 0;
	int c = 10;
	int *p1, *p2, *p3;
	p1 = &a;
	p2 = &b;
	p3 = &c;
	exchange(p1, p2, p3);
	printf("\n%d,%d,%d\n", a, b, c);
	system("pause");
}

void exchange(int *q1, int *q2, int *q3)  //该函数用来交换q1,q2,q3的值，使得三者的值由大到小的顺序排序
{
	if (*q1<*q2) swap(q1, q2);
	if (*q1<*q3) swap(q1, q3);
	if (*q2<*q3) swap(q2, q3);
}

void swap(int *pt1, int *pt2)           //该函数用来交换pt1和pt2的值
{
	int temp;
	temp = *pt1;
	*pt1 = *pt2;
	*pt2 = temp;
}
swap没有在前面声明吧
#include<stdio.h>
#include<iostream>

    void exchange(int *q1,int *q2,int *q3);
void swap(int **pt1,int **pt2);

int main()
{
    int a=9;
    int b=0;
    int c=10;
    int *p1,*p2,*p3;
    p1=&a;
    p2=&b;
    p3=&c;
    exchange(p1,p2,p3);
    printf("\n%d,%d,%d\n",a,b,c);

    return 0;
}

void exchange(int *q1,int *q2,int *q3)
{
    if(*q1<*q2) swap(&q1, &q2);
    if(*q1<*q3) swap(&q1, &q3);
    if(*q2<*q3) swap(&q2, &q3);
}

void swap(int **pt1,int **pt2)
{
    int temp;
    temp = **pt1;
    **pt1 = **pt2;
    **pt2 = temp;
}
建议了解一下一重指针和二重指针
你的代码中有#include<iostream>，这是C++的头文件，C编译器是不支持的
可能你用的是C的编译器编译你的程序，所以出错
你将#include<iostream>这句删除即可
仅供参考：#include <stdio.h>
#define SWAP(a,b) do ((&(a))!=(&(b)))?((a)^=(b)^=(a)^=(b)):((a)=(a)); while (0)
char   *p1="1" ,*p2="2" ;
char    c1=1   , c2=2   ;
short   s1=1   , s2=2   ;
int     i1=1   , i2=2   ;
__int64 I1=1i64, I2=2i64;
float   f1=1.0f, f2=2.0f;
double  d1=1.0 , d2=2.0 ;
void main() {
    SWAP((int)p1,(int)p2);                printf("char *     %5s,   %5s\n",p1,p2);
    SWAP(c1,c2);                          printf("char       %5d,   %5d\n",c1,c2);
    SWAP(s1,s2);                          printf("short      %5d,   %5d\n",s1,s2);
    SWAP(i1,i2);                          printf("int        %5d,   %5d\n",i1,i2);
    SWAP(I1,I2);                          printf("__int64 %5I64d,%5I64d\n",I1,I2);
    SWAP(*(int     *)&f1,*(int     *)&f2);printf("float      %5g,   %5g\n",f1,f2);
    SWAP(*(__int64 *)&d1,*(__int64 *)&d2);printf("double    %5lg,  %5lg\n",d1,d2);

    SWAP(c1,c1);
    printf("%d\n",c1);
}
//char *         2,       1
//char           2,       1
//short          2,       1
//int            2,       1
//__int64     2,    1
//float          2,       1
//double        2,      1
//2


如何使用OnCtlColor消息函数对BUTTON设置不同的颜色本帖最后由 martin_tang 于 2015-10-18 23:23:11 编辑

MFC
CtlColor

                  我的目的：程序中有BUTTON控件，IDC_BUTTON3  现在需要设置其字体大小和颜色
做到下面这种程度，debug过了，确实是执行了，但字体大小和颜色没有任何变化～


HBRUSH Csunboxtest11Dlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CDialogEx::OnCtlColor(pDC, pWnd, nCtlColor);
  switch (pWnd->GetDlgCtrlID() ) 
	   {
              case IDC_BUTTON3 :
                    {
                         m_font.CreatePointFont( 300,_T("Helvetica"),NULL );
                            pDC->SelectObject(&m_font); 
                            pDC->SetTextColor(RGB(100,255,100));
                             pDC->SetBkColor(RGB(0,255,0));

	               }  

               }  
	return hbr;
         }




睡不着了
请教请教请教请教请教请教请教请教请教请教请教请教请教请教请教请教请教请教～～～～～
CWnd::OnCtlColor  
afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor );

Return Value

OnCtlColor must return a handle to the brush that is to be used for painting the control background.

Parameters

pDC

Contains a pointer to the display context for the child window. May be temporary.

pWnd

Contains a pointer to the control asking for the color. May be temporary.

nCtlColor

Contains one of the following values, specifying the type of control: 

CTLCOLOR_BTN   Button control


CTLCOLOR_DLG   Dialog box


CTLCOLOR_EDIT   Edit control


CTLCOLOR_LISTBOX   List-box control


CTLCOLOR_MSGBOX   Message box


CTLCOLOR_SCROLLBAR   Scroll-bar control


CTLCOLOR_STATIC   Static control 
Remarks

The framework calls this member function when a child control is about to be drawn. Most controls send this message to their parent (usually a dialog box) to prepare the pDC for drawing the control using the correct colors.

To change the text color, call the SetTextColor member function with the desired red, green, and blue (RGB) values. 

To change the background color of a single-line edit control, set the brush handle in both the CTLCOLOR_EDIT and CTLCOLOR_MSGBOX message codes, and call the CDC::SetBkColor function in response to the CTLCOLOR_EDIT code.

OnCtlColor will not be called for the list box of a drop-down combo box because the drop-down list box is actually a child of the combo box and not a child of the window. To change the color of the drop-down list box, create a CComboBox with an override of OnCtlColor that checks for CTLCOLOR_LISTBOX in the nCtlColor parameter. In this handler, the SetBkColor member function must be used to set the background color for the text.

Note   This member function is called by the framework to allow your application to handle a Windows message. The parameters passed to your function reflect the parameters received by the framework when the message was received. If you call the base-class implementation of this function, that implementation will use the parameters originally passed with the message and not the parameters you supply to the function.

CWnd Overview |  Class Members |  Hierarchy Chart

See Also   CDC::SetBkColor
引用 1 楼 zhao4zhong1 的回复:CWnd::OnCtlColor  
afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor );

Return Value

OnCtlColor must return a handle to the brush that is to be used for painting the control background.

Parameters

pDC

Contains a pointer to the display context for the child window. May be temporary.

pWnd

Contains a pointer to the control asking for the color. May be temporary.

nCtlColor

Contains one of the following values, specifying the type of control: 

CTLCOLOR_BTN   Button control


CTLCOLOR_DLG   Dialog box


CTLCOLOR_EDIT   Edit control


CTLCOLOR_LISTBOX   List-box control


CTLCOLOR_MSGBOX   Message box


CTLCOLOR_SCROLLBAR   Scroll-bar control


CTLCOLOR_STATIC   Static control 
Remarks

The framework calls this member function when a child control is about to be drawn. Most controls send this message to their parent (usually a dialog box) to prepare the pDC for drawing the control using the correct colors.

To change the text color, call the SetTextColor member function with the desired red, green, and blue (RGB) values. 

To change the background color of a single-line edit control, set the brush handle in both the CTLCOLOR_EDIT and CTLCOLOR_MSGBOX message codes, and call the CDC::SetBkColor function in response to the CTLCOLOR_EDIT code.

OnCtlColor will not be called for the list box of a drop-down combo box because the drop-down list box is actually a child of the combo box and not a child of the window. To change the color of the drop-down list box, create a CComboBox with an override of OnCtlColor that checks for CTLCOLOR_LISTBOX in the nCtlColor parameter. In this handler, the SetBkColor member function must be used to set the background color for the text.

Note   This member function is called by the framework to allow your application to handle a Windows message. The parameters passed to your function reflect the parameters received by the framework when the message was received. If you call the base-class implementation of this function, that implementation will use the parameters originally passed with the message and not the parameters you supply to the function.

CWnd Overview |  Class Members |  Hierarchy Chart

See Also   CDC::SetBkColor


我就是这么使用的啊， 还有其他可能性吗？？
引用 1 楼 zhao4zhong1 的回复:CWnd::OnCtlColor  
afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor );

Return Value

OnCtlColor must return a handle to the brush that is to be used for painting the control background.

Parameters

pDC

Contains a pointer to the display context for the child window. May be temporary.

pWnd

Contains a pointer to the control asking for the color. May be temporary.

nCtlColor

Contains one of the following values, specifying the type of control: 

CTLCOLOR_BTN   Button control


CTLCOLOR_DLG   Dialog box


CTLCOLOR_EDIT   Edit control


CTLCOLOR_LISTBOX   List-box control


CTLCOLOR_MSGBOX   Message box


CTLCOLOR_SCROLLBAR   Scroll-bar control


CTLCOLOR_STATIC   Static control 
Remarks

The framework calls this member function when a child control is about to be drawn. Most controls send this message to their parent (usually a dialog box) to prepare the pDC for drawing the control using the correct colors.

To change the text color, call the SetTextColor member function with the desired red, green, and blue (RGB) values. 

To change the background color of a single-line edit control, set the brush handle in both the CTLCOLOR_EDIT and CTLCOLOR_MSGBOX message codes, and call the CDC::SetBkColor function in response to the CTLCOLOR_EDIT code.

OnCtlColor will not be called for the list box of a drop-down combo box because the drop-down list box is actually a child of the combo box and not a child of the window. To change the color of the drop-down list box, create a CComboBox with an override of OnCtlColor that checks for CTLCOLOR_LISTBOX in the nCtlColor parameter. In this handler, the SetBkColor member function must be used to set the background color for the text.

Note   This member function is called by the framework to allow your application to handle a Windows message. The parameters passed to your function reflect the parameters received by the framework when the message was received. If you call the base-class implementation of this function, that implementation will use the parameters originally passed with the message and not the parameters you supply to the function.

CWnd Overview |  Class Members |  Hierarchy Chart

See Also   CDC::SetBkColor


“The parameters passed to your function reflect the parameters received by the framework when the message was received. If you call the base-class implementation of this function, that implementation will use the parameters originally passed with the message and not the parameters you supply to the function.”
这句话吗？可是怎么理解
MSDN98_1.ISO http://pan.baidu.com/s/1dDF41ix,  MSDN98_2.ISO http://pan.baidu.com/s/1bnGo0Vl
先下载安装MSDN98

再参考：
MSDN98\SAMPLES\VC98\APPWIZ\HIERWIZ\CSTM1DLG.CPP
MSDN98\SAMPLES\VC98\MFC\OLE\TSTCON\TCSPLIT.CPP
？
重载OnCtlColor只能改变窗体和STATIC的颜色，而对于Button则不行
要怎么修改Button的颜色请看：http://bbs.csdn.net/topics/60377907
从CButton派生一个类，然后在那个派生类中自绘按钮，就是在DrawItem函数中绘制
引用 7楼爱你哈哈_ 的回复:从CButton派生一个类，然后在那个派生类中自绘按钮，就是在DrawItem函数中绘制如果我有6个按钮，需要不同字体颜色，需要每一个都生成一个类然后实例化吗？
引用 6楼paschen 的回复:要怎么修改Button的颜色请看：http://bbs.csdn.net/topics/60377907那篇文字并没有实际解决吧……
引用 8 楼 martin_tang的回复:Quote: 引用 7楼爱你哈哈_ 的回复:从CButton派生一个类，然后在那个派生类中自绘按钮，就是在DrawItem函数中绘制如果我有6个按钮，需要不同字体颜色，需要每一个都生成一个类然后实例化吗？
你可以设置一个接口，供外部调用的，比如说SetButtonColor,某个按钮要什么颜色调用就好了
1、字体字形在Init中创建CFONT， GetDlgItem(IDC_BUTTON1)->SetFont(f);
2、颜色在OnDrawItem中SetTextColor实现
OnCtrlColor()是无法改变按钮的颜色的
可以重写DrawItem（），将m_clrFace改为你要的颜色


求问二维数组怎样写入二进制文件。。。。小弟在自学c，在c primer plus 上有一道题是一架航班每天飞4班，然后实现座位号预定位置什么的各种信息，
要求貌似都可以实现，但就是写进文件这里实现不了。。。。求教一下。。。。

void f_read(struct seat (*st)[SEAT])
{
	int i;
	FILE *fp;
	if((fp=fopen("seats.dat","rb+"))==NULL)
	{
		fprintf(stderr,"Error");
		exit(1);
	}
	for(i=0;i<AIR;i++)
	fread(&st[i][SEAT],sizeof(struct seat),1,fp);
	fclose(fp);

}
void f_write(struct seat (*st)[SEAT])
{
	int i;
	FILE *fp;
	if((fp=fopen("seats.dat","wb+"))==NULL)
		exit(2);
	for(i=0;i<AIR;i++)
	fwrite(&st[i][SEAT],sizeof(struct seat),1,fp);
	fclose(fp);
}
FILE 文件操作
搜“序列化 反序列化”
www.json.org
引用 2 楼 zhao4zhong1 的回复:搜“序列化 反序列化”
www.json.org
谢谢！！刚刚我又在网上查了一下，原来是fread和fwrite里的参数写错了。。。。。现在解决了

这位老师。。。。。第一次看到你头像的时候就觉得是不是初中的数学老师在回答别人问题。。。。。你们长得简直一毛一样

还有就是我第一次发帖，不知道要给分的。。。。。抱歉啊
引用 3 楼 losercat 的回复:Quote: 引用 2 楼 zhao4zhong1 的回复:
搜“序列化 反序列化”
www.json.org
谢谢！！刚刚我又在网上查了一下，原来是fread和fwrite里的参数写错了。。。。。现在解决了

这位老师。。。。。第一次看到你头像的时候就觉得是不是初中的数学老师在回答别人问题。。。。。你们长得简直一毛一样

还有就是我第一次发帖，不知道要给分的。。。。。抱歉啊
没准你遇到了我失散多年的孪生兄弟。


简单的代码，一看就懂。结果却不对，为什么c/c++

#include <stdio.h>
#include <assert.h>

int main()
{
	double a, b, c,d;
	printf("请输入两个数：A和B\n");
	scanf("%lf,%lf\n", &a, &b);
	assert(b != 0);
	c = a / b;
	printf("%lf\n", c);
        return 0;
}

结果：

什么地方出了问题呢？脑子有点糊，昨晚没睡好，自己没看出来。
是不是初始化的问题？
输入的时候少个逗号；
或者直接将代码里的逗号去掉，重新编译然后按照你现在的格式输入也是可行的。
#include <stdio.h>
#include <assert.h>

int main()
{
	double a, b, c,d;
	printf("请输入两个数：A和B\n");
	scanf("%lf%lf", &a, &b);
	assert(b != 0);
	c = a / b;
	printf("%lf\n", c);
        return 0;
}

把第12行的逗号和\n符号去掉就正常了
你的第八行代码，是我的vc6的12行
double a, b, c,d;
    printf("请输入两个数：A和B\n");
    scanf("%lf%lf", &a, &b);
    assert(b != 0);
    c = a / b;
    printf("%lf\n", c);

	getchar();
	getchar();
		getchar();
	getchar();
        return 0;
浮点数不能判断精确的相等
printf输出double的时候，最好不用%lf，不是每个编译器都支持的，直接用%f
scanf("%lf,%lf\n", &a, &b);这一句代码中多了一个逗号
改成scanf("%lf %lf\n", &a, &b);
scanf("%lf,%lf\n", &a, &b); 改成 scanf("%lf%lf\n", &a, &b);

或者输入的时候用逗号分隔，而不是空格
根据你的代码，输入应该是4,2中间的逗号少不了，格式匹配问题
scanf格式的问题，注意格式匹配问题就可以。
仅供参考：#include <stdio.h>
int main()
{
    int a,b,n,v,r,k;
    char buf[80];
    char *p;

    k=0;
    r=EOF;
    while (1) {
        if (EOF==r) {
            fgets(buf,80,stdin);
            p=buf;
        }
        while (1) {
            r=sscanf(p,"%d%n",&v,&n);
            if (1==r) {k++;break;}
            if (EOF==r) break;
            p++;
        }
        if (EOF==r) continue;
        p+=n;
        if (1==k) a=v;
        if (2==k) {
            b=v;
            break;
        }
    }
    printf("%d,%d\n",a,b);
    return 0;
}



16位RGB565格式图像数据存储为bmp文件bmp
C++
MFC
RGB565

                  想把下位机传上来的16位RGB565格式图像数据存储为bmp文件，看着网上一些程序改的，不知道哪里写错了，保存后图象显示不对，求指导，谢谢

代码如下：
	WORD width = 160;
	WORD height = 160;
	BITMAPFILEHEADER bmfHdr; //定义文件头   
	BITMAPINFOHEADER bmiHdr; //定义信息头   
	RGBQUAD bmiClr[3];	//定义调色板

	bmiHdr.biSize = sizeof(BITMAPINFOHEADER);
	bmiHdr.biWidth = width;//指定图像的宽度，单位是像素
	bmiHdr.biHeight = -height;//指定图像的高度，单位是像素
	bmiHdr.biPlanes = 1;//目标设备的级别，必须是1
	bmiHdr.biBitCount = 16;//表示用到颜色时用到的位数 16位表示高彩色图
	bmiHdr.biCompression = BI_BITFIELDS;//BI_RGB仅有RGB555格式
	bmiHdr.biSizeImage = (width * height * 2);//指定实际位图所占字节数
	bmiHdr.biXPelsPerMeter = 0;//水平分辨率，用象素/米表示。
	bmiHdr.biYPelsPerMeter = 0;//垂直分辨率，用象素/米表示。
	bmiHdr.biClrUsed = 0;//位图实际使用的彩色表中的颜色索引数（设为0的话，则说明使用所有调色板项）
	bmiHdr.biClrImportant = 0;//说明对图象显示有重要影响的颜色索引的数目，0表示所有颜色都重要

	//RGB565格式掩码
	bmiClr[0].rgbBlue = 0;
	bmiClr[0].rgbGreen = 0xF8;
	bmiClr[0].rgbRed = 0;
	bmiClr[0].rgbReserved = 0;

	bmiClr[1].rgbBlue = 0xE0;
	bmiClr[1].rgbGreen = 0x07;
	bmiClr[1].rgbRed = 0;
	bmiClr[1].rgbReserved = 0;

	bmiClr[2].rgbBlue = 0x1F;
	bmiClr[2].rgbGreen = 0;
	bmiClr[2].rgbRed = 0;
	bmiClr[2].rgbReserved = 0;


	bmfHdr.bfType = (WORD)0x4D42;//文件类型，0x4D42也就是字符'BM'
	bmfHdr.bfSize = (DWORD)(sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 3 + width * height * 2);//文件大小
	bmfHdr.bfReserved1 = 0;//保留，必须为0
	bmfHdr.bfReserved2 = 0;//保留，必须为0
	bmfHdr.bfOffBits = (DWORD)(sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)+ sizeof(RGBQUAD) * 3);//实际图像数据偏移量

	CFile fp;
	fp.Open("d:\\Model.bmp", CFile::modeCreate | CFile::modeWrite);
	fp.Write((LPSTR)&bmfHdr, sizeof(BITMAPFILEHEADER)); //	写文件头  
	fp.Write((LPSTR)&bmiHdr, sizeof(BITMAPINFOHEADER)); //	写信息头 
	fp.Write((LPSTR)&bmiClr, sizeof(RGBQUAD) * 3);
	fp.Write((LPSTR)CameraData, width * height * 2);//	写数据
	fp.Close();
可以发一下两张图片的对比。
引用 1 楼 turingo 的回复:可以发一下两张图片的对比。

红框内的图像就是要显示的部分



实际保存后的图像
看起来像是每行的数据没有对齐，应该是少了一些像素或者是对齐数据。

引用 2 楼 kid229305772 的回复:Quote: 引用 1 楼 turingo 的回复:
可以发一下两张图片的对比。

红框内的图像就是要显示的部分



实际保存后的图像
BMP要求每行像素数据的字节数必须是4的倍数，如果不是，补1～3个字节0
已找到原因，16位的像素点被当成是32位的了
应该说是数据类型定义的时候弄错了 小错误 哎
楼主是用C语言写的么，我现在正在学
想要把保存的rjb565 16位 bmp图片指针储存为文件，想向楼主您请教
你好，可以请问下你是怎么把RGB565转位bmp的吗，能看下代码吗


用Qt graphics view实现许多图片围绕中点旋转（具体想实现如图效果）Qt graphics view
这个效果不错，关注。
怎么结贴了


vs2015社区版和vs2013企业版#pragma pack(push,1)无效vs2013
#pragma pack
无效

                  #include "stdafx.h"
#include <iostream>
using namespace std;

#pragma pack(push,1)
struct RateInfo
{
	time_t            tm;
	int               o;
	int               h, l, c;
	double            v;
};

struct MyStruct
{
	bool b;
	int i;
	char c;
};
#pragma pack(pop)

int main(int argc, char* argv[])
{
        cout<<"size_t:"<< sizeof(size_t)<<" int:"<< sizeof(int)<<" double:"<< sizeof(double)<<endl;
	cout << "RateInfo:" << sizeof(RateInfo) << endl;
	cout << "MyStruct:" << sizeof(MyStruct) << endl;
        return 0;
}

输出如下：
size_t:4 int:4 double:8
RateInfo:32
MyStruct:6

关于RateInfo:32怎么理解？
加上
#define _USE_32BIT_TIME_T
后RateInfo:28，正常。

但仍无法说明：
size_t:4 int:4 double:8  //这条显示大小就是28，不加宏也应该这样
RateInfo:32

有知道的XD解释下吗？
用VS2015企业版试下
引用 2 楼 paschen 的回复:用VS2015企业版试下
终于有人回复了，谢谢版主。
现在固态硬盘太小，等新买的硬盘到手再试试吧。

有DS试过，有结果吗？
http://www.cnblogs.com/lazycoding/archive/2011/03/22/sizeof-struct.html
看下这个好像就明白了。
引用 4 楼 mengjiangtao 的回复:http://www.cnblogs.com/lazycoding/archive/2011/03/22/sizeof-struct.html
看下这个好像就明白了。
这篇文档中没有讲到#pragma pack(push,1)这种情况。
谢谢你的关注。


我的疑问工作有些年头了，但是感觉不出自己有多厉害，顶多也就是经验多了点，而在纯粹的技术领域我觉的自己不强，而同时我感觉不仅仅是我，10个程序员里面有8个都是不强的，都是因为某个领域做多了，然后经验多点
主要我想说的是，在技术方面的研究太难了同时也没必要，因为在实际的工作中根本就没用到，学了又会忘，如此反复，太累了

你们觉的呢？
工作3年了-但是感觉每天都有学不完的东西啊楼主不会每天被重复的工作耽误吧我们领导每次都让人开拓新疆土…
饱汉子不知饿汉子饥；
饿汉子不知饱汉子撑。

这山望着那山高。

别人的幸福我享受不到；
我的烦恼别人体会不到。
引用 1 楼 iloveyou418 的回复:工作3年了-但是感觉每天都有学不完的东西啊楼主不会每天被重复的工作耽误吧我们领导每次都让人开拓新疆土…那祝福你，或许再过几年你就会有和我一样的想发了
引用 2 楼 zhao4zhong1 的回复:饱汉子不知饿汉子饥；
饿汉子不知饱汉子撑。

这山望着那山高。

别人的幸福我享受不到；
我的烦恼别人体会不到。
赵老说的是


c++ 构造函数的问题using namespace std;
int main()
{  
	double f(double x);
	int x;
	cout<<"x：";
cin>>x;
double f(double x);



cout<<f(x)<<endl;
system("pause");
	return 0;
}
double f(double x){
	return 0.1*x*x/100;}
这程序构造了 一个函数，执行正确。


那下么代码为啥提示 error C2106: '=' : left operand must be l-value
这个不算已经构造了函数么？
#include<iostream>


using namespace std;
int  main()
{
double f1(double x );
cin>>"x:";
int x;

f1(x)=0.1*x*x/100;

}

system("pause");
	return 0;
}
百度搜索一下什么叫“右值”
using namespace std;
int main()
{  
double f(double x);     //  此处是函数声明（仅仅是告诉程序有这么一个函数）
int x;
cout<<"x：";
cin>>x;
double f(double x);           //    这一句根本就没必要，前面已经声明过了



cout<<f(x)<<endl;                 //  这里的f(x)是函数调用
system("pause");
return 0;
}
double f(double x){                  //      这里是对前面声明的函数的具体实现，也就是函数定义
return 0.1*x*x/100;}
这程序构造了 一个函数，执行正确。


那下么代码为啥提示 error C2106: '=' : left operand must be l-value
这个不算已经构造了函数么？                 //    上面的函数没什么问题，下面的函数就有问题了，分析见下面红色字体

#include<iostream>


using namespace std;
int  main()              //    main 函数里面写的太过混乱
{
double f1(double x );                  //   这里声明了一个函数f1，和上面的函数 f 并不是同一个函数（函数名都不一样），而且在后面也没有定义函数 f1 ，所以这个函数是不完整的。
cin>>"x:";                 
int x;                              //   首先这里输入一个值给到x这个变量要把 x 变量的定义写在输入之前，再一个就是输入是cin>>x; 而不是cin>>"x";

f1(x)=0.1*x*x/100;           //   f1(x)是对函数f1的调用而不是一个变量，它的结果是返回一个double类型的值，应该需要定义一个double型变量来接收它的返回值 而不是写成给一个函数调用赋值（你写的是给一个变量赋值），这一条代码是很有问题的。

}                 //   这个括号应该是多余了

system("pause");
return 0;
}

  对于这段代码的问题我个人的分析和描述详见上面红色字体。对于后半段有问题的代码我修改后的参考代码如下：

#include<iostream>
#include<Windows.h>

using namespace std;
int  main()
{
	double f1(double x );
	int x;
        cin>>x;

	cout<<f1(x)<<endl;       //  直接输出函数f1(x)的返回值
        double y = f1(x);           //   定义一个变量来接收函数返回值

        system("pause");
        return 0;
}

double f1(double x)
{
        return (0.1*x*x/100);
}

希望对你能够有帮助，谢谢~
引用 2 楼 abc_18217053753 的回复:using namespace std;
int main()
{  
double f(double x);     //  此处是函数声明（仅仅是告诉程序有这么一个函数）
int x;
cout<<"x：";
cin>>x;
double f(double x);           //    这一句根本就没必要，前面已经声明过了



cout<<f(x)<<endl;                 //  这里的f(x)是函数调用
system("pause");
return 0;
}
double f(double x){                  //      这里是对前面声明的函数的具体实现，也就是函数定义
return 0.1*x*x/100;}
这程序构造了 一个函数，执行正确。


那下么代码为啥提示 error C2106: '=' : left operand must be l-value
这个不算已经构造了函数么？                 //    上面的函数没什么问题，下面的函数就有问题了，分析见下面红色字体

#include<iostream>


using namespace std;
int  main()              //    main 函数里面写的太过混乱
{
double f1(double x );                  //   这里声明了一个函数f1，和上面的函数 f 并不是同一个函数（函数名都不一样），而且在后面也没有定义函数 f1 ，所以这个函数是不完整的。
cin>>"x:";                 
int x;                              //   首先这里输入一个值给到x这个变量要把 x 变量的定义写在输入之前，再一个就是输入是cin>>x; 而不是cin>>"x";

f1(x)=0.1*x*x/100;           //   f1(x)是对函数f1的调用而不是一个变量，它的结果是返回一个double类型的值，应该需要定义一个double型变量来接收它的返回值 而不是写成给一个函数调用赋值（你写的是给一个变量赋值），这一条代码是很有问题的。

}                 //   这个括号应该是多余了

system("pause");
return 0;
}

  对于这段代码的问题我个人的分析和描述详见上面红色字体。对于后半段有问题的代码我修改后的参考代码如下：

#include<iostream>
#include<Windows.h>

using namespace std;
int  main()
{
	double f1(double x );
	int x;
        cin>>x;

	cout<<f1(x)<<endl;       //  直接输出函数f1(x)的返回值
        double y = f1(x);           //   定义一个变量来接收函数返回值

        system("pause");
        return 0;
}

double f1(double x)
{
        return (0.1*x*x/100);
}

希望对你能够有帮助，谢谢~++
一般函数在用之前是要进行声明的！例如:double f(double x); 记得加上符号，代表声明函数，放在main函数之前。 如果你的f函数写在main函数前就不用。不过建议函数使用前都使用声明，这是良好的习惯。


位数组问题  c和指针第5章第4道题c和指针

                  题目要求

主函数是自定义的
有两个问题：
第一：位数组  定义的 char bit_array[ ],这个字符数组中的元素都是要求必须都是二进制的0或1吗？
第二：这里的unsigned character_offset( unsigned bit_number )和unsigned bit_offset( unsigned bit_number )两个函数是求这个位数组的最高二进制位在第几个字节的第几位，如66位二进制数，int 66/CHAR_BIT=8;66%CHAR_BIT=2;这里应该是第9个字节第二位吗？字节数是从0开始算起的吗？
第三：帮我改一下这个main函数  能够实现这道题的要求

#include <stdio.h>
#include <limits.h>
//#include "bitarray.h"

unsigned character_offset( unsigned bit_number )
{
    return bit_number / CHAR_BIT;                       //计算bit_number第几个字节内
}

unsigned bit_offset( unsigned bit_number )
{
    return bit_number % CHAR_BIT;                       //计算bit_number 在最高字节里是第几位
}
                                          //以上两个函数计算了bit_number在第几个字节的第几位
                                          //如第66位二进制数，在第8个字节的的第二位？？？？
                                          // 我认为是第九个字节的第二位

void set_bit( char bit_array[], unsigned bit_number )    //把指定的位设置为 1
{
    bit_array[ character_offset( bit_number ) ] |=
    1 << bit_offset( bit_number );
}

void clear_bit( char bit_array[], unsigned bit_number )
{
    bit_array[ character_offset( bit_number ) ] &=
    ~ ( 1 << bit_offset( bit_number ) );
}

void assign_bit( char bit_array[], unsigned bit_number, int value )
{
    if( value != 0 )
    set_bit( bit_array, bit_number );
    else
    clear_bit( bit_array, bit_number );
}

int test_bit( char bit_array[], unsigned bit_number )
{
    return (
    bit_array[ character_offset( bit_number ) ] & 1 << bit_offset( bit_number )) != 0;
}


int main()
{
    char bit_array[10] = "100001";
    clear_bit( bit_array, 5 );
    set_bit(bit_array, 5);
    test_bit( bit_array, 6);
    printf( "%c",bit_array[1]);
    return 0;
}


如何取4x4数组中不同行不同列的元素的全部排列例如在
1  2  3  4
5  6  7  8
9 10 11 12
13 14 15 16
中 取全部不同行不同列的元素的排列 
比如 1 6 11 16
       1 7 10 16
取全部排列 想不到怎么写
#include <stdio.h>
int isright(int i,int j, int x,int y)
{
	int a[4]={0,0,0,0};
	a[i]+=1;a[j]+=1;a[x]+=1;a[y]+=1;
	if(a[0]*a[1]*a[2]*a[3]==0)
	    return 0;
	printf("%d,%d,%d,%d>>",i,j,x,y);
	return 1;
}
int main()
{
         int i,j,x,y;
         for(i=1;i<=4;i++)
            for(j=5;j<=8;j++)
               for(x=9;x<=12;x++)
                   for(y=13;y<=16;y++)
                   {
                   	if(isright(i%4,j%4,x%4,y%4))
       	           printf("%d,%d,%d,%d\n",i,j,x,y);
                   }
	     return 0;   
}
如何拓展至n*n呢
http://blog.csdn.net/wangshengfeng1986211/article/details/38366709
http://www.cnblogs.com/wanxiao/p/3607216.html


无GPU下win764+vs2013安装caffe出错在编译build_cpu_only中的MainBuilder时
出现错误，编译matcaffe出现
在编译pycaffe出现
跪求解决方法
求解决啊 求解决


好吧  我又重新来了一遍。在编译matcaffe与pycaffe时，属性-c++-常规，，附加改成自己的matlab与python安装路径
我最后运行caffe，没有出结果，，，，怎么解决


C++类与类的传值问题。A类的私有成员如何传到B类中？类
C++

红色字体的两个部分传值，用了友元但是没有用（也不知道用得对不对），A类的4个成员是要获取运算之后的值，传到B 类中，求各位大神指教
#include <iostream.h>

class A
{
	private:
		int day;
		int hour;
		int minute;
		int second;
	public:
	A(int a,int b,int c,int d)
	{
		day=a;
		hour=b;
		minute=c;
		second=d;
	}
	friend class B;
} ;

class B
{
	private:
		int gday;
		int ghour;
		int gminute;
		int gsecond;
		A oneday;
	public:
		B()
		{
			gday=oneday.day;
			ghour=oneday.hour;
			gminute=oneday.minute;
			gsecond=oneday.second;
		}

};
不要在类外面，即使是声明为友元类，不能用对象直接获取私用成员，要通过类方法。
上面写错了，类友元是可以访问类的私有部分的权限的
在电脑运行了一下。你这个程序本身是存在问题的。这个知识点应该是组合类，你的B类程序中是默认构造函数，没有给类成员A初始化，那么在调用B的构造函数之前，会先调用A的默认构造函数(你这里没有)，所以会提示出错的。如果你要给B的私用成员赋值(也就是你想要的)，你应该在构造函数改为B(A oneday)...，然后调用的时候，给B初始化一个A的对象。


cppcms-1.0.5 windows下编译问题本帖最后由 lovton 于 2017-10-28 08:11:33 编辑

C++
CppCMS

                  系统win8.1，VS2013，zlib库 1.2.7

zlib库 换了zlib-1.2.8, zlib-1.2.11，同样的错误。cppcms换1.1.0也一样。

使用下面命令编译出现错误，不知道怎么解决，百度实在找不到资料，有知道大牛们应该怎么解决？
已经解决，没看清生成的文件。


从控制台向变量输入值出现的问题c语言
控制台

                  大家好，我在练习c语言课后习题时，有一题是输入两个float变量的值，即scanf("%f,%f",&a,&b)。我从控制台输入0,3.14/2时出现错误的计算结果，当输入0,3.14/2.0时结果又与之前的不同了，但结果也是错误的。
于是我怀疑控制台是不是不能接收乘除符号，又实验了一下乘号，输入0,2*1.57后计算结果是对的，输入其它的乘号数，也是对的。
请问控制台不识别除号吗？
抱歉，乘号计算也是错的
你就输入两个运算符然后监控程序中变量的值……你就明白了
控制台能接收 但是无法识别 
那只是一个符号 不是运算符
你得自己按字符去接收运算符，然后判断这个字符是什么运算符，然后采取不同的操作
scanf只是按%s的说明识别输入项。
如果你想输入 0,3.14/2，应该用 scanf("%f,%f/%f", &a, &b, &c)，结果abc分别为0、3.14、2
float a,b;
char c;
while (1) {
 rewind(stdin);
 if (3!=scanf("%f%c%f", &a, &c, &b)) break;
 switch (c) {
  case '*':
   printf("%g*%g=%g\n",a,b,a*b);
  break;
  case '/':
   printf("%g/%g=%g\n",a,b,a/b);
  break;
  default:
  break;
 }
 }
}
第15行多余，删掉。


求助大佬：我编写以下代码:
#define  N  8
int main()
{
     char a[N] = "abcdefg";
     char b[N] = {a};    //不知道这样是否可以，但数组名本质就是首地址，所以就试了试，并没有报错，但结果。。。。
     printf("%s",b);
}
结果屏幕显示一个垂直制表符，这是怎么回事？？？
求助大佬
赋值改一下memcpy（b，a，N）；
至少应该这样吧
char b[N] = {a[0], a[1]};
那直接b[N] = {a}本质是什么？为什么可以这样做？
引用 3 楼 qq_40470949 的回复:那直接b[N] = {a}本质是什么？为什么可以这样做？
把a的值（一个地址）当做字符（一般要截断变短），存入 b[0]
http://edu.csdn.net/course/detail/2344 C语言指针与汇编内存地址-一.代码要素


关于while(scanf("%d", &n) != EOF)无法停止的一些问题c语言；
while scanf;

                  如题 直接上代码：
#include<stdio.h>

int main ()
{
	int a,b,c,i;
	while(scanf("%d%d",&a,&b)!=EOF);
	{
	c=a+b;
	printf("%d\n",c);	
	}
	return 0;
}
题目是输入多组数据（具体多少组未知），然后输出两数字之和。但遇到的问题是不知道怎么让这个输入停下来，并且每输入两个数据并没有相应的c输出出来。我用的是devc++,求大神指教一下.
大佬直接百度eof就知道输入什么啦
while后面的; 去掉


关于vs2015+openmvg的问题希望得到大神解答openmvg
vs2015
点云处理系统

                  本人小白第一次配置openmvg
想要利用openmvg开发一款点云处理系统

按照 https://raw.githubusercontent.com/openMVG/openMVG/master/BUILD 步骤利用cmake和git生成好了文件
用vs2015打开后进行debug和release
但是debug/release后会出现如图错误
我百度查询后1.防火墙关闭还是不行 2.管理员身份运行后还是有这个提示
这个图为按照步骤debug/release后文件夹
下图为拒绝访问的文件夹内容
以及我找到的包含可执行文件的文件夹

还有想请教大神 我这些步骤都做完之后是要怎样继续操作呢?是不是就可以直接建立新的项目写代码引用库函数还是要找到文件夹中的样例来进行操作?
关闭UAC、防火墙、杀毒软件、……
重建所有。
并不管用啊老师...  我关了UCA也关了防火墙  然后重新git cmake 再用vs2015编译 最后还是会显示这个....
引用 1 楼 zhao4zhong1 的回复:关闭UAC、防火墙、杀毒软件、……
重建所有。
并不管用啊老师...  我关了UCA也关了防火墙  然后重新git cmake 再用vs2015编译 最后还是会显示这个..
以管理员身份运行VS2015 ？
重启电脑？
重装VS2015？
确保编译生成了exe文件。
以管理员身份运行运行对应exe文件？
直接忽略这个就行。因为ALL_BUILD没有生成exe文件。ALL_BUILD是默认启动项，系统编译完后默认启动ALL—build的exe文件，就会出现这个提示。直接忽略就好。或者改一下启动项，我觉得
感谢两个老师的回答  因为ALL_BUILD没有生成可执行的exe所以一直出现问题...
你好，楼主能加个微信么，我最近也要做OpenMVG，希望能一起学习
引用 8 楼 weixin_36408769 的回复:你好，楼主能加个微信么，我最近也要做OpenMVG，希望能一起学习

好呀 Sunround5
你好楼主，我最近也需要利用openMVG处理图像影像  但是在配置时遇到很多困难，能加下微信一起交流一下吗，楼上发的是微信号吗我搜索不到，希望能加一下  感激不尽
引用 10 楼 weixin_38497813 的回复:你好楼主，我最近也需要利用openMVG处理图像影像  但是在配置时遇到很多困难，能加下微信一起交流一下吗，楼上发的是微信号吗我搜索不到，希望能加一下  感激不尽
你微信多少，我也在做OpenMVG 一起学习
引用 11 楼 weixin_36408769 的回复:Quote: 引用 10 楼 weixin_38497813 的回复:
你好楼主，我最近也需要利用openMVG处理图像影像  但是在配置时遇到很多困难，能加下微信一起交流一下吗，楼上发的是微信号吗我搜索不到，希望能加一下  感激不尽
你微信多少，我也在做OpenMVG 一起学习
微信号：UlqUioRraA_4
有点复杂  真心请教 感谢
楼主请问你还有没有安装openmvg时候git的代码，你给的网站好像进不去了。表示要重装openmvg但是不记得git语句了....
引用 13 楼 heli8310 的回复:楼主请问你还有没有安装openmvg时候git的代码，你给的网站好像进不去了。表示要重装openmvg但是不记得git语句了....

输入git clone https://github.com/openMVG/openMVG.git
然后进入openMVG文件夹内，输入git submodule init
然后输入git submodule update


QT局域网组播或者用udp通讯会受防火墙限制吗？QT

                  QT局域网组播或者用udp通讯会受防火墙限制吗？我连不通，udp本机测试可以收的到，但是和别的机器连不上。
http://blog.csdn.net/asklw/article/details/73332152
你为啥不试一下呢？


vs2015中stdin如何进行终止？c
vs2015
stdin终止符

                  在vs2015中运行如下代码：
int main()
{
	unsigned int account;
	char name[30];
	double balance;

	FILE *cfPtr;

	if ((cfPtr = fopen("clients.dat", "w")) == NULL)
	{
		puts("File could not be opend!");
	}
	else
	{
		puts("Enter the account, name, and balance.");
		puts("Enter EOF to end input.");
		printf("%s", "? ");
		scanf("%d%29s%lf", &account, &name, &balance);

		while ( !feof( stdin ) )
		{
			fprintf(cfPtr, "%d %s %.2f\n", account, name, balance);
			printf("%s", "? ");
			scanf("%d%29s%lf", &account, &name, &balance);
		}

		fclose(cfPtr);
	}


	return 0;
}

发现需要按《Ctrl+z Ctrl+z Enter 》 或 《Ctrl+z Enter 》 组合3次才能终止，即如下图所示，是什么情况？

为什么需要执行三次？
Enter、Ctrl+Z、Enter


Linux服务器开了两个端口，我该怎么知道客户端连接了哪个端口呢Socket

                  RT
例如我用线程监听了5090 和 5080两个端口，有客户端连接时开一个线程去服务，但是这个线程怎么知道客户端连接的是哪个端口（因为开两个端口是为了区分不同的服务）
监听2个不同的端口，必然是两个不同的socket，哪个socket返回了就是客户端连接的哪个
引用 1 楼 大尾巴猫的回复:监听2个不同的端口，必然是两个不同的socket，哪个socket返回了就是客户端连接的哪个
socket返回是指accept的返回？
是accept返回的。
同时监听2个端口，是开2个线程，每个线程各自初始化一个socket->bind->listen->accept
哪个线程accept返回的，就是客户端连接的哪个端口，怎么无法分辨？
你listen的时候就可以知道了，怎么区分不出呢？搞不懂
引用 3 楼 大尾巴猫的回复:是accept返回的。
同时监听2个端口，是开2个线程，每个线程各自初始化一个socket->bind->listen->accept
哪个线程accept返回的，就是客户端连接的哪个端口，怎么无法分辨？
我两个线程分别去取两个不同的端口做初始化步骤，但是都是调用我封装的ServerSocket类，该用什么条件去区分？
引用 4 楼 JasonHuo_的回复:你listen的时候就可以知道了，怎么区分不出呢？搞不懂
举个例子 说一下大概的流程 实在搞不懂(=_=)
引用 5 楼 qq_38374462 的回复:Quote: 引用 3 楼 大尾巴猫的回复:是accept返回的。
同时监听2个端口，是开2个线程，每个线程各自初始化一个socket->bind->listen->accept
哪个线程accept返回的，就是客户端连接的哪个端口，怎么无法分辨？
我两个线程分别去取两个不同的端口做初始化步骤，但是都是调用我封装的ServerSocket类，该用什么条件去区分？
封装没关系，具体看你实现的封装，listen的socket总是2个不同的socket吧，在你封装的ServerSocket内部进行判断是哪个listen的socket
netstat -nba


vs2015  字体 不能加粗 什么原因呢设置了  粗体  


可是根本没任何效果


这是咋回事呢？
换个字体然后选中加粗试试
你的图中没有设置粗体的选项，只有选择字体和设置字体大小。
Console粗体显示，是告诉你这个字体是等宽的，并不是说你用了console的粗体。
引用 2 楼 ananluowei 的回复:你的图中没有设置粗体的选项，只有选择字体和设置字体大小。
Console粗体显示，是告诉你这个字体是等宽的，并不是说你用了console的粗体。
我第一张图 不是打钩了 粗体吗
引用 2 楼 ananluowei 的回复:你的图中没有设置粗体的选项，只有选择字体和设置字体大小。
Console粗体显示，是告诉你这个字体是等宽的，并不是说你用了console的粗体。

难道说不是在那里 设置粗体么   那又会在哪里呢
你仅把“纯文本”的内容加粗了，各代码元素都还没有设置。如果你想全部加粗，你得把那个列表里面和C++有关的项一个一个都设置为粗体。不信你把列表最后的“注释”设置为粗体看看。
引用 3 楼 ianchen11 的回复:Quote: 引用 2 楼 ananluowei 的回复:
你的图中没有设置粗体的选项，只有选择字体和设置字体大小。
Console粗体显示，是告诉你这个字体是等宽的，并不是说你用了console的粗体。
我第一张图 不是打钩了 粗体吗 哦，看错了


求助,win7轻松访问功能,怎么响应窗口自动停靠排列就是双击窗口边缘最高化,拖拽窗口到屏幕边沿自动缩放这些功能
用SPY抓不到消息,而且大小改变也不会发送WM_SIZE,该怎么响应呢
https://msdn.microsoft.com/en-us/library/windows/desktop/ff729170(v=vs.85).aspx
解决了,会发送WM_SIZE,让我不小心屏蔽了...


关于enable_shared_from_this的使用疑问本帖最后由 stecdeng 于 2017-10-26 12:56:18 编辑

shared_ptr
enabel_shared_from

                  今天遇到一段代码 使用方式比较不常见 个人不太理解
而且自以为可能有使用错误的可能 向各位请教 
代码如下

template<class T>
class Socket : public std::enable_shared_from_this<T> 
/*
这种使用enable_shared_from_this的方式正确么？？？
class Socket : public std::enable_shared_from_this<Socket> //T另外处理
*/
{
	//.....
private:
	tcp::socket _socket;		//boost
	MessageBuffer _readBuffer; // other class
public:
  void ReadHandlerInternal(boost::system::error_code error, size_t transferredBytes)
    {
        if (error)
        {
            CloseSocket();
            return;
        }

        _readBuffer.WriteCompleted(transferredBytes);
        ReadHandler();
    }
	void AsyncReadWithCallback(void (T::*callback)(boost::system::error_code, std::size_t))
	{
		if (!IsOpen())
			return;

		_readBuffer.Normalize();
		_readBuffer.EnsureFreeSpace();
		_socket.async_read_some(boost::asio::buffer(_readBuffer.GetWritePointer(), _readBuffer.GetRemainingSpace()),
			std::bind(callback, this->shared_from_this(), std::placeholders::_1, std::placeholders::_2));
		/*
		这里能够理解 传入的是T的成员函数 所以指针也是shared_from_this
		*/
	}
	void AsyncRead()
	{
		if (!IsOpen())
			return;

		_readBuffer.Normalize();
		_readBuffer.EnsureFreeSpace();
		_socket.async_read_some(boost::asio::buffer(_readBuffer.GetWritePointer(), _readBuffer.GetRemainingSpace()),
			std::bind(&Socket<T>::ReadHandlerInternal, this->shared_from_this(), std::placeholders::_1, std::placeholders::_2));
		/*
			这里为什么不是传入Socket的指针
		*/
	}

};
中午求教  大家解答下 谢谢
望回复  谢谢
class Socket : public std::enable_shared_from_this<Socket<T>>
上enable_shared_from_this<T>是为了让async_read的函数对象借助shared_ptr<T>保存这个Socket的生存期。把继承类用基类shared_ptr在基类析构函数是虚函数的时候才可以做。所以你这里如果T有虚析构的话这代码勉强没问题。
引用 4 楼 FancyMouse 的回复:上enable_shared_from_this<T>是为了让async_read的函数对象借助shared_ptr<T>保存这个Socket的生存期。把继承类用基类shared_ptr在基类析构函数是虚函数的时候才可以做。所以你这里如果T有虚析构的话这代码勉强没问题。
谢谢解答
还是不太了解 std::bind中 T的callback  和  Socket<T> 的函数 都是传递同样的值shared_from_this。我的理解应该是一个是 this->shared_from_this() 一个是shared_from_this()之类的写法
而且不用shared_from_this而是this->shared_from_this()的形式  感觉很怪异
http://en.cppreference.com/w/cpp/memory/enable_shared_from_this
引用 5 楼 stecdeng 的回复:而且不用shared_from_this而是this->shared_from_this()的形式  感觉很怪异
加this->只是因为dependent name的原因，因为是从模板类继承，不用this->的话编译器不从模板基类里获取这个名字，会unresolved symbol的。这个和shared_ptr的问题是没关系的。
详情去了解一下std::shared_ptr<T> 智能指针的用法，用了它后，就尽量不要用该T对象的裸指针，因为生命周期的问题，除非你自己能严格把控该对象的生命周期，否则就最好用std::shared_ptr<T> ，为了解决该对象类成员方法内部要将自身指针传出的问题，才有了继承std::enable_shared_from_this<T>的用法，在方法内使用shared_from_this()
引用 8 楼 sdghchj 的回复:详情去了解一下std::shared_ptr<T> 智能指针的用法，用了它后，就尽量不要用该T对象的裸指针，因为生命周期的问题，除非你自己能严格把控该对象的生命周期，否则就最好用std::shared_ptr<T> ，为了解决该对象类成员方法内部要将自身指针传出的问题，才有了继承std::enable_shared_from_this<T>的用法，在方法内使用shared_from_this()
你好 那么请问
1 
template<class T>
class Socket : public std::enable_shared_from_this<T> 
这个是针对T的自身指针还是Socket的自身指针的使用？

2 在bing 函数中
  std::bind(callback, this->shared_from_this()
std::bind(&Socket<T>::ReadHandlerInternal, this->shared_from_this()
一个是T的成员函数 一个是Socket的成员函数 为什么都传入this->shared_from_this()？ 而且传入的都是this->shared_from_this()？

这个根据shared_ptr手头的资料 我还不能理解
周末快乐  这个若没人回复 周一结贴
都讲了dependent name的问题和shared_ptr没关系

template<typename T>
struct A
{
	void foo(){}
};
template<typename T>
struct B : public A<T>
{
	void a()
	{
		this->foo(); //OK
		//foo();  编译错误
	}
};
引用 4 楼 FancyMouse 的回复:上enable_shared_from_this<T>是为了让async_read的函数对象借助shared_ptr<T>保存这个Socket的生存期。把继承类用基类shared_ptr在基类析构函数是虚函数的时候才可以做。所以你这里如果T有虚析构的话这代码勉强没问题。
这样不需要Socket继承T吗？
引用 12 楼 xsklld 的回复:Quote: 引用 4 楼 FancyMouse 的回复:
上enable_shared_from_this<T>是为了让async_read的函数对象借助shared_ptr<T>保存这个Socket的生存期。把继承类用基类shared_ptr在基类析构函数是虚函数的时候才可以做。所以你这里如果T有虚析构的话这代码勉强没问题。
这样不需要Socket继承T吗？
需要。但是他能调用shared_from_this()说明this能隐式转成T*，如果没有继承关系的话直接就一票编译错误了。lz的语气看上去像是问如何理解能跑的代码，而不是说代码有错，所以我也就没特别强调这点。
引用 13 楼 FancyMouse 的回复:Quote: 引用 12 楼 xsklld 的回复:
Quote: 引用 4 楼 FancyMouse 的回复:
上enable_shared_from_this<T>是为了让async_read的函数对象借助shared_ptr<T>保存这个Socket的生存期。把继承类用基类shared_ptr在基类析构函数是虚函数的时候才可以做。所以你这里如果T有虚析构的话这代码勉强没问题。
这样不需要Socket继承T吗？
需要。但是他能调用shared_from_this()说明this能隐式转成T*，如果没有继承关系的话直接就一票编译错误了。lz的语气看上去像是问如何理解能跑的代码，而不是说代码有错，所以我也就没特别强调这点。

但是这点恰恰是理解的重点
这说明这种不太一般的写法 还是有很多限制 
我是我疑惑的来源   谢谢


C++新手，求大神帮忙解答C++
析构函数
三角形


老师留的作业，一直没有调试出来，求大神帮忙写一下代码，谢谢！！！
把你调试的代码发出来，让大家看看哪里出错了。而不是让别人给你做。
写完才发现居然没有分！楼主还是个伸手党！
仅供参考
#include <iostream>
#include <cstdlib>
#include <cmath>

using namespace std;
class pos {

public:
    pos() { }
    pos(double _x, double _y) {
        x = _x;
        y = _y;
    }

    double x;
    double y;
};

class triangle {
public:
    triangle(pos _pointA, pos _pointB, pos _pointC);
    ~triangle() { std::cout<<"triangle has deleted."<<endl; }

    int changePoint(unsigned int num, pos pointValue);
    int isTriangle();
    double getLengthOfSide();
    double getArea();

private:
    pos point[3];
};

int main()
{
    pos pointA(1.0, 2.0);
    pos pointB(1.0, 3.0);
    pos pointC(2.0, 3.0);
    triangle tri(pointA, pointB, pointC);
    triangle tri1 = tri;
    if(tri.isTriangle())
        std::cout<<"tri is not a triangle";
    else
    {
        double length = tri.getLengthOfSide();
        double area = tri.getArea();
        std::cout<<"tri is a trianle"<<std::endl;
        std::cout<<"the length of side is "<<length<<std::endl;
        std::cout<<"the area is "<<area<<std::endl;
    }
    cout<<endl;
    if(tri1.isTriangle())
        std::cout<<"tri1 is not a triangle";
    else
    {
        double length = tri1.getLengthOfSide();
        double area = tri1.getArea();
        std::cout<<"tri1 is a trianle"<<std::endl;
        std::cout<<"the length of side is "<<length<<std::endl;
        std::cout<<"the area is "<<area<<std::endl;
    }


    return 0;
}

triangle::triangle(pos _pointA, pos _pointB, pos _pointC)
{
    cout<<"x:"<<_pointA.x<<"y:"<<_pointA.y<<std::endl
       <<"x:"<<_pointB.x<<"y:"<<_pointB.y<<std::endl
      <<"x:"<<_pointC.x<<"y:"<<_pointC.y<<std::endl;
    point[0].x = _pointA.x;
    point[0].y = _pointA.y;

    point[1].x = _pointB.x;
    point[1].y = _pointB.y;

    point[2].x = _pointC.x;
    point[2].y = _pointC.y;
}

//-1失败0成功
int triangle::changePoint(unsigned int num, pos pointValue)
{
    if(num>3) return -1;
    point[num].x = pointValue.x;
    point[num].y = pointValue.y;
    return 0;
}

//-1不是三角形0是
int triangle::isTriangle()
{
    double a,b,c;
    //点不重合
    if(point[0].x == point[1].x && point[0].y == point[1].y)
        return -1;
    if(point[0].x == point[2].x && point[0].y == point[2].y)
        return -1;
    if(point[1].x == point[2].x && point[1].y == point[2].y)
        return -1;

    //三角形任何两边的和大于第三边
    a = sqrt(abs(pow(point[0].x - point[1].x, 2) - pow(point[0].y - point[1].y, 2)));
    b = sqrt(abs(pow(point[0].x - point[2].x, 2) - pow(point[0].x - point[2].y, 2)));
    c = sqrt(abs(pow(point[1].x - point[2].x, 2) - pow(point[1].x - point[2].y, 2)));
    if(a+b<=c || a+c<=b || b+c<=a)
        return -1;

    return 0;
}

double triangle::getLengthOfSide()
{
    double a,b,c;

    a = sqrt(abs(pow(point[0].x - point[1].x, 2) - pow(point[0].y - point[1].y, 2)));
    b = sqrt(abs(pow(point[0].x - point[2].x, 2) - pow(point[0].x - point[2].y, 2)));
    c = sqrt(abs(pow(point[1].x - point[2].x, 2) - pow(point[1].x - point[2].y, 2)));
    return a+b+c;
}

double triangle::getArea()
{
    double a,b,c,length,area;

    a = sqrt(abs(pow(point[0].x - point[1].x, 2) - pow(point[0].y - point[1].y, 2)));
    b = sqrt(abs(pow(point[0].x - point[2].x, 2) - pow(point[0].x - point[2].y, 2)));
    c = sqrt(abs(pow(point[1].x - point[2].x, 2) - pow(point[1].x - point[2].y, 2)));
    length = a+b+c;
    area = sqrt(length*(length-a)*(length-b)*(length-c));
    return area;
}


下面的程序输出结果为什么是11111011求大神讲解class one
{
public:
	one(int data=0):m1_data(data)
	{

	}

	int GetData()
	{
		return dodata(); 
	}

	virtual int dodata()
	{
		return m1_data;
	}

public:
	int m1_data;
};

class two:public one
{
public:
	two(int data=1):m2_data(data)
	{

	}

	int dodata()
	{
		return m2_data;
	}

public:
	int m2_data;
};

class three:public two
{
public:
	three(int data=2):m3_data(data)
	{
		//counnt=10;
	}

	static int asd()
	{
		return counnt;
	}

	int aaa()
	{
		return asd();
	}

	static int counnt;

public:
	int m3_data;
};


int three::counnt=10;
int _tmain(int argc, _TCHAR* argv[])
{
	three t(3);

	cout<<t.GetData()<<endl;
	cout<<t.one::GetData()<<endl;
	cout<<t.two::GetData()<<endl;
	cout<<t.three::GetData()<<endl;

	cout<<t.dodata()<<endl;
	cout<<t.one::dodata()<<endl;
	cout<<t.two::dodata()<<endl;
	cout<<t.three::dodata()<<endl;
  ｝
为啥子没人回复额？




新人，关于运行程序一闪而过的解决办法运行后闪过

                  你们好，老鸟们，学C的时候经常会碰到的运行后对话框闪过的问题，怎么处理啊？我试过加getchar(),没有用，求老鸟们帮个忙，代码如下，谢了！

//talkack.c -- 一个能为您提供一些信息的对话程序
#include<stdio.h>
#include<string.h> //提供strlen()函数的原型
#define DENSITY 62.4 //人的密度（单位是：英镑/每立方英尺）
int main()
{
	float weight, volume;
	int size, letters;
	char name[40]; //name是一个有40个字符的数组

	printf("Hi! What's your first name?\n");
	scanf_s("%s", name);
	printf("%s,What's your weight in pounds?\n", name);
	scanf_s("%f", &weight);
	size = sizeof name;
	letters = strlen(name);
	volume = weight / DENSITY;
	printf("Well,&s,your volume is %2.2f cubic feet.\n", name, volume);
	printf("Also,your first name has %d letters,\n", letters);
	printf("and we have %d bytes to store it in.\n", size);
	return 0;
}
没有用...多加几个
要不就是system("pause")
用两个getchar();呢
因为第一个getchar()可能接收了输入缓存里的换行符，这个换行符是应该是最后一次输入遗留在输入缓存里的； 所以第二个getchar()应该可以；
另外，如果是Windows下，可以试一下system("pause");
引用 2 楼 cfjtaishan 的回复:用两个getchar();呢
因为第一个getchar()可能接收了输入缓存里的换行符，这个换行符是应该是最后一次输入遗留在输入缓存里的； 所以第二个getchar()应该可以；
另外，如果是Windows下，可以试一下system("pause");
嗯我之前加过但是说未定义的标识符，刚才查了资料需要加上#include<stdlib.h>头文件才可以，谢谢啦！
引用 2 楼 cfjtaishan 的回复:用两个getchar();呢
因为第一个getchar()可能接收了输入缓存里的换行符，这个换行符是应该是最后一次输入遗留在输入缓存里的； 所以第二个getchar()应该可以；
另外，如果是Windows下，可以试一下system("pause");
谢谢啦！
加system("pause");  头文件是include<windows.h>
<windows.h>头文件


C语言问题求助 求知道这种方式的人给解释下说清楚点吧  我这是常用算法程序集（C/C++描述）这本书的代码 本来我是想要移植到别的地方用 但是真到移植的时候发现我不懂这种方式所以没法移植 直接上截图吧 比如说他这种定义方式 定义一个函数 之后定义一个变量然后才是大括号 这是什么方式，还有截图中的变量 比如说a b x都是灰色的 这是在哪有什么设置么 这是在哪定义的 在原来代码中这种方式是不报错的只是编译不通过  但是我这些把程序复制走 粘贴到别的地方是报错的 报变量未定义
 
则是我复制走之后移植到一个新建的C工程中的截图 都是变量未定义错误 水平低微 完全不知道怎么回事 他这种定义方式看着就跟用MATLAB一样 我度不知道到哪去找设置去
fftsf是一个函数，后面的double x只是把参数表的定义单独拿出来写，相当于这样的写法：
double fftsf(double x)
后面的ffts也是一样的道理。

这些写法，包括变量是否可以随处定义等等，可能跟编译器有关，如果编译器不支持，你就改一下，按标准写法来就好了。
函数定义的形式不对呢，用matlab的语法写C语言程序，本身语法的规则都不一样，怎么可能编译过去呢；
函数的定义就像main函数定义一样，有大括号包起来；需要的变量可以在大括号里定义，需要外部传递过来的变量，在参数里体现；
这是旧式的C语言函数定义，具体可参看：http://blog.csdn.net/talent_CYJ/article/details/51302816

实际使用时，建议使用新式的


求大佬来看看,在线等，谢谢。#include<stdio.h>
int main()
{
 int StrDelete(Hsting *s,int pos,int len)
{
		char*p;
		int i;
		if(pos<=0||s->length-pos<len)
		{printf("parameter error!");
		return(0);
		}
		p=s->ch+pos-1;
		for(i=0;i<len;i++)
			*(p+i)=*(p+len+i);
		s->length=s->length-n;
		return(l);
	}
看不懂你的代码，main函数里嵌套StrDelete函数吗？
建议重发一下你的代码
C语言规定函数不能嵌套定义
为什么要这样定义啊？
把你的StrDelete函数放到main函数的外面，不能在一个函数里实现另一个函数
定义的方式不对
要把 StrDelete函数提到main函数上面


C++类之间的值传递，我传的疑似地址，就是两个红色字体的部分传，图为20点时的运行结果C++
类
传值

问题就是两个红色字体部分的值，上面的传给下面的不会传，在此附上代码，和20点时候运行的结果。希望各位大佬能帮助我
#include <iostream.h>
#include <time.h>
#include <windows.h>

class TimeDifferent
{
	private:
	int d,h,m,s;//录入时间
	int dc,hc,mc,sc;//现在时间

	int ddc,dd;//现在秒 销售秒
	int dj;//两秒差

    int nd,nh,nm,ns;
	public:
	friend class Count;
	int getnewday()
	{
		return nd;
	}
	int getnewhour()
	{
		return nh;
	}
	int getnewminute()
	{
		return nm;
	}
	int getnewsecond()
	{
		return ns;
	}
	void FindTimeDifferent()
	{
	time_t timep;  //去当前系统时间 
	struct tm *p;  
	time(&timep);  
	p =localtime(&timep);
	dc=p->tm_mday;
	hc=p->tm_hour;
	mc=p->tm_min;
	sc=p->tm_sec;

	cin>>d>>h>>m>>s;


	if(d<dc)//判断输入时间是否合法 
	{
		cout<<"error"<<endl;
	}
	else
	{
 	 if(d==dc)//当天时间的换算方法 
 	 {
		  ddc=hc*3600+mc*60+sc;
		  dd=h*3600+m*60+s;
		  dj=dd-ddc;
		   nh=dj/3600;
		   nm=(dj-nh*3600)/60;
		   ns=dj-nh*3600-nm*60;
		   cout<<"0day"<<nh<<"hour"<<nm<<"minute"<<ns<<"second"<<endl;
  	}
  	else//把时间差化成秒，并且计算 
  	{
    	  ddc=dc*3600*24+hc*3600+mc*60+sc;
		  dd=d*3600*24+h*3600+m*60+s;
		  dj=dd-ddc;
		  nd=dj/86400;
	 	 nh=(dj-nd*86400)/3600;
	 	 nm=(dj-nd*86400-nh*3600)/60;
	 	 ns=dj-nd*86400-nh*3600-nm*60;
	 	 cout<<nd<<"day   "<<nh<<"hour   "<<nm<<"minute   "<<ns<<"second   "<<endl;
 	 }
	}

	}
	};


class Count//倒计时算法 
{
	private:
	int day;
		int hour;
		int minute;
		int second;

	public：
		Count()
		{
			day=oneday.getnewday();
			hour=oneday.getnewhour();
			minute=oneday.getnewminute();
			second=oneday.getnewsecond();	
		}
		void printthenumber()
		{
			cout<<day<<"天"<<hour<<"时"<<minute<<"分"<<second<<"秒"<<endl;
		}

};
int main()
{
	TimeDifferent one;
	one.FindTimeDifferent();
	Count oneday;
	oneday.printthenumber();
	return 0;
}


关于C++ setf()的返回值的问题#include <iostream>

int main(int argc, char *argv[])
{
	using namespace std;

	ios_base::fmtflags flg = cout.setf(ios_base::boolalpha);
	cout << true << endl;
	cout.setf(ios_base::showbase);
	cout << 100 << endl;
	hex(cout);
	cout << 100 << endl;
	oct(cout);
	cout << 100 << endl;
	return 0;
}
setf()返回以前的标记设置类型为ios_base::fmtflags
要恢复到以前的设置要怎么做呢？单参数的setf()返回值是用做恢复之前的设置的吗？要怎么恢复呢？
乍看起来c++的cin、cout、ifstream、ofstream、istringstream、ostringstream在输入、输出上比c的scanf、printf、fscanf、fprintf、fread、fwrite、sscanf、sprintf简单，不用格式控制符！
但是不用格式控制符，输入输出恰好是你期望的格式的时候好说；等到输入输出不是你期望的格式的时候，你就会觉得还是用格式控制符更方便、更靠谱。
摒弃cin、cout、ifstream、ofstream、istringstream、ostringstream！
使用scanf、printf、fscanf、fprintf、fread、fwrite、sscanf、sprintf。
用flags成员函数。
引用 2 楼 xsklld 的回复:用flags成员函数。
多谢，真的可以耶
引用 1 楼 zhao4zhong1 的回复:乍看起来c++的cin、cout、ifstream、ofstream、istringstream、ostringstream在输入、输出上比c的scanf、printf、fscanf、fprintf、fread、fwrite、sscanf、sprintf简单，不用格式控制符！
但是不用格式控制符，输入输出恰好是你期望的格式的时候好说；等到输入输出不是你期望的格式的时候，你就会觉得还是用格式控制符更方便、更靠谱。
摒弃cin、cout、ifstream、ofstream、istringstream、ostringstream！
使用scanf、printf、fscanf、fprintf、fread、fwrite、sscanf、sprintf。
大佬，我没有SCDN账号的时候  百度的时候经常看到您的帖子。关注您很久了。请接受我的膜拜！
C的库函数用多了  感觉C++很不习惯。
我是初学者，多谢大佬指点


变量char (*a)[];如何赋值c
c++


int ffff(const char ( *  a) [])
{
	return 1;
}
char (*a)[];  // =???



奇怪，能声明，却无法赋值
int ffff(char(*a)[2]) //这样子必须指明是多少个元素的数组，表示参数是一个指向一个有两个元素的数组
{
    return 1;
}

void main()
{
    char arr[] = { 1, 2 };
    ffff(&arr);
}


更常见的代码是

//取得二维点的坐标值
void GetPoint(int(&p)[2])
{
    p[0] = 10;
    p[1] = 20;
}

void main()
{
    int pt1[2];
    int pt2[3];
    GetPoint(pt1);
    // 这个数组大小是3，不符合参数要求导致编译错误
    // 作用是：强制使用者传递指定大小的数组
    //GetPoint(pt2);
}
声明中的 [] 没啥用，直接写 const char** 就行了。
引用 1 楼 jianwen0529 的回复:

引用 2 楼 ri_aje 的回复:声明中的 [] 没啥用，直接写 const char** 就行了。
char (*a)[N];  //可以，没有常量N，死活赋不了值。
另外，char** 与char (*)[]可不一样
引用 3 楼 GKatHere 的回复:Quote: 引用 1 楼 jianwen0529 的回复:


引用 2 楼 ri_aje 的回复:声明中的 [] 没啥用，直接写 const char** 就行了。
char (*a)[N];  //可以，没有常量N，死活赋不了值。
另外，char** 与char (*)[]可不一样 
char** 和 char (*a)[N] 不一样，char (*)[] 和 char (*)[N] 不一样，和 char const** 一样，别搞混了。
char (*a)[100];
	char str[100];
	a = &str;
5L正解。。
引用 4 楼 ri_aje 的回复:Quote: 引用 3 楼 GKatHere 的回复:
Quote: 引用 1 楼 jianwen0529 的回复:


引用 2 楼 ri_aje 的回复:声明中的 [] 没啥用，直接写 const char** 就行了。
char (*a)[N];  //可以，没有常量N，死活赋不了值。
另外，char** 与char (*)[]可不一样 
char** 和 char (*a)[N] 不一样，char (*)[] 和 char (*)[N] 不一样，和 char const** 一样，别搞混了。
有点问题：如果 
char *a[]; == char** a;
char (*a)[];  == char** a;
char *a[] == ?? char (*a)[];
 char (*b)[];
b+1; // ERROR ??
引用 7 楼 GKatHere 的回复:Quote: 引用 4 楼 ri_aje 的回复:
Quote: 引用 3 楼 GKatHere 的回复:
Quote: 引用 1 楼 jianwen0529 的回复:


引用 2 楼 ri_aje 的回复:声明中的 [] 没啥用，直接写 const char** 就行了。
char (*a)[N];  //可以，没有常量N，死活赋不了值。
另外，char** 与char (*)[]可不一样 
char** 和 char (*a)[N] 不一样，char (*)[] 和 char (*)[N] 不一样，和 char const** 一样，别搞混了。
有点问题：如果 
char *a[]; == char** a;
char (*a)[];  == char** a;
char *a[] == ?? char (*a)[];
 char (*b)[];
b+1; // ERROR ??




没太看明白你的问题。
char (*) [] 是指向数组的指针，但问题是数组维度信息没有，所以只能是个指针的指针，在函数体里面用起来的时候和 char ** 没啥本质区别。
LS正解123456789
仅供参考：//char (*(*x[3])())[5];//x是什么类型的变量?
//
//分析C语言声明，关键是搞清楚这个变量是个什么东西（函数、指针、数组），
//是函数那么剩下的就是他的参数和返回值，
//是指针那剩下部分是说明他指向什么，
//是数组剩下的部分就是说明数组的成员是什么类型。
//解析C语言声明规则：
//从左侧第一个标识符开始，按照优先级进行结合。*表示是..的指针，const表示只读的，volatile表示可变的，[]表示是数组，()表示是函数。
//
//x和[3]结合说明是一个大小为3的数组，该数组的每个元素为一类指针，该类指针指向一类函数，该类函数无参数，返回一类指针，该类指针指向一个大小为5的char型数组
#include <stdio.h>
#include <typeinfo.h>
char num[5];
char (*x00())[5] {
    return &num;
}
int main() {
    char (*(*x[3])())[5];//是个数组，大小为3
    char (*(*x0  )())[5];//数组的元素，是个函数指针
    char (*( x00 )())[5];//函数原型，参数为空，返回值为指针
    char (*  x000   )[5];//返回值

    x0 = x00;
    x[0] = x0;
    x[1] = x0;
    x[2] = x0;
    printf("typeid(x).name() is %s\n",typeid(x).name());
    return 0;
}
//typeid(x).name() is char (* (__cdecl**)(void))[5]
引用 7 楼 GKatHere 的回复:Quote: 引用 4 楼 ri_aje 的回复:
Quote: 引用 3 楼 GKatHere 的回复:
Quote: 引用 1 楼 jianwen0529 的回复:


引用 2 楼 ri_aje 的回复:声明中的 [] 没啥用，直接写 const char** 就行了。
char (*a)[N];  //可以，没有常量N，死活赋不了值。
另外，char** 与char (*)[]可不一样 
char** 和 char (*a)[N] 不一样，char (*)[] 和 char (*)[N] 不一样，和 char const** 一样，别搞混了。
有点问题：如果 
char *a[]; == char** a;
char (*a)[];  == char** a;
char *a[] == ?? char (*a)[];
 char (*b)[];
b+1; // ERROR ??




char b=1,c=3,d=5,*a[3]={&b,&c,&d};
	printf("%d,%d,%d",**a,*a[1],**(a+1));
输出： 1，3，3


简单问题求教！！！！！请问大牛们，devcpp4.9.9.2如何设置单步调试？
百度搜相关关键字。
建议看一下软件的使用说明吧，只有用过的朋友能回答你的这个问题；一般软件，建议从网上搜一搜，然后总结一下用法


C++ 在编译生成O文件时main被多次定义../obj/bitcoind.o：在函数‘main’中：
bitcoind.cpp:(.text.startup+0x0): `main'被多次定义
../obj/bitcoin-cli.o:bitcoin-cli.cpp:(.text.startup+0x0)：第一次在此定义
../obj/bitcoin-tx.o：在函数‘main’中：
bitcoin-tx.cpp:(.text.startup+0x0): `main'被多次定义
../obj/bitcoin-cli.o:bitcoin-cli.cpp:(.text.startup+0x0)：第一次在此定义
../obj/bitcoin.o：在函数‘main’中：
bitcoin.cpp:(.text.startup+0xc0): `main'被多次定义
../obj/bitcoin-cli.o:bitcoin-cli.cpp:(.text.startup+0x0)：第一次在此定义

在生成.o文件时出现错误，该问题是什么原因？怎样解决？
被多次定义...
那你只定义一次不行么?
g++编译命令是什么？  或者代码定义了多个main入口函数？
删除一个main函数
在你的一个工程中的多个cpp文件中都有main函数, 就会这样.  你要保证编译的所有cpp文件中只能有一个main函数.  因为c++程序入口只能有一个.
一个CPP 会被编译为 一个OBJ对象文件 
每个OBJ又会被装进 其它二进制文件
这个二进制是一个整体 一个整体的DLL或者 EXE  如果DLL中要调用其它LIB 则由这些LIB装入OBJ 以供调用

装入时同时会包含各个函数的所属类型和索引标识 像main这种全局类型的函数 是不会有类类型的 但也有void_cdel的标识
多重定义很明显要出问题 真到了调用main 函数的时候 怎么找要调用哪一个main??? main比较特殊 是不能重载的一个函数

错误	9	error C2731: “main”: 无法重载函数[/code]

要不就删去多余的main
要不就使用宏做屏蔽
也可以删除掉其它包含多余main的cpp 如果你目前的功能 不需要使用这些cpp对应的OBJ的话
main（）函数多写了一个


test.exe 中的 0x54821f86 处有未经处理的异常: 0xC0000005: 读取位置 0x00000018 时发生访问冲突#include<iostream>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
using namespace cv;
int main()
{
	// 读入一张图片（游戏原画）
	Mat img=imread("1.jpg");
	// 创建一个名为 "游戏原画"窗口
	namedWindow("游戏原画");
	// 在窗口中显示游戏原画
	imshow("游戏原画",img);
	// 等待6000 ms后窗口自动关闭
	waitKey(6000);
}
opencv新手，今天刚配环境了 就出现这个问题 求大神解决
检查函数返回值，判断是否成功，检查是否成功读到文件，使用绝对路径试上
这是对空指针进行了操作。
比如Mat img=imread("1.jpg");检查下你的1.jpg是不是在当前工程目录，或者改成绝对路径
一句句检查下去
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
查看自己建立的工程是否是C++工程。我也遇到这样的问题。更改工程后就可以了。


为什么下面的程序错误C语言

                  //问题八：输入年、月、日，在屏幕上输出此日期是该年的第几天
#include<stdio.h>
int main()
{
    int year,month,day,what_day;
 //   int a[130],b[130];
    int a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
    int b[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    scanf("%d,%d,%d",year,month,day);
    if(year%4==0)
        {
            for(;month>0;month--)
                what_day+=a[month];
            printf("\n%d",what_day);
        }
    else
        {
            for(;month>0;month--)
                what_day+=b[month];
            printf("\n%d",what_day);
        }
    what_day+=day;
  //  printf("\n第%d天",what_day);
    return 0;
}
多算了一个月吧 假如是五月二十日 你这算了12345月的总和+20 应该是1234+20
还有scanf  里面&year ...  以及闰年判断方法
for(;month>0;month--)改成 for(;month>1;month--)
what_day+=a[month];改成what_day+=a[month-1]
看看;
来晚了，上面已经有正解了。
引用 4 楼 zjq9931 的回复:来晚了，上面已经有正解了。
还有问题呢，what_day没有初始化，闰年的判断是否正确？
#include<stdio.h>

int main()
{
    int year,month,day,what_day = 0;
    //   int a[130],b[130];
    int a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
    int b[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    scanf("%d,%d,%d", &year, &month, &day);
    if(year%400 ==0 || (year % 4 == 0 && year % 100 != 0))
    {
        for(month = month-1;month>0;month--)
            what_day+=a[month];
        printf("\n%d",what_day);
    }
    else
    {
        for(month = month-1;month>0;month--)
            what_day+=b[month];
        printf("\n%d",what_day);
    }
    what_day+=day;
    //  printf("\n第%d天",what_day);
    return 0;
}
四个问题：
1. 输入格式不正确，年月日变量缺少&
2. 闰年判断不对；
3. what_day没有初始化； 
4. a的下标month应从month - 1开始
明白了，谢谢了诸位


为什么下面的程序错误//问题八：输入年、月、日，在屏幕上输出此日期是该年的第几天
#include<stdio.h>
int main()
{
    int year,month,day,what_day;
    int a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
    int b[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    scanf("%d,%d,%d",year,month,day);
    if(year%4==0)
        {
            for(;month>0;month--)
                what_day+=a[month];
            printf("\n%d",what_day);
        }
    else
        {
            for(;month>0;month--)
                what_day+=b[month];
            printf("\n%d",what_day);
        }
    what_day+=day;
    printf("\n第%d天",what_day);
    return 0;
}
scanf("%d,%d,%d",year,month,day);
===>
  scanf("%d,%d,%d",&year,&month,&day);


为什么下面的程序输出错误//问题八：输入年、月、日，在屏幕上输出此日期是该年的第几天
#include<stdio.h>
int main()
{
    int year,month,day,what_day;
 //   int a[130],b[130];
    int a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
    int b[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    scanf("%d,%d,%d",year,month,day);
    if(year%4==0)
        {
            for(;month>0;month--)
                what_day+=a[month];
            printf("\n%d",what_day);
        }
    else
        {
            for(;month>0;month--)
                what_day+=b[month];
            printf("\n%d",what_day);
        }
    what_day+=day;
  //  printf("\n第%d天",what_day);
    return 0;
}
scanf("%d,%d,%d", &year, &month, &day);  //添加 &
#include<stdio.h>

int main()
{
    int year,month,day,what_day = 0;
    //   int a[130],b[130];
    int a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
    int b[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    scanf("%d,%d,%d", &year, &month, &day);
    if(year%4==0 || (year % 4 == 0 && year % 100 != 0))
    {
        for(;month>0;month--)
            what_day+=a[month];
        printf("\n%d",what_day);
    }
    else
    {
        for(;month>0;month--)
            what_day+=b[month];
        printf("\n%d",what_day);
    }
    what_day+=day;
    //  printf("\n第%d天",what_day);
    return 0;
}
三个问题：
1. 输入格式不正确，年月日变量缺少&
2. 闰年判断不对；
3. what_day没有初始化；
当然还有多算一个月，a的下标应该从month-1开始算
#include<stdio.h>

int main()
{
    int year,month,day,what_day = 0;
    //   int a[130],b[130];
    int a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
    int b[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    scanf("%d,%d,%d", &year, &month, &day);
    if(year%400 ==0 || (year % 4 == 0 && year % 100 != 0))
    {
        for(month = month-1;month>0;month--)
            what_day+=a[month];
        printf("\n%d",what_day);
    }
    else
    {
        for(month = month-1;month>0;month--)
            what_day+=b[month];
        printf("\n%d",what_day);
    }
    what_day+=day;
    //  printf("\n第%d天",what_day);
    return 0;
}


去掉字符中的格式字符处理

                  json解析带有格式的字符时会解析出错,问下怎么去掉这种格式呢
提醒：解析json的库一般都是开源的。
仅供参考：#include <stdio.h>
#include <string.h>
#include <locale.h>
char s[]="%26nbsp%3B%u5BF9%u65B9%u7B54%u590D";
char *p;
int i,j,r,n,v;
wchar_t w1[100];
wchar_t *pw;
void urldecode() {
    p=s;
    i=0;
    while (1) {
        r=sscanf(p,"%%%2X%n",&v,&n);
        if (r==EOF) break;
        if (r==1) {
            w1[i]=(wchar_t)v;
            p+=n;
            i++;
        } else {//r==0
            r=sscanf(p,"%%u%4X%n",&v,&n);
            if (r==EOF) break;
            if (r==1) {
                w1[i]=(wchar_t)v;
                p+=n;
                i++;
            } else {//r==0
                w1[i]=(wchar_t)p[0];
                p++;
                i++;
            }
        }
    }
}
void wstrrep(wchar_t *a,wchar_t b) {
    pw=w1;
    while (1) {
        pw=wcsstr(pw,a);
        if (pw) {
            memmove(pw+1,pw+wcslen(a),2*(wcslen(pw)-wcslen(a)+1));
            pw[0]=b;
        } else break;
    }
}
void htmldecode() {
    wstrrep(L"&nbsp;",L' ');
    wstrrep(L"&amp;",L'&');
    wstrrep(L"&quot;",L'\"');
    wstrrep(L"&lt;",L'<');
    wstrrep(L"&gt;",L'>');
}
int main() {
    _wsetlocale(LC_ALL,L"chs");
    urldecode();
    wprintf(L"[%s]\n",w1);
    htmldecode();
    wprintf(L"[%s]\n",w1);
    return 0;
}
//[&nbsp;对方答复]
//[ 对方答复]
//
可能我表述有问题,具体点就是json中的一个参数是string类型,但是如果字符带有格式的话,json会解析失败.现已解决


关于free()的问题free()
malloc
内存释放
内存分配
指针

#include <io.h>
#include <string.h>
#include<stdlib.h>
#include<stdio.h>

//分配len的长度的内存,内存地址由ptr输出
void test_malloc(char **prt, int len)
{
	char *tmp=NULL;
	tmp=(char*)malloc(len);
	*prt=tmp;
}

 void main(void)
 {
 	char *str="welcome to huawei";
 	char *buf;
 	char c=0xff;
 	test_malloc(&buf, sizeof(str));//strlen(str)+1
 	if(buf ==NULL)
 	{
 		return;
 	}
 	strcpy(buf , str);
 	if( c==(char)0xff)
 	{
 		printf("OK,str=%s",buf);
 	}
 	else
 	{
 		printf("OH my God!");
 	}
 	free(buf);
 }
如上代码在free();时会崩溃，求大神指点
用 Cygwin C++ Compiler调试 没有出现问题。
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
你代码中注释都说了：要用strlen(str)+1，不能用sizeof(str)

str是指针，sizeof(str)得到的是指针大小（32位程序为4），从而导致越界访问了，破坏了堆，释放时出错

如果要用sizeof(str)，第一句要改为：char str[] = "welcome to huawei";
问题在这一行：
test_malloc(&buf, sizeof(str));
改为：
test_malloc(&buf, strlen(str)+1);
3楼说的对，第一句要改为：char str[] = "welcome to huawei"; 修改后问题解决。char *str不管是char指针还是int、double，指针跟普通变量都是一样（如int m=3;）都是存在栈中的，仅仅占用4个字节，sizeof(str)取的是str在栈空间的大小。总结下来就是如果有如下操作int * nAge = new int(3);那么nAge就是存储在栈中的指针变量，只是它里面存储的是地址，这个地址是指向了“ new int(3)”分配的堆空间，strlen（nAge）获取的也是4，在32位或者64位的操作系统中，栈中存储的变量都是4个字节。所以变量为char *str="welcome to huawei";时通过sizeof(str)获取的值永远是4，不管你的字符串多长，但是改为char str []="welcome to huawei";时str就是一个数组了，sizeof(str)获取的是数组的长度


C语言多线程 openmpC语言程序的openmp多线程处理，需要对每个线程都要创建一套自己私有的全局指针变量（改指针变量是跨文件的，而且里面包括各种指针、结构体），即使用threadprivate声明各个线程中的变量也是同一块内存，怎样才能各自独立的使用这些全局指针？

你的意思是多个线程访问同一块内存？？
如果是这样，访问会有冲突，需要增加锁，很难并行计算
引用 2楼呔妖怪来嘛 的回复:你的意思是多个线程访问同一块内存？？
如果是这样，访问会有冲突，需要增加锁，很难并行计算我的意思是怎么让各个线程都有一份独立的
线程函数中声明的占内存比较小的变量本来就在各个线程的堆栈中。
线程函数中声明的占内存比较大（比如超过1MB）的变量应该在前面加static，将其存储位置挪到全局变量区，或者使用new，将其挪到堆存储区；但这样一来，会导致多线程读写冲突，此时一个解决办法就是将变量数组化，每个线程访问改数组变量时，都使用比如varArray[thread_id%MAX_THREADS]的办法避免访问冲突。
访问改数组变量时→访问该数组变量时
引用 3 楼 xu6832281 的回复:Quote: 引用 2楼呔妖怪来嘛 的回复:你的意思是多个线程访问同一块内存？？
如果是这样，访问会有冲突，需要增加锁，很难并行计算我的意思是怎么让各个线程都有一份独立的

啥叫每个线程都有一份独立的，又全局，又独立的~~。你多整几个全局变量不就行了？？
引用 6 楼 hezhe1008 的回复:Quote: 引用 3 楼 xu6832281 的回复:Quote: 引用 2楼呔妖怪来嘛 的回复:你的意思是多个线程访问同一块内存？？如果是这样，访问会有冲突，需要增加锁，很难并行计算我的意思是怎么让各个线程都有一份独立的啥叫每个线程都有一份独立的，又全局，又独立的~~。你多整几个全局变量不就行了？？

使用线程局部存储(TLS)，具体用法可参看MSDN
引用 7 楼 paschen 的回复:Quote: 引用 6 楼 hezhe1008 的回复:Quote: 引用 3 楼 xu6832281 的回复:Quote: 引用 2楼呔妖怪来嘛 的回复:你的意思是多个线程访问同一块内存？？如果是这样，访问会有冲突，需要增加锁，很难并行计算我的意思是怎么让各个线程都有一份独立的啥叫每个线程都有一份独立的，又全局，又独立的~~。你多整几个全局变量不就行了？？

使用线程局部存储(TLS)，具体用法可参看MSDN
 
Thread Local Storage (TLS)
Home |  Overview |  How Do I |  Sample

Thread Local Storage (TLS) is the method by which each thread in a given multithreaded process may allocate locations in which to store thread-specific data. Dynamically bound (run-time) thread-specific data is supported by way of the TLS API (TlsAlloc, TlsGetValue, TlsSetValue, TlsFree). Win32 and the Visual C++ compiler now support statically bound (load-time) per-thread data in addition to the existing API implementation.

API Implementation for TLS
Thread Local Storage is implemented through the Win32 API layer as well as the compiler. For details, see the Win32 API documentation for TlsAlloc, TlsGetValue, TlsSetValue, and TlsFree.

The Visual C++ compiler includes a keyword to make thread local storage operations more automatic, rather than through the API layer. This syntax is described in the next section, Compiler Implementation for TLS.

Compiler Implementation for TLS
To support TLS, a new attribute, thread, has been added to the C and C++ languages and is supported by the Visual C++ compiler. This attribute is an extended storage class modifier, as described in the previous section. Use the __declspec keyword to declare a thread variable. For example, the following code declares an integer thread local variable and initializes it with a value:

__declspec( thread ) int tls_i = 1;

See Also   Rules and Limitations for TLS
Thread Local Storage
Microsoft Specific —>

Thread Local Storage (TLS) is the mechanism by which each thread in a given multithreaded process allocates storage for thread-specific data. In standard multithreaded programs, data is shared among all threads of a given process, whereas thread local storage is the mechanism for allocating per-thread data. For a complete discussion of threads, seeProcesses and Threads in the Microsoft Win32® Software Development Kit documentation.

The Microsoft C language includes the extended storage-class attribute, thread, which is used with the __declspec keyword to declare a thread local variable. For example, the following code declares an integer thread local variable and initializes it with a value:

__declspec( thread ) int tls_i = 1;

These guidelines must be observed when you are declaring statically bound thread local variables: 

The use of __declspec(thread) may interfere withdelay loading of DLL imports.


You can apply the thread attribute only to data declarations and definitions. It cannot be used on function declarations or definitions. For example, the following code generates a compiler error:
#define Thread    __declspec( thread )
Thread void func();        /* Error */

You can specify the thread attribute only on data items with static storage duration. This includes global data (both static and extern) and local static data. You cannot declare automatic data with the thread attribute. For example, the following code generates compiler errors:
#define Thread    __declspec( thread )
void func1()
{
    Thread int tls_i;            /* Error */
}

int func2( Thread int tls_i )    /* Error */
{
return tls_i;
}

You must use the thread attribute for the declaration and the definition of thread local data, regardless of whether the declaration and definition occur in the same file or separate files. For example, the following code generates an error:
#define Thread    __declspec( thread )
extern int tls_i;     /* This generates an error, because the   */
int Thread tls_i;     /* declaration and the definition differ. */

You cannot use the thread attribute as a type modifier. For example, the following code generates a compiler error:
char *ch __declspec( thread );        /* Error */

The address of a thread local variable is not considered constant, and any expression involving such an address is not considered a constant expression. This means that you cannot use the address of a thread local variable as an initializer for a pointer. For example, the compiler flags the following code as an error:
#define Thread    __declspec( thread )
Thread int tls_i;
int *p = &tls_i;        /* Error */

C permits initialization of a variable with an expression involving a reference to itself, but only for objects of nonstatic extent. For example:
#define Thread    __declspec( thread )
Thread int tls_i = tls_i;             /* Error */
int j = j;                            /* Error */
Thread int tls_i = sizeof( tls_i )    /* Okay  */

Note that a sizeof expression that includes the variable being initialized does not constitute a reference to itself and is allowed.

The use of __declspec(thread) may interfere withdelay loading of DLL imports. 
For more information about using the thread attribute, seeMultithreading Topics in Visual C++ Programmer’s Guide.

END Microsoft Specific
我用线程的话一般是包装成类，每个线程就是一个类对象，很方便保存各种参数
我的意思是：threadprivate声明的指针变量在各个线程都有一份独立拷贝，互不影响。但这前提是在同一个文件中，如果跨文件的全局变量，这种机制就出错了
《Windows核心编程》
threadprivate指定全局变量被OpenMP所有的线程各自产生一个私有的拷贝，即各个线程都有自己私有的全局变量。threadprivate并不是针对某一个并行区域，而是整个于整个程序，所以其拷贝的副本变量也是全局的，即在不同的并行区域之间的同一个线程也是共享的。threadprivate只能用于全局变量或静态变量
http://blog.csdn.net/gengshenghong/article/details/6985431


为什么这段代码的结果为空（代码在VS2017编译器下运行的）#include"stdafx.h"
#include<stdio.h>
#include<string.h>
int main()
{
	char str1[30] = {"People's Republic of"};
	char str2[] = {"China"};
	printf("%s\n", strcat_s(str1, str2));
        return 0;
}
Collapse AllExpand All      Code: All Code: Multiple Code: Visual Basic Code: C# Code: Visual C++ Code: J# Code: JScript  
Visual Basic
C#
Visual C++
J#
JScript
Run-Time Library Reference 
strcat_s, wcscat_s, _mbscat_s 
Example  See Also  Send Feedback 
 

Append a string. These are versions of strcat, wcscat, _mbscat with security enhancements as described in Security Enhancements in the CRT.

 
errno_t strcat_s(
   char *strDestination,
   size_t numberOfElements,
   const char *strSource 
);
errno_t wcscat_s(
   wchar_t *strDestination,
   size_t numberOfElements,
   const wchar_t *strSource 
);
errno_t _mbscat_s(
   unsigned char *strDestination,
   size_t numberOfElements,
   const unsigned char *strSource 
);
template <size_t size>
errno_t strcat_s(
   char (&strDestination)[size],
   const char *strSource 
); // C++ only
template <size_t size>
errno_t wcscat_s(
   wchar_t (&strDestination)[size],
   const wchar_t *strSource 
); // C++ only
template <size_t size>
errno_t _mbscat_s(
   unsigned char (&strDestination)[size],
   const unsigned char *strSource 
); // C++ only
 

Parameters
strDestination
Null-terminated destination string buffer.

numberOfElements
Size of the destination string buffer.

strSource
Null-terminated source string buffer.

Return Value
Zero if successful; an error code on failure.

strDestination
 numberOfElements
 strSource
 Return value
 Contents of strDestination
 
NULL or unterminated
 any
 any
 EINVAL
 not modified
 
any
 any
 NULL
 EINVAL
 strDestination[0] set to 0
 
any
 0, or too small
 any
 ERANGE
 strDestination[0] set to 0
 

Remarks
The strcat_s function appends strSource to strDestination and terminates the resulting string with a null character. The initial character of strSource overwrites the terminating null character of strDestination. The behavior of strcat_s is undefined if the source and destination strings overlap.

Note that the second parameter is the total size of the buffer, not the remaining size:

  Copy Code 
char buf[16];
strcpy_s(buf, 16, "Start");
strcat_s(buf, 16, " End");               // Correct
strcat_s(buf, 16 – strlen(buf), " End"); // Incorrect
 

wcscat_s and _mbscat_s are wide-character and multibyte-character versions of strcat_s. The arguments and return value of wcscat_s are wide-character strings; those of _mbscat_s are multibyte-character strings. These three functions behave identically otherwise.

If strDestination is a null pointer, or is not null-terminated, or if strSource is a NULL pointer, or if the destination string is too small, the invalid parameter handler is invoked, as described in Parameter Validation . If execution is allowed to continue, these functions return EINVAL and set errno to EINVAL.

In C++, using these functions is simplified by template overloads; the overloads can infer buffer length automatically (eliminating the need to specify a size argument) and they can automatically replace older, non-secure functions with their newer, secure counterparts. For more information, see Secure Template Overloads.

The debug versions of these functions first fill the buffer with 0xFD. To disable this behavior, use _CrtSetDebugFillThreshold.

TCHAR.H routine 
 _UNICODE & _MBCS not defined
 _MBCS defined
 _UNICODE defined
 
_tcscat_s
 strcat_s
 _mbscat_s
 wcscat_s
 

Requirements
Routine
 Required header
 
strcat_s
 <string.h>
 
wcscat_s
 <string.h> or <wchar.h>
 
_mbscat_s
 <mbstring.h>
 

For additional compatibility information, see Compatibility in the Introduction.

Example
See the code example in strcpy_s, wcscpy_s, _mbscpy_s.

.NET Framework Equivalent
System::String::Concat

See Also
Concepts
String Manipulation (CRT)
strncat, _strncat_l, wcsncat, wcsncat_l, _mbsncat _mbsncat_l
strncmp, wcsncmp, _mbsncmp, _mbsncmp_l
strncpy, _strncpy_l, wcsncpy, _wcsncpy_l, _mbsncpy, _mbsncpy_l
_strnicmp, _wcsnicmp, _mbsnicmp, _strnicmp_l, _wcsnicmp_l, _mbsnicmp_l
strrchr, wcsrchr, _mbsrchr, _mbsrchr_l
strspn, wcsspn, _mbsspn, _mbsspn_l
Send feedback on this topic to Microsoft.

#include <stdio.h>
#include <string.h>
int main()
{
    char str1[30] = "People's Republic of";
    char str2[] = "China";
    strcat_s(str1, 30, str2);
    printf("%s\n", str1);
    return 0;
}
//People's Republic ofChina
//
strcat_s参数不对，缺少参数；
#include"stdafx.h"
#include<stdio.h>
#include<string.h>
int main()
{
char str1[30] = {"People's Republic of"};
char str2[] = {"China"};
printf("%s\n", strcat_s(str1, 30， str2));
        return 0;
}
引用 2 楼 cfjtaishan 的回复:strcat_s参数不对，缺少参数；
#include"stdafx.h"
#include<stdio.h>
#include<string.h>
int main()
{
char str1[30] = {"People's Republic of"};
char str2[] = {"China"};
printf("%s\n", strcat_s(str1, 30， str2));
        return 0;
} 
看看楼上MSDN节选中strcat_s的返回值是啥吧！想当然害死人的。
引用 3 楼 zhao4zhong1 的回复:Quote: 引用 2 楼 cfjtaishan 的回复:
strcat_s参数不对，缺少参数；
#include"stdafx.h"
#include<stdio.h>
#include<string.h>
int main()
{
char str1[30] = {"People's Republic of"};
char str2[] = {"China"};
printf("%s\n", strcat_s(str1, 30， str2));
        return 0;
} 
看看楼上MSDN节选中strcat_s的返回值是啥吧！想当然害死人的。
它和strcat不一样呗，不一样的库。

#include"stdafx.h"
#include<stdio.h>
#include<string.h>
int main()
{
char str1[30] = {"People's Republic of"};
char str2[] = {"China"};
strcat_s(str1, 30， str2);
printf("%s\n", str1);
        return 0;
}
谢谢热心的你们吗


为什么在c语言头文件中函数的声明是下划线格式的，但我们引用时可以不加下划线  _ ?本帖最后由 MHLAH 于 2017-10-26 15:53:42 编辑

c
c++
函数
头文件
声明


如下所示：
VS IDE中，在不明白的符号上点鼠标右键，选转到定义。
这些  “—” 下划线前缀的函数的 不是 C语言标准定义的函数，所以加了个  _  区别出来。
对于函数 好像 使用的时候  _fun 和 fun 没区别吧
http://www.cnblogs.com/zhulin/archive/2011/12/27/2303398.html
有一部分原因是区分是系统函数或库函数还是自定义函数；系统或库函数一般前加_下划线，主要会和用户自己定义的函数名不冲突
http://bbs.csdn.net/topics/390471598


萌新求教，关于内存分配的问题#include<stdlib.h>
strcut name {
         char * fname;
};
------------------------------------------------------------------------------------
int main(void) {
           struct name * my_name;
           my_name->fname=(char *)malloc(10*sizeof(char));
           return 0;
}
当然这样是错的 （为什么）
-------------------------------------------------------------------------------------
int main(void) {
         struct name * my_name;
         my_name=(struct name *)malloc(siezeof(struct name));
         return 0;
}
这是对的
-------------------------------------------------------------------------------------
int main(void) {
          struct name my_name;
          my_name.fname=(char *)malloc(10*sizeof(char));
         return 0;
}
这是对的。
好吧 我感觉自己找到答案了，因为指针初始化的问题。
struct name * my_name;
这样定义的是一个野指针，对于野指针的使用是未定义的，有可能会导致段错误；
通过malloc之后，my_name指针就指向的堆上的空间，堆上的空间就是可以正常访问了。
int  main（void） {
          struct name * my_name;
          my_name=(struct name *)malloc(siezeof(struct name));
          my_name->fname=(char *)malloc(10*sizeof(char));
          return 0;
} 这样就可以了......
作为一个金融专业的，我TM为什么要看C语言呢.............
因为你年轻，精力旺盛！

帮结帖＋蹭分


用codeblocks向main函数传递参数，控制台输出乱码大家好，在学习c语言指针这一章时，谭四版有个例子：

#include "stdio.h"

int main(int argc,char *argv[])
{
    while(argc>1)
    {
        ++argv;
        printf("%s\n",argv);
        --argc;
    }
    return 0;
}


我用的IDE是codeblocks（自带mingw），想试验一下这个例子。
百度一下，网上很多帖子说是将传给main的参数在project-set programs' arguments-program arguments里填入就可以了。我也照着做，填入后，点击OK，再点击运行程序（绿色的箭头符号），控制台输出的是乱码。
请问这是怎么回事呢？
printf("%s\n", argv[0]);
#include<stdio.h>
int main(int argc, char* argv[])
{

    printf("You have inputed total %d argments\n", argc);
    for (int  i = 0 ; i < argc ; i++) {
        printf("arg%d : %s\n", i, argv[i]);
    }

    return 0;
}


你学的教材不行，学参数 应该要这样的代码，这样才好理解
命令行参数  如图中所示

*argv 这个指针，实际 指向 argv[0] .  ++ argv后就指向了  argv[1] 
楼主的代码 正确的写法应该如下面 ，不过这样写，感觉在给自己挖坑

#include <stdio.h>

int main(int argc, char* argv[])
{
    while (argc > 1) {
        ++argv;
        printf("%s\n", *argv);
        --argc;
    }
    return 0;
}
#include <stdio.h>

int main(int argc,char *argv[])
{
    while(argc>1)
    {
        ++argv;
        printf("%s\n", *argv); //用*argv
        --argc;
    }
    return 0;
}
用*argv，注意argv的类型是char **是字符类型的的指针数组
下载了电子版 
教程 确实是错了， 少了  *
#include <stdio.h>

int main(int argc, char* argv[])
{
    while (argc-- > 1) {
        printf("%s\n", *++argv);
    }
    return 0;
}

更加挖坑的写法，这个运行是正确的
引用 3 楼 hongwenjun 的回复:
命令行参数  如图中所示

*argv 这个指针，实际 指向 argv[0] .  ++ argv后就指向了  argv[1] 
楼主的代码 正确的写法应该如下面 ，不过这样写，感觉在给自己挖坑

#include <stdio.h>

int main(int argc, char* argv[])
{
    while (argc > 1) {
        ++argv;
        printf("%s\n", *argv);
        --argc;
    }
    return 0;
}

非常感谢。
现在被谭书的指针绕的云里雾里的
引用 6 楼 hongwenjun 的回复:#include <stdio.h>

int main(int argc, char* argv[])
{
    while (argc-- > 1) {
        printf("%s\n", *++argv);
    }
    return 0;
}

更加挖坑的写法，这个运行是正确的
对于指针数组，例如char *s[]={"abc","123"};，既然s[0

引用 6 楼 hongwenjun 的回复:#include <stdio.h>

int main(int argc, char* argv[])
{
    while (argc-- > 1) {
        printf("%s\n", *++argv);
    }
    return 0;
}

更加挖坑的写法，这个运行是正确的
您好，“挖坑的写法”是指使用指针变量吗？
http://bbs.csdn.net/topics/390469280
引用 9 楼 zhao4zhong1 的回复:http://bbs.csdn.net/topics/390469280
多谢赵老师
#include <stdio.h>

// int main(int argc, char* argv[])
int main()

{
    char* s[] = {"myexe", "abc", "123"};
    int argc = 3;

    char** argv = s;

    while (argc > 1) {
        ++argv;   // 指向 s[1];
        printf("%s\n", *argv); //用*argv
        --argc;  //(3-1)
    }

    return 0;
}

实际是这样的


救急！!！江湖救急！！！拜托各位大佬了！！！C++
C语言

                  各位大佬帮忙看一下我写的这个程序出了什么错？该怎么改呢？
main函数的返回值，一般会定义为int类型，这是其一；
其二，double类型都是以%lf输出，以%f输出会将数据截断，或者得到错误的值。
其三，函数声明，老式的编程风格是将函数声明放在main函数里，新的编译器要求放在main外，main之前，做到函数的使用也是先声明后使用。这也是编译器提示的error问题。
楼上正解！
18行，24行前面多一个；（ps能不能把行号打开，数半天）


win7 64位 vs2010连接redis.lib,发生连接错误vs2010;redis;
C++;

                  我在window7 64位操作系统下，使用vs2010，编译一个程序，工程是release版64位。编译没有错误，但是在连接redis.lib 是发生连接错误。（说明：redis是2.6版本的）这是redis的编译lib的工程。其中包括连接lib的运行是库等配置都是没有问题的。因为我以前在window 32 位编译 32位工程，没有问题。现在把连接报错贴出来

1>------ 已启动生成: 项目: test, 配置: Debug Win32 ------
1>LINK : warning LNK4098: 默认库“LIBCMTD”与其他库的使用冲突；请使用 /NODEFAULTLIB:library
1>hiredis.lib(hiredis.obj) : error LNK2019: 无法解析的外部符号 _strerror_r，该符号在函数 ___redisSetError 中被引用
1>hiredis.lib(net.obj) : error LNK2001: 无法解析的外部符号 _strerror_r
1>hiredis.lib(net.obj) : error LNK2019: 无法解析的外部符号 _replace_setsockopt，该符号在函数 _redisContextSetTimeout 中被引用
1>C:\Users\Administrator\Desktop\test\Debug\test.exe : fatal error LNK1120: 2 个无法解析的外部命令
========== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ==========

代码更简单：
#include "stdafx.h"
#include "hiredis.h"
#include <iostream>

using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	struct timeval tv;
    int timeout=1000;
	tv.tv_sec = timeout / 1000;
	tv.tv_usec = timeout % 1000;
	redisContext *m_pContext = redisConnectWithTimeout("127.0.0.1",6379,tv);
	if( NULL == m_pContext || m_pContext->err)
	{
		if( NULL != m_pContext)
		{
			cout<<"redisClient connection error:" << m_pContext->errstr<<" ;errcode : "<< m_pContext->err;
			redisFree(m_pContext);
			m_pContext = NULL;
		}
		return -1;
	}
	//redisSetTimeout(m_pContext, tv);

	return 0;
}


求大神解决！！！！！！！！！
你认为是 release ，但你贴出来的内容第一行就写明是 debug
hiredis windows 版生成 hiredis.lib, 还有一个库提供 strerror_r() 等函数，链接加上该库才行。
如 https://github.com/Microsoft/hiredis 还会有个 win32_interop.lib。
刚刚解决这样的问题，实在win10下利用VS2013环境下编译实现的。你的问题出在没有在Source Files中引入win32fixes.c文件，导致编译出现这一系列问题。我的测试代码如下：
#include <iostream>
#include <stdlib.h>
#include <string.h>
#include <hiredis.h>
extern "C"
{
#include <win32fixes.h>
}
#include <ICRSINT.H>
#include <windows.h>
#include "win32fixes.h"
using namespace std;
void redis()
{
	WSADATA wsaData;
	WSAStartup(MAKEWORD(2, 1), &wsaData);
	redisContext *c;
	redisReply *reply;
	char sCommand[256];
	sprintf(sCommand, "HSET ALARM_EVENT_TAB:%d LAST_CHANGE_TIME %d", 10,20);
	//excuteRedisCommand(sCommand);
	struct timeval timeout = { 1, 500000 }; // 1.5 seconds
	QSharedPointer<redisContext> pRedisContext = QSharedPointer<redisContext>(redisConnectWithTimeout((char*)"127.0.0.1", 6379, timeout));
	c = redisConnectWithTimeout((char*)"127.0.0.1", 6379, timeout);
	if (c->err) {
		printf("Connection error: %s\n", c->errstr);
		exit(1);
	}
	/* Set a key */
	reply = (redisReply *)redisCommand(c, "SET %s %s", "foo", "jingbodasb");
	printf("SET: %s\n", reply->str);
	freeReplyObject(reply);


	/* Try a GET and two INCR */
	reply = (redisReply *)redisCommand(c, "GET foo");
	printf("GET foo: %s\n", reply->str);
	freeReplyObject(reply);
}


int main(int argc, char *argv[])
{
	redis();
	return  0;

}

测试结果完全没问题
同问啊，楼主解决了吗？


c51单片机大神围观求解决，感谢！c51单片机

                  #include<reg52.h>
#define uchar unsigned char
uchar data text1[16] _at_0x60;
uchar xdata text2[16] _at_0x1000;
void main(void)
{
uchar i;
for(i=0;i<16;i++)
text1[i]=i;
for(i=0;i<16;i++)
text2[i]=text1[i];
while(1);
}
问题：用pointer指针写出以上C语言代码内容。
感谢各位有心好心的单片机大神，有会的希望帮小弟一把，感谢！
A[B]
*(A+B)
*(B+A)
B[A]
//以上四行等价

"abc"[1]
*("abc"+1)
*(1+"abc")
1["abc"]
//以上四行等价

A[0]
*(A)
0[A]
//以上三行等价
能具体点吗 ？这是一个例子吧，能具体写一下代码吗？这样能理解但还是不太清楚怎么写，感谢！
#include<reg52.h>
#define uchar unsigned char
uchar data text1[16] _at_0x60;
uchar xdata text2[16] _at_0x1000;
void main(void)
{
uchar i;
uchar *p1, *p2;

p1 = test1;
p2 = test2;
for (i = 0; i < 16; i++) {
    p1[i] = i;
    p2[i] = i;
}
/*
for(i=0;i<16;i++)
text1[i]=i;
for(i=0;i<16;i++)
text2[i]=text1[i];
*/
while(1);
}
这是一个for的还是指针的啊？


大家帮忙看看哪里的问题 输出错误本帖最后由 yqchilde 于 2017-10-25 09:21:58 编辑

c

                  #include <stdio.h>
#include <stdlib.h>

int main()
{
   int m,i;
   printf("please enter a number:");
   scanf("%d",&m);
   for (i=2;i<=m-1;i++)
    if (m%i==0)  break;
       if(i<m)
        printf("%d is not a prime number");
       else
          printf("%d is a prime number");
    return 0;

}
没有人在吗？
算法问题建议设置断点调试
百度搜索相关程序参考
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int m,i;
    printf("please enter a number:");
    scanf("%d",&m);
    for (i = 2;i< m;i++)
        if (m%i == 0)  break;
    if(i < m)
        printf("%d is not a prime number", m);   /*缺少参数*/
    else
        printf("%d is a prime number", m);    /*缺少参数*/
    return 0;

}
printf输出缺少参数；有%d后面就应该跟一个对应的整形参数（楼主的代码里缺少m）；
像这样的错误，编译器会提出警告的，建议你不要放过警告信息。
printf里面的%和变量的一一对应关系
scanf里面的%和变量以及变量前加不加&的一一对应关系
是C代码中非常容易出错的地方，而且通常编译还不出错。
所以在编译源代码之前值得专门仔细检查一遍甚至多遍。
楼上全是正解，
printf("%d is a prime number");编译器不知道%d打出什么。
printf("%d is a prime number", m);需要在后面 ， 分开， 输入要打印的变量。


稀疏矩阵加法问题求解数据结构

                  题目如下：
给出两个稀疏矩阵A和B，分别用三元组序列表示，求A+B 。
输入的第一行是3个整数 m, n, c ，表示矩阵A的行数、列数，以及非零元个数。其中 1 ≤ m, n ≤ 10000  , 0 < c < 7000
接下来c行，每行是一个三元组 (e, f, v) ，e表示行号，f表示列号，v表示该非零元的值。其中 0 ≤ e < m  ， 0 ≤ f < n
三元组按"行优先次序"存放。
接下来是对矩阵B的描述，格式同矩阵A。

首先输出A+B和矩阵的行数，列数，非零元素个数。
接着输出A+B和矩阵的三元组形式，一个一行。三元组各元之间用一个空格分隔。
按行优先次序输出。
测试数据
Sample Input
10 10 3
2 7 97
7 1 58
9 3 7
10 10 4
2 3 8
2 9 20
4 6 32
5 0 35
Sample Output
10 10 7
2 3 8
2 7 97
2 9 20
4 6 32
5 0 35
7 1 58
9 3 7

我的代码在2楼。测试输出的是
10 10 8
2 3 8
2 7 97
2 9 20
4 6 32
5 0 35
7 1 58
9 3 7
10 10 4
在oj提交是Runtime Error，求解问题出在哪
#include <stdio.h>
#include <malloc.h>
#define MAXSIZE 10002

typedef struct
{
    int i;
    int j;
    int e;
}Triple;
typedef struct
{
    int row;
    int col;
    int cnt;
    Triple data[MAXSIZE];
}Matrix;

int main()
{
    int k, n1, n2, n3, sum;
    Matrix *A, *B, *C;
    A = (Matrix *)malloc(sizeof(Matrix));
    B = (Matrix *)malloc(sizeof(Matrix));
    C = (Matrix *)malloc(sizeof(Matrix));

    scanf("%d%d%d", &A->row, &A->col, &A->cnt);
    for(k = 1; k <= A->cnt; k++)
        scanf("%d%d%d", &A->data[k].i, &A->data[k].j, &A->data[k].e);
    scanf("%d%d%d", &B->row, &B->col, &B->cnt);
    for(k = 1; k <= B->cnt; k++)
        scanf("%d%d%d", &B->data[k].i, &B->data[k].j, &B->data[k].e);

    C->row = A->row;
    C->col = A->col;
    C->cnt = 0;
    n1 = n2 = n3 = 1;

    //while(n1 <= A->cnt && n2 <= B->cnt)
    for(k = 1; k <= A->row; k++)
    {
        while(A->data[n1].i < k)
            n1++;
        while(B->data[n2].i < k)
            n2++;

        while(A->data[n1].i == k && B->data[n2].i == k)
        {
            if(A->data[n1].j == B->data[n2].j)
            {
                sum = A->data[n1].e + B->data[n2].e;
                if(sum)
                {
                    C->data[n3].i = k;
                    C->data[n3].j = A->data[n1].j;
                    C->data[n3].e = sum;
                    n3++;
                }
                n1++;
                n2++;
            }
            else if(A->data[n1].j > B->data[n2].j)
            {
                C->data[n3].i = k;
                C->data[n3].j = B->data[n2].j;
                C->data[n3].e = B->data[n2].e;
                n2++;
                n3++;
            }
            else
            {
                C->data[n3].i = k;
                C->data[n3].j = A->data[n1].j;
                C->data[n3].e = A->data[n1].e;
                n1++;
                n3++;
            }
        }
        while(A->data[n1].i == k)
        {
            C->data[n3].i = k;
            C->data[n3].j = A->data[n1].j;
            C->data[n3].e = A->data[n1].e;
            n1++;
            n3++;
        }
        while(B->data[n2].i == k)
        {
            C->data[n3].i = k;
            C->data[n3].j = B->data[n2].j;
            C->data[n3].e = B->data[n2].e;
            n2++;
            n3++;
        }
    }

    C->cnt = n3-1;
    printf("%d %d %d\n", A->row, A->col, C->cnt);
    for(k = 1; k <= C->cnt; k++)
        printf("%d %d %d\n", C->data[k].i, C->data[k].j, C->data[k].e);

    return 0;
}
我又写了个，结果测试输出是
10 10 5
2 3 8
2 7 97
2 9 20
4 6 32
5 0 35



#include <stdio.h>
#include <malloc.h>
#define MAXSIZE 10002

typedef struct
{
    int i;
    int j;
    int e;
}Triple;
typedef struct
{
    int row;
    int col;
    int cnt;
    Triple data[MAXSIZE];
}Matrix;

int main()
{
    int k, n1, n2, n3, sum;
    Matrix *A, *B, *C;
    A = (Matrix *)malloc(sizeof(Matrix));
    B = (Matrix *)malloc(sizeof(Matrix));
    C = (Matrix *)malloc(sizeof(Matrix));

    scanf("%d%d%d", &A->row, &A->col, &A->cnt);
    for(k = 1; k <= A->cnt; k++)
        scanf("%d%d%d", &A->data[k].i, &A->data[k].j, &A->data[k].e);
    scanf("%d%d%d", &B->row, &B->col, &B->cnt);
    for(k = 1; k <= B->cnt; k++)
        scanf("%d%d%d", &B->data[k].i, &B->data[k].j, &B->data[k].e);

    C->row = A->row;
    C->col = A->col;
    C->cnt = 0;
    n1 = n2 = n3 = 1;

    while(n1 <= A->cnt && n2 <= B->cnt)
    {
        if(A->data[n1].i == B->data[n2].i)
        {
            if(A->data[n1].j == B->data[n2].j)
            {
                sum = A->data[n1].e + B->data[n2].e;
                if(sum)
                {
                    C->data[n3].i = A->data[n1].i;
                    C->data[n3].j = A->data[n1].j;
                    C->data[n3].e = sum;
                    n3++;
                }
                n1++;
                n2++;
            }
            else if(A->data[n1].j > B->data[n2].j)
            {
                C->data[n3].i = B->data[n2].i;
                C->data[n3].j = B->data[n2].j;
                C->data[n3].e = B->data[n2].e;
                n2++;
                n3++;
            }
            else
            {
                C->data[n3].i = A->data[n1].i;
                C->data[n3].j = A->data[n1].j;
                C->data[n3].e = A->data[n1].e;
                n1++;
                n3++;
            }
        }
        if(A->data[n1].i < B->data[n2].i)
        {
            C->data[n3].i = A->data[n1].i;
            C->data[n3].j = A->data[n1].j;
            C->data[n3].e = A->data[n1].e;
            n1++;
            n3++;
        }
        else
        {
            C->data[n3].i = B->data[n2].i;
            C->data[n3].j = B->data[n2].j;
            C->data[n3].e = B->data[n2].e;
            n2++;
            n3++;
        }
    }

    C->cnt = n3-1;
    printf("%d %d %d\n", A->row, A->col, C->cnt);
    for(k = 1; k <= C->cnt; k++)
        printf("%d %d %d\n", C->data[k].i, C->data[k].j, C->data[k].e);

    return 0;
}


关于c语言的设计去处理文字的问题c

                  sum(item_num) 182
sum123

sum(item_num) 132
sum123

sum(item_num) NULL
sum123

想使用读文件操作把上面的东西读到代码中。
需要求出sum(item_num)后面的数相加，取和。如果是NULL则不取值，怎么实现呢？

求思路。最好简单点的思路。不想把代码写的太复杂
fopen, fgets，然后通过strsep_r解析，求sum, fclose
仅供参考：//NAME: essaie bla bla
//DIMENSION: 8
//DATA
//1  14  15
//2  11  10
//3  6   4
//4  7   13
//5  9   21
//6  19  3
//7  1   5
//8  8   8
//EOF
//
// 文本文件中可能还含有其他内容，但是需要用到的内容即以上

//比如data.txt:
//NAME: essaie bla bla
//其它内容
//DIMENSION: 8
//其它内容
//DATA
//其它内容
//1  14  15
//其它内容
//2  11  10
//其它内容
//3  6   4
//其它内容
//4  7   13
//其它内容
//5  9   21
//其它内容
//6  19  3
//其它内容
//7  1   5
//其它内容
//8  8   8
//其它内容
//EOF

// 目标是要获取NAME后字串，DIMENSION后数值，以及DATA以下的数值
// 其中NAME就是随便个字句，DIMENSION是城市数量，DATA以下是城市编号，X坐标，Y坐标
// 所有的这些将赋值给一个事先定义好的结构
#include <stdio.h>
#include <string.h>
#define MAXCPL   80   //每行最大字符数
#define MAXCITY  100  //每组数据中DATA最多项数，DIMENSION的最大值
#define MAXNAMEL 32   //NAME最大长度
struct S {
    char NAME[MAXNAMEL+1];
    int  DIMENSION;
    struct D {
        int NO;
        int X;
        int Y;
    } DATA[MAXCITY];
} s;
FILE *f;
int st,n,i;
char ln[MAXCPL];
int main() {
    f=fopen("data.txt","r");
    if (NULL==f) {
        printf("Can not open file data.txt!\n");
        return 1;
    }
    st=0;
    n=0;
    while (1) {
        if (NULL==fgets(ln,MAXCPL,f)) break;
        if (st==0) {
            if (1==sscanf(ln,"NAME: %31[^\n]",s.NAME)) st=1;
        } else if (st==1) {
            if (1==sscanf(ln,"DIMENSION: %d",&s.DIMENSION)) st=2;
        } else if (st==2) {
            if (0==strcmp(ln,"DATA\n")) st=3;
        } else if (st==3) {
            if (3==sscanf(ln,"%d%d%d",&s.DATA[n].NO,&s.DATA[n].X,&s.DATA[n].Y)) {
                n++;
                if (n>=MAXCITY || n>=s.DIMENSION) break;
            }
        }
    }
    fclose(f);
    printf("s.NAME=[%s]\n",s.NAME);
    printf("s.DIMENSION=%d\n",s.DIMENSION);
    for (i=0;i<n;i++) {
        printf("s.DATA[%d].NO,X,Y=%d,%d,%d\n",i,s.DATA[i].NO,s.DATA[i].X,s.DATA[i].Y);
    }
    return 0;
}
//s.NAME=[essaie bla bla]
//s.DIMENSION=8
//s.DATA[0].NO,X,Y=1,14,15
//s.DATA[1].NO,X,Y=2,11,10
//s.DATA[2].NO,X,Y=3,6,4
//s.DATA[3].NO,X,Y=4,7,13
//s.DATA[4].NO,X,Y=5,9,21
//s.DATA[5].NO,X,Y=6,19,3
//s.DATA[6].NO,X,Y=7,1,5
//s.DATA[7].NO,X,Y=8,8,8
谢谢两位的提示。我已经用shell把这个问题处理了。


c51单片机大神帮忙看看，感谢！单片机、汇编

                  #include<reg52.h>
#define uchar unsigned char
uchar data text1[16] _at_0x60;
uchar xdata text2[16] _at_0x1000;
void main(void)
{
uchar i;
for(i=0;i<16;i++)
text1[i]=i;
for(i=0;i<16;i++)
text2[i]=text1[i];
while(1);
}
提出问题：1、用一个for实现以上代码内容；2、汇编语言实现以上代码内容。
希望有会的单片机大神给予帮助，在这小弟将感激涕零。
for(i=0;i<16;i++){
text1[i]=i;
text2[i]=text1[i];
}

编译器可以直接把c编译成汇编代码
非常感谢您的这代码,汇编能找到,但是太多太杂乱了,您能具体写一下上边这代码汇编有用的具体的内容吗?在这小弟先感谢了,谢谢!
两个循环合在一起，不就是一个循环完成了两个循环的操作；


qt 鼠标移动到加载完图片的label后，对label中的图片实现放大镜功能！鼠标一旦进入label和按键就会下沉到下面。后来重写QLabel还是不能实现该功能
难道没有人吗？
百度搜相关关键字。
用CB吧，秒速实现。


关于opengl的坐标转换的一个问题opengl

                  我在MFC里绘制opengl，我想在屏幕上可以实时显示鼠标位置对应的世界坐标，现在有一个很奇怪的问题，先贴代码

    GLint viewport[4];
    GLdouble mvmatrix[16], projmatrix[16];
    GLdouble realy,WinZ;  /*  OpenGL y coordinate position  */
    GLdouble wx, wy, wz;  /*  returned world x, y, z coords  */   
	
   
	 
	glGetIntegerv (GL_VIEWPORT, viewport);
	glGetDoublev (GL_PROJECTION_MATRIX, projmatrix);
        glGetDoublev (GL_MODELVIEW_MATRIX, mvmatrix);   
  
  /*  note viewport[3] is height of window in pixels  */
 
	realy = viewport[3] - sty ;

		glReadPixels(stx, sty, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &WinZ);	
		gluUnProject ((GLdouble)stx,(GLdouble) realy ,WinZ, mvmatrix, projmatrix, viewport, &wx, &wy, &wz);



我这么做了以后，如果深度不改变的话，我的坐标始终不变，就是在当前深度下，另外两个轴的坐标也都不变，我的Y轴是深度轴，不知道这个有没有影响。


还有就是如果我在第5行加上

     glTranslatef(0,objectDistance,0);                               //之前的移动
     glRotatef(objectAngleX,1,0,0);
     glRotatef(objectAngleY,0,0,1);
     glScalef(0.2,0.2,0.2);
     glTranslatef(x,y,z);

那么就可以随着鼠标的移动实时显示坐标，但是和真值相差十万八千里，请问该怎么办
搜网络教程“学OpenGL编3D游戏”。
有没有大佬帮看看啊，或者解释一下获得的模型矩阵以及投影矩阵各元素含义....
百度网页和百度图片搜相关关键字。


编程的基本运算编程实现各种运算，使用顺序队列和链队列，完成以下功能。
（1）初始化队列
（2）建立队列
（3）入队
（4）出队
（5）判断队列是否为空
（6）取对头元素
建议个人先写一写，有问题可以提出来。
百度搜相关关键字。


字符数组和字符指针的地址问题char *a 字符指针时  为什么a和&a的地址不同   却和&a[0]相同     而char b[]     字符数组     b和&b和&b[0]的地址都 相同  这是为什么  
还有就是  a[0] a[1] a[2] 和b[0] b[1] b[2] 的地址都是怎么变化的   求大佬解答。
a是指向字符串常量，那么a指针变量里存放的是字符串的地址，字符串在只读数据段，而指针变量a是在粘上申请，因此&a是变量a的地址，在栈上申请，那么就是栈地址。
&a[0]是指向字符串第一个字符的地址，那么改地址是在只读数据段，因此就是字符串的首地址。
同理，b变量是在栈上申请，字符串"You are a student..."是在栈上（注意这儿有一个copy，即字符串是常量，从只读数据段拷贝到栈上），因为b是数组，在栈上有内存空间，a是指针变量，只存放地址，因为不会将字符串拷贝至a中。

指针可以按照数组的形式使用。因此a[0]和b[0]都是一样的，取字符串的第一个字符；a[0] == *(a+0); a[1] == *(a + 1);  b[1] == *(b+1);
查看他们的变化，建议写个程序运行一下即可。
理解和讨论之前请先学会如何观察！

计算机组成原理→DOS命令→汇编语言→C语言（不包括C++）、代码书写规范→数据结构、编译原理、操作系统→计算机网络、数据库原理、正则表达式→其它语言（包括C++）、架构……

对学习编程者的忠告：
多用小脑和手，少用大脑、眼睛和嘴，会更快地学会编程！
眼过千遍不如手过一遍！
书看千行不如手敲一行！
手敲千行不如单步一行！
单步源代码千行不如单步Debug版对应汇编一行！
单步Debug版对应汇编千行不如单步Release版对应汇编一行！
不会单步Release版对应汇编？在你想单步Release版C/C++代码片断的前面临时加一句DebugBreak();重建所有，然后在IDE中运行。（一般人我不告诉他！）

VC调试时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
对VC来说，所谓‘调试时’就是编译连接通过以后，按F10或F11键单步执行一步以后的时候，或者在某行按F9设了断点后按F5执行停在该断点处的时候。
（Turbo C或Borland C用Turbo Debugger调试,Linux或Unix下用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）

想要从本质上理解C指针，必须学习汇编以及C和汇编的对应关系。
从汇编的角度理解和学习C语言的指针，原本看似复杂的东西就会变得非常简单！
指针即地址。“地址又是啥？”“只能从汇编语言和计算机组成原理的角度去解释了。”
但我又不得不承认：
 有那么些人喜欢或者适合用“先具体再抽象”的方法学习和理解复杂事物；
 而另一些人喜欢或者适合用“先抽象再具体”的方法学习和理解复杂事物。
而我本人属前者。

不要企图依赖输出指针相关表达式...的值【比如printf("%p\n",...);或者cout<<...】来理解指针的本质，
而要依赖调试时的反汇编窗口中的C/C++代码【比如void *p=(void *)(...);】及其对应汇编指令以及内存窗口中的内存地址和内存值来理解指针的本质。

这辈子不看内存地址和内存值；只画链表、指针示意图，画堆栈示意图，画各种示意图，甚至自己没画过而只看过书上的图……能从本质上理解指针、理解函数参数传递吗？本人深表怀疑！
这辈子不种麦不收麦不将麦粒拿去磨面；只吃馒头、吃面条、吃面包、……甚至从没看过别人怎么蒸馒头，压面条，烤面包，……能从本质上理解面粉、理解面食吗？本人深表怀疑！！

提醒：
“学习用汇编语言写程序”
和
“VC调试(TC或BC用TD调试)时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
（Linux或Unix下可以在用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）
想要从本质上理解C指针，必须学习C和汇编的对应关系。”
不是一回事！

不要迷信书、考题、老师、回帖；
要迷信CPU、编译器、调试器、运行结果。
并请结合“盲人摸太阳”和“驾船出海时一定只带一个指南针。”加以理解。
任何理论、权威、传说、真理、标准、解释、想象、知识……都比不上摆在眼前的事实！

有人说一套做一套，你相信他说的还是相信他做的？
其实严格来说这个世界上古往今来所有人都是说一套做一套，不是吗？

不要写连自己也预测不了结果的代码！

电脑内存或文件内容或传输内容只是一个一维二进制字节数组及其对应的二进制地址；
人脑才将电脑内存或文件内容或传输内容中的这个一维二进制字节数组及其对应的二进制地址的某些部分看成是整数、有符号数/无符号数、浮点数、复数、英文字母、阿拉伯数字、中文/韩文/法文……字符/字符串、汇编指令、函数、函数参数、堆、栈、数组、指针、数组指针、指针数组、数组的数组、指针的指针、二维数组、字符点阵、字符笔画的坐标、黑白二值图片、灰度图片、彩色图片、录音、视频、指纹信息、身份证信息……

十字链表交换任意两个节点C源代码（C指针应用终极挑战）http://download.csdn.net/detail/zhao4zhong1/5532495

http://edu.csdn.net/course/detail/2344 C语言指针与汇编内存地址-一.代码要素
http://edu.csdn.net/course/detail/2516 C语言指针与汇编内存地址-三.数组和二维数组


c++ ,新手问一个问题先上代码：

//banker.h
double count(double capital,double dayInterestRate,double day)
{
        if(day < 1)
        {
                cout<< capital <<endl; //这里输出的是对的
                return capital ;
        }
        else
        {
                count(capital*(dayInterestRate+1),dayInterestRate,--day);
        }
}

//main.cpp
int main()
{
        double cp = 0, dir = 0;
        double day = 0;
        cout<<"please input capital:";
        cin>>cp;
        cout<<"please input interest rate:";
        cin>>dir;
        cout<<"please input day:";
        cin>>day;
        cout<< count(cp,dir,day)<<endl;//这个输出的是nan
        return 0;
}

为什么在count函数里面,返回前的值是对的，在main函数里就显示nan呢？
#include <iostream>

using namespace std;

//banker.h
double count(double capital,double dayInterestRate,double day)
{
        if(day < 1)
        {
                cout<< capital <<endl; //这里输出的是对的
                return capital ;
        }
        else
        {
                return count(capital*(dayInterestRate+1),dayInterestRate,--day);
        }
}

//main.cpp
int main()
{
        double cp = 0, dir = 0;
        double day = 0;
        cout<<"please input capital:";
        cin>>cp;
        cout<<"please input interest rate:";
        cin>>dir;
        cout<<"please input day:";
        cin>>day;
        cout<< count(cp,dir,day)<<endl;//这个输出的是nan
        return 0;
}
试试这样
建议贴一下你的测试用例，会不会是越界了等原因
“给定一个小点的输入，完整单步跟踪(同时按Alt+7键查看Call Stack里面从上到下列出的对应从里层到外层的函数调用历史)一遍。”是理解递归函数工作原理的不二法门！
递归函数关注以下几个因素
·退出条件
·参数有哪些
·返回值是什么
·局部变量有哪些
·全局变量有哪些
·何时输出
·会不会导致堆栈溢出


字符串处理函数运行异常自己编写了一个字符串处理函数，想把输入的几个单个字符组合成一个字符串然后输出，编译没有错，输入字符回车后程序就停止运行，调试的时候运行到strcat_s(str,sizeof(str),DataRcv[i]);这一句的时候就直接结束了，都不知是什么原因，还请哪位大神指点一下，谢谢
#include<stdio.h> 
#include<string.h>
int main()[/b]
{
	char DataRcv[20], character;
	char str[20]="";
	int  i=0, j=0;
	printf("Enter text:\n");
	do
	{   
		character = getchar();
		DataRcv[i] = character;
	        strcat_s(str,sizeof(str),DataRcv[i]);	
                i++;
	} while (character!='\n');
    printf("%s\n", str);
}
#include<stdio.h>
#include<string.h>

int main()
{
    char DataRcv[20], character;
    char str[20]="";
    int  i=0, j=0;

    printf("Enter text:\n");
    do
    {
        character = getchar();
        DataRcv[i] = character;
        if (i >= 20)
           break;
        DataRcv[i+1] = 0;    /*字符串结束标记*/
        strcat_s(str, sizeof(str), &DataRcv[i]);
        i++;
    } while (character!='\n');
    printf("%s\n", str);
}
原因出在DataRcv不是字符串，字符串的其中一个标志就是有结束标记；若DataRcv不是字符串，那么和str通过strcat_s连接肯定会出问题（注意DataRcv没有初始化）
所以，每次调用strcat_s前都应该保证&DataRcv[i]是字符串；
另外，strcat_s的第三个参数是地址，不是字符，所以需要加&
困扰我好几天的问题终于解决了，非常感谢你。
我还有两个小问题想请教一下，字符串的结束标识符不应该是'\0'吗？另外我查了一下这个函数的原型是这样的errno_t strcat_s(char *strDestination,size_t numberOfElements,const char *strSource);第三个参数是不是相当于一个char型指针指向字符串的地址所以DataRcv的前面要加&？
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
建议使用标准库的std::string， 更安全更方便，而不是刀耕火种时代的char[]
引用 2 楼 qq_38546553 的回复:困扰我好几天的问题终于解决了，非常感谢你。
我还有两个小问题想请教一下，字符串的结束标识符不应该是'\0'吗？另外我查了一下这个函数的原型是这样的errno_t strcat_s(char *strDestination,size_t numberOfElements,const char *strSource);第三个参数是不是相当于一个char型指针指向字符串的地址所以DataRcv的前面要加&？
'\0' == 0即，字符串结束标记'\0'对应的数值就是0；
第三个参数是字符指针，即传的是地址，所以要加&


SPVMN平台注册失败gb28181最近在搞gb28181
在注册的时候死活不成功。
和网上的都兑了好十几遍了，也没发现问题
加密也是按照网上说的做的
HA1=MD5(username:realm:passwd) #username和realm在字段“Authorization”中可以找到，
passwd这个是由客户端和服务器协商得到的，一般情况下UAC端存一个UAS也知道的密码就行了
HA2=MD5(Method:Uri) #Method一般有INVITE, ACK, OPTIONS, BYE, CANCEL, REGISTER；
Uri可以在字段“Authorization”找到
response = MD5(HA1:nonce:HA2)
MD5的加密算法也验证过没问题
哪个大神可以指点一下迷津，看看是啥地方出错了

REGISTER sip:34020000002000000001@192.168.0.108:5060 SIP/2.0
Via: SIP/2.0/UDP 192.168.0.108:7788;rport=7788;branch=z9hG4bK2509000523;received=192.168.0.108
From: <sip:34020000001110000001@192.168.0.108>;tag=2577708869
To: <sip:34020000001110000001@192.168.0.108>
Call-ID: ms1214-322164710-681262131542511620107-0@192.168.0.108
CSeq: 1 REGISTER
Contact: <sip:34020000001320000001@192.168.0.108:7788;line=6513f93347c330b>
Max-Forwards: 70
User-Agent: eXosip/3.6.0
Expires: 3600
Authorization: Capability, algorithm="H:MD5"
Content-Length: 0


SIP/2.0 401 Unauthorized
CSeq: 1 REGISTER
Call-ID: ms1214-322164710-681262131542511620107-0@192.168.0.108
From: <sip:34020000001110000001@192.168.0.108>;tag=2577708869
To: <sip:34020000001110000001@192.168.0.108>;tag=75447840_53173353_687a1885-1718-4227-98e3-3c5e0b2f21fb
Via: SIP/2.0/UDP 192.168.0.108:7788;rport=7788;branch=z9hG4bK2509000523;received=192.168.0.108
WWW-Authenticate: Digest realm="34020000",nonce="ba4ceec21f98aa79"
Content-Length: 0


REGISTER sip:34020000002000000001@192.168.0.108:5060 SIP/2.0
Via: SIP/2.0/UDP 192.168.0.108:7788;rport=7788;branch=z9hG4bK2509000523;received=192.168.0.108
From: <sip:34020000001320000001@192.168.0.108>;tag=2577708869
To: <sip:34020000001320000001@192.168.0.108>
Call-ID: ms1214-322164710-681262131542511620107-0@192.168.0.108
CSeq: 2 REGISTER
Contact: <sip:34020000001320000001@192.168.0.108:7788;line=6513f93347c330b>
Max-Forwards: 70
User-Agent: eXosip/3.6.0
Authorization: Digest username="34020000001110000001",realm="34020000",nonce="ba4ceec21f98aa79",uri="sip:192.168.0.108:5060",response="8cbe6eded6af75d3cf89bb5d2a9c584f",algorithm=MD5
Expires: 3600
Content-Length: 0


SIP/2.0 403 Forbidden
CSeq: 2 REGISTER
Call-ID: ms1214-322164710-681262131542511620107-0@192.168.0.108
From: <sip:34020000001320000001@192.168.0.108>;tag=2577708869
To: <sip:34020000001320000001@192.168.0.108>;tag=04781339_53173353_d7187f95-b469-42b3-b924-6c99f2442ec4
Via: SIP/2.0/UDP 192.168.0.108:7788;rport=7788;branch=z9hG4bK2509000523;received=192.168.0.108
Content-Length: 0
百度搜相关关键字。
引用 1 楼 zhao4zhong1 的回复:百度搜相关关键字。
不是关键字的问题，内容我都是按照协议写的
我感觉是加密问题或者是平台配置问题
各位麻烦指点迷津
https://www.baidu.com/s?wd=PVMN%20gb28181
https://www.baidu.com/s?wd=SPVMN%20gb28181
没有人做过么？
有国标书吗？看下国标书很清晰，比对一下立马知道哪里错了
你这个问题解决了吗？我也碰到了
问题搞定了，这个是加密的时候没搞对


stl 里面的 map 是否自带锁的?今天调试程序的时候, 崩在图片上的位置了
发现 map 里面自带锁的?

vs2010 + win7
否
引用 1 楼 zhao4zhong1 的回复:否

那为什么程序会崩在加锁的地方???
崩溃的地方是从 std::map::begin() 函数一直深入进去的
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。

《Windows核心编程》
加不加锁，怎么加锁是实现问题。
标准规定容器的线程安全如下：
引用1. All container functions can be called concurrently by different threads on different containers. More generally, the C++ standard library functions do not read objects accessible by other threads unless those objects are directly or indirectly accessible via the function arguments, including the this pointer.

2. All const member functions can be called concurrently by different threads on the same container. In addition, the member functions begin(), end(), rbegin(), rend(), front(), back(), data(), find(), lower_bound(), upper_bound(), equal_range(), at(), and, except in associative containers, operator[], behave as const for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). More generally, the C++ standard library functions do not modify objects unless those objects are accessible, directly or indirectly, via the function's non-const arguments, including the this pointer.

3. Different elements in the same container can be modified concurrently by different threads, except for the elements of std::vector<bool> (for example, a vector of std::future objects can be receiving values from multiple threads).

4. Iterator operations (e.g. incrementing an iterator) read, but do not modify the underlying container, and may be executed concurrently with operations on other iterators on the same container, with the const member functions, or reads from the elements. Container operations that invalidate any iterators modify the container and cannot be executed concurrently with any operations on existing iterators even if those iterators are not invalidated.

5. Elements of the same container can be modified concurrently with those member functions that are not specified to access these elements. More generally, the C++ standard library functions do not read objects indirectly accessible through their arguments (including other elements of a container) except when required by its specification.

6. In any case, container operations (as well as algorithms, or any other C++ standard library functions) may be parallelized internally as long as this does not change the user-visible results (e.g. std::transform may be parallelized, but not std::for_each which is specified to visit each element of a sequence in order)
——http://en.cppreference.com/w/cpp/container
没加锁的，自己加一下，很简单的。
STL标准中未提出map为线程安全

std::map崩溃可能是迭代器访问失效？
应该没有加锁！我以前两个线程同时push_back一个list，结果挂了。
VC2010。
如果默认加锁的话，可能会影响到单线程操作的性能。
map标准是没有加锁的，需要进行加锁，代码里有个lock不代表是为了同步访问而去加锁，可能是为了其他需要，也可能是debug下的异常检测，具体取决于代码实现


为什么变量的内存数据一样，打印出来结果确不同呢？内存
浮点
c
编译
c++

#include <stdio.h>

int main()
{
	double a = -8.9993308495351441e+061; 	//vc6.0下生成的数值
	double b = 2.0674879979702547e-312; 	//mingw
	double c = 1.7802244858455987e-307;		//gcc
	double d = 3.3823769033946863e-306;		//gcc
    printf("%s\n%s\n%s\n%s\n", &a,&b,&c,&d);
    return 0;
}



我的疑惑是： 为啥输出的都是同一个字符串  竟然数值都还不一样， 我对double内存填充的 china 都是按顺序 填充的。 那得到的数值为啥不一样啊？
double占8个字节，而只打印了5个字节，说明第六个字节是0；这只能表明前六个字节内存一样，不能说明后边两个一样
引用 1 楼 hezhe1008 的回复:double占8个字节，而只打印了5个字节，说明第六个字节是0；这只能表明前六个字节内存一样，不能说明后边两个一样
正解
引用 2 楼 ananluowei 的回复:Quote: 引用 1 楼 hezhe1008 的回复:
double占8个字节，而只打印了5个字节，说明第六个字节是0；这只能表明前六个字节内存一样，不能说明后边两个一样
正解
更正一下，也许前面有几个字符是不可打印字符，不一定能说明前面6个字符一定相同
引用 1 楼 hezhe1008 的回复:double占8个字节，而只打印了5个字节，说明第六个字节是0；这只能表明前六个字节内存一样，不能说明后边两个一样

你说的对  后来我每个字节的输出内容  发现了不同编译器下未初始化的变量内存字节 是不确定的 
vc6在debug未初始化下的内存字节 就填充 0xcc  Release下也不确定   
未使用的内存字节  就不会被覆盖  所以就不一样了  说来还是不同编译器的编译模式下 为初始化的值 不一样
围观。。学习了。
来晚了，已经解决了，就混个脸熟吧。
哈哈！正解！
\0标志字符串的结束，字符串只解析到\0的位置，只要\0前面的字字一样，输出就一样的，只要其他字节不一样，就是不同的浮点数


QImage访问像素并保存时提示像素点超出范围！qt
图像处理
c++
越界



QImage source;
	source.load("source.png");
	std::vector<QRgb>sor;

	
	std::cout << sor.size();
	for (int i = 0; i < source.height(); i++)
		for (int j = 0; j <source.width(); j++)
			sor.push_back(QRgb(source.pixel(i, j)));
	RgbToLab(sor);

运行以上代码时，控制台输出：好多像素超出范围，程序终止并弹出对话框：vector下标超出范围。
调试的时候前几十个像素都能
求大神解答
前几十个像素都能正确的加入vector,但是这个循环总是运行不完就直接中止退出了
上面有一个小的失误，我把pixel函数的（i，j）换成了（j,i）这样的画他不显示像素超出范围了，但是显示vector下标超出范围
崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。
我已经自己解决了，，，，我下面调用函数  用的是auto自动测定的QRgb变量，确实越界了~~~


